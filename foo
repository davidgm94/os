/* automatically generated by rust-bindgen 0.59.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC2X_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_ISOCXX11: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const __USE_XOPEN: u32 = 1;
pub const __USE_XOPEN_EXTENDED: u32 = 1;
pub const __USE_UNIX98: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __USE_XOPEN2K8XSI: u32 = 1;
pub const __USE_XOPEN2KXSI: u32 = 1;
pub const __USE_LARGEFILE: u32 = 1;
pub const __USE_LARGEFILE64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_GNU: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 33;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 0;
pub const __GLIBC_USE_LIB_EXT2: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const INT8_WIDTH: u32 = 8;
pub const UINT8_WIDTH: u32 = 8;
pub const INT16_WIDTH: u32 = 16;
pub const UINT16_WIDTH: u32 = 16;
pub const INT32_WIDTH: u32 = 32;
pub const UINT32_WIDTH: u32 = 32;
pub const INT64_WIDTH: u32 = 64;
pub const UINT64_WIDTH: u32 = 64;
pub const INT_LEAST8_WIDTH: u32 = 8;
pub const UINT_LEAST8_WIDTH: u32 = 8;
pub const INT_LEAST16_WIDTH: u32 = 16;
pub const UINT_LEAST16_WIDTH: u32 = 16;
pub const INT_LEAST32_WIDTH: u32 = 32;
pub const UINT_LEAST32_WIDTH: u32 = 32;
pub const INT_LEAST64_WIDTH: u32 = 64;
pub const UINT_LEAST64_WIDTH: u32 = 64;
pub const INT_FAST8_WIDTH: u32 = 8;
pub const UINT_FAST8_WIDTH: u32 = 8;
pub const INT_FAST16_WIDTH: u32 = 64;
pub const UINT_FAST16_WIDTH: u32 = 64;
pub const INT_FAST32_WIDTH: u32 = 64;
pub const UINT_FAST32_WIDTH: u32 = 64;
pub const INT_FAST64_WIDTH: u32 = 64;
pub const UINT_FAST64_WIDTH: u32 = 64;
pub const INTPTR_WIDTH: u32 = 64;
pub const UINTPTR_WIDTH: u32 = 64;
pub const INTMAX_WIDTH: u32 = 64;
pub const UINTMAX_WIDTH: u32 = 64;
pub const PTRDIFF_WIDTH: u32 = 64;
pub const SIG_ATOMIC_WIDTH: u32 = 32;
pub const SIZE_WIDTH: u32 = 64;
pub const WCHAR_WIDTH: u32 = 32;
pub const WINT_WIDTH: u32 = 32;
pub const __GNUC_VA_LIST: u32 = 1;
pub const ES_PERMISSION_NETWORKING: u32 = 1;
pub const ES_PERMISSION_PROCESS_CREATE: u32 = 2;
pub const ES_PERMISSION_PROCESS_OPEN: u32 = 4;
pub const ES_PERMISSION_SCREEN_MODIFY: u32 = 8;
pub const ES_PERMISSION_SHUTDOWN: u32 = 16;
pub const ES_PERMISSION_TAKE_SYSTEM_SNAPSHOT: u32 = 32;
pub const ES_PERMISSION_GET_VOLUME_INFORMATION: u32 = 64;
pub const ES_PERMISSION_WINDOW_MANAGER: u32 = 128;
pub const ES_PERMISSION_POSIX_SUBSYSTEM: u32 = 256;
pub const CC_ACCESS_MAP: u32 = 1;
pub const CC_ACCESS_READ: u32 = 2;
pub const CC_ACCESS_WRITE: u32 = 4;
pub const CC_ACCESS_WRITE_BACK: u32 = 8;
pub const CC_ACCESS_PRECISE: u32 = 16;
pub const CC_ACCESS_USER_BUFFER_MAPPED: u32 = 32;
pub const ES_MEMORY_OPEN_FAIL_IF_FOUND: u32 = 4096;
pub const ES_MEMORY_OPEN_FAIL_IF_NOT_FOUND: u32 = 8192;
pub const ES_THREAD_EVENT_MUTEX_ACQUIRE: u32 = 1;
pub const ES_THREAD_EVENT_MUTEX_RELEASE: u32 = 2;
pub const K_MAX_PROCESSORS: u32 = 256;
pub const _ES_NODE_FROM_WRITE_EXCLUSIVE: u32 = 131072;
pub const _ES_NODE_DIRECTORY_WRITE: u32 = 262144;
pub const _ES_NODE_NO_WRITE_BASE: u32 = 524288;
pub const ES_ERROR_BUFFER_TOO_SMALL: i32 = -2;
pub const ES_ERROR_UNKNOWN: i32 = -7;
pub const ES_ERROR_NO_MESSAGES_AVAILABLE: i32 = -9;
pub const ES_ERROR_MESSAGE_QUEUE_FULL: i32 = -10;
pub const ES_ERROR_PATH_NOT_WITHIN_MOUNTED_VOLUME: i32 = -14;
pub const ES_ERROR_PATH_NOT_TRAVERSABLE: i32 = -15;
pub const ES_ERROR_FILE_ALREADY_EXISTS: i32 = -19;
pub const ES_ERROR_FILE_DOES_NOT_EXIST: i32 = -20;
pub const ES_ERROR_DRIVE_ERROR_FILE_DAMAGED: i32 = -21;
pub const ES_ERROR_ACCESS_NOT_WITHIN_FILE_BOUNDS: i32 = -22;
pub const ES_ERROR_PERMISSION_NOT_GRANTED: i32 = -23;
pub const ES_ERROR_FILE_IN_EXCLUSIVE_USE: i32 = -24;
pub const ES_ERROR_FILE_CANNOT_GET_EXCLUSIVE_USE: i32 = -25;
pub const ES_ERROR_INCORRECT_NODE_TYPE: i32 = -26;
pub const ES_ERROR_EVENT_NOT_SET: i32 = -27;
pub const ES_ERROR_FILE_HAS_WRITERS: i32 = -28;
pub const ES_ERROR_TIMEOUT_REACHED: i32 = -29;
pub const ES_ERROR_FILE_ON_READ_ONLY_VOLUME: i32 = -32;
pub const ES_ERROR_INVALID_DIMENSIONS: i32 = -34;
pub const ES_ERROR_DRIVE_CONTROLLER_REPORTED: i32 = -35;
pub const ES_ERROR_COULD_NOT_ISSUE_PACKET: i32 = -36;
pub const ES_ERROR_HANDLE_TABLE_FULL: i32 = -37;
pub const ES_ERROR_COULD_NOT_RESIZE_FILE: i32 = -38;
pub const ES_ERROR_DIRECTORY_NOT_EMPTY: i32 = -39;
pub const ES_ERROR_NODE_DELETED: i32 = -41;
pub const ES_ERROR_VOLUME_MISMATCH: i32 = -43;
pub const ES_ERROR_TARGET_WITHIN_SOURCE: i32 = -44;
pub const ES_ERROR_TARGET_INVALID_TYPE: i32 = -45;
pub const ES_ERROR_MALFORMED_NODE_PATH: i32 = -47;
pub const ES_ERROR_TARGET_IS_SOURCE: i32 = -49;
pub const ES_ERROR_INVALID_NAME: i32 = -50;
pub const ES_ERROR_CORRUPT_DATA: i32 = -51;
pub const ES_ERROR_INSUFFICIENT_RESOURCES: i32 = -52;
pub const ES_ERROR_UNSUPPORTED_FEATURE: i32 = -53;
pub const ES_ERROR_FILE_TOO_FRAGMENTED: i32 = -54;
pub const ES_ERROR_DRIVE_FULL: i32 = -55;
pub const ES_ERROR_COULD_NOT_RESOLVE_SYMBOL: i32 = -56;
pub const ES_ERROR_ALREADY_EMBEDDED: i32 = -57;
pub const ES_ERROR_UNSUPPORTED_CONVERSION: i32 = -60;
pub const ES_ERROR_SOURCE_EMPTY: i32 = -61;
pub const ES_ERROR_UNSUPPORTED_EXECUTABLE: i32 = -62;
pub const ES_ERROR_NO_ADDRESS_FOR_DOMAIN_NAME: i32 = -63;
pub const ES_ERROR_NO_CONNECTED_NETWORK_INTERFACES: i32 = -64;
pub const ES_ERROR_BAD_DOMAIN_NAME: i32 = -65;
pub const ES_ERROR_LOST_IP_ADDRESS: i32 = -66;
pub const ES_ERROR_CONNECTION_RESET: i32 = -67;
pub const ES_ERROR_CONNECTION_REFUSED: i32 = -68;
pub const ES_ERROR_ILLEGAL_PATH: i32 = -69;
pub const ES_ERROR_NODE_NOT_LOADED: i32 = -71;
pub const ES_ERROR_DIRECTORY_ENTRY_BEING_REMOVED: i32 = -72;
pub const ES_ERROR_CANCELLED: i32 = -73;
pub const ES_ERROR_BLOCK_ACCESS_INVALID: i32 = -74;
pub const ES_ERROR_DEVICE_REMOVED: i32 = -75;
pub const ES_ERROR_TOO_MANY_FILES_WITH_NAME: i32 = -76;
pub const CC_WAIT_FOR_WRITE_BEHIND: u32 = 1000;
pub const CC_WRITE_BACK_DIVISOR: u32 = 8;
pub const MM_ZERO_PAGE_THRESHOLD: u32 = 16;
pub const MM_OBJECT_CACHE_TRIM_GROUP_COUNT: u32 = 1024;
pub const PHYSICAL_MEMORY_MANIPULATION_REGION_PAGES: u32 = 16;
pub const POOL_CACHE_COUNT: u32 = 16;
pub const ES_SUCCESS: i32 = -1;
pub const ES_WAIT_NO_TIMEOUT: i32 = -1;
pub const ES_MAX_WAIT_COUNT: u32 = 8;
pub const ES_NODE_FILE: u32 = 0;
pub const ES_NODE_DIRECTORY: u32 = 16;
pub const ES_NODE_INVALID: u32 = 32;
pub const ES_FLAGS_DEFAULT: u32 = 0;
pub const ES_NODE_FAIL_IF_FOUND: u32 = 4096;
pub const ES_NODE_FAIL_IF_NOT_FOUND: u32 = 8192;
pub const ES_NODE_PREVENT_RESIZE: u32 = 16384;
pub const ES_NODE_CREATE_DIRECTORIES: u32 = 32768;
pub const NODE_MAX_ACCESSORS: u32 = 16777216;
pub const NODE_HAS_EXCLUSIVE_WRITER: u32 = 1;
pub const NODE_ENUMERATED_ALL_DIRECTORY_ENTRIES: u32 = 2;
pub const NODE_CREATED_ON_FILE_SYSTEM: u32 = 4;
pub const NODE_DELETED: u32 = 8;
pub const NODE_MODIFIED: u32 = 16;
pub const NODE_IN_CACHE_LIST: u32 = 32;
pub const FS_NODE_OPEN_HANDLE_STANDARD: u32 = 0;
pub const FS_NODE_OPEN_HANDLE_FIRST: u32 = 1;
pub const FS_NODE_OPEN_HANDLE_DIRECTORY_TEMPORARY: u32 = 2;
pub const ES_FILE_READ_SHARED: u32 = 1;
pub const ES_FILE_READ: u32 = 2;
pub const ES_FILE_WRITE_SHARED: u32 = 4;
pub const ES_FILE_WRITE: u32 = 8;
pub const MM_REGION_FIXED: u32 = 1;
pub const MM_REGION_NOT_CACHEABLE: u32 = 2;
pub const MM_REGION_NO_COMMIT_TRACKING: u32 = 4;
pub const MM_REGION_READ_ONLY: u32 = 8;
pub const MM_REGION_COPY_ON_WRITE: u32 = 16;
pub const MM_REGION_WRITE_COMBINING: u32 = 32;
pub const MM_REGION_EXECUTABLE: u32 = 64;
pub const MM_REGION_USER: u32 = 128;
pub const K_PAGE_BITS: u32 = 12;
pub const K_PAGE_SIZE: u32 = 4096;
pub const MM_CORE_REGIONS_START: i64 = -140729166856192;
pub const MM_KERNEL_SPACE_START: i64 = -123145302310912;
pub const MM_KERNEL_SPACE_SIZE: u64 = 105553116266496;
pub const MM_MODULES_START: i32 = -1879048192;
pub const MM_MODULES_SIZE: u32 = 805306368;
pub const MM_CORE_SPACE_START: i64 = -140733193388032;
pub const MM_CORE_SPACE_SIZE: u32 = 4026531840;
pub const MM_USER_SPACE_START: u64 = 17592186044416;
pub const MM_USER_SPACE_SIZE: u64 = 246290604621824;
pub const LOW_MEMORY_MAP_START: i64 = -2199023255552;
pub const LOW_MEMORY_LIMIT: u64 = 4294967296;
pub const LARGE_ALLOCATION_THRESHOLD: u32 = 32768;
pub const USED_HEAP_REGION_MAGIC: u32 = 43981;
pub const MM_MAP_PAGE_NOT_CACHEABLE: u32 = 1;
pub const MM_MAP_PAGE_USER: u32 = 2;
pub const MM_MAP_PAGE_OVERWRITE: u32 = 4;
pub const MM_MAP_PAGE_COMMIT_TABLES_NOW: u32 = 8;
pub const MM_MAP_PAGE_READ_ONLY: u32 = 16;
pub const MM_MAP_PAGE_COPIED: u32 = 32;
pub const MM_MAP_PAGE_NO_NEW_TABLES: u32 = 64;
pub const MM_MAP_PAGE_FRAME_LOCK_ACQUIRED: u32 = 128;
pub const MM_MAP_PAGE_WRITE_COMBINING: u32 = 256;
pub const MM_MAP_PAGE_IGNORE_IF_MAPPED: u32 = 512;
pub const MM_UNMAP_PAGES_FREE: u32 = 1;
pub const MM_UNMAP_PAGES_FREE_COPIED: u32 = 2;
pub const MM_UNMAP_PAGES_BALANCE_FILE: u32 = 4;
pub const MM_HANDLE_PAGE_FAULT_WRITE: u32 = 1;
pub const MM_HANDLE_PAGE_FAULT_LOCK_ACQUIRED: u32 = 2;
pub const MM_HANDLE_PAGE_FAULT_FOR_SUPERVISOR: u32 = 4;
pub const MM_REGION_PHYSICAL: u32 = 256;
pub const MM_REGION_NORMAL: u32 = 512;
pub const MM_REGION_SHARED: u32 = 1024;
pub const MM_REGION_GUARD: u32 = 2048;
pub const MM_REGION_CACHE: u32 = 4096;
pub const MM_REGION_FILE: u32 = 8192;
pub const MM_SHARED_ENTRY_PRESENT: u32 = 1;
pub const MM_PHYSICAL_ALLOCATE_CAN_FAIL: u32 = 1;
pub const MM_PHYSICAL_ALLOCATE_COMMIT_NOW: u32 = 2;
pub const MM_PHYSICAL_ALLOCATE_ZEROED: u32 = 4;
pub const MM_PHYSICAL_ALLOCATE_LOCK_ACQUIRED: u32 = 8;
pub const K_DEVICE_REMOVED: u32 = 1;
pub const K_DEVICE_VISIBLE_TO_USER: u32 = 2;
pub const ES_SNAPSHOT_MAX_PROCESS_NAME_LENGTH: u32 = 31;
pub const THREAD_PRIORITY_NORMAL: u32 = 0;
pub const THREAD_PRIORITY_LOW: u32 = 1;
pub const THREAD_PRIORITY_COUNT: u32 = 2;
pub const FILE_STORE_HANDLE: u32 = 1;
pub const FILE_STORE_PATH: u32 = 2;
pub const FILE_STORE_EMBEDDED_FILE: u32 = 3;
pub const MESSAGE_QUEUE_MAX_LENGTH: u32 = 4096;
pub const HANDLE_TABLE_L2_ENTRIES: u32 = 256;
pub const HANDLE_TABLE_L1_ENTRIES: u32 = 256;
pub const RESOLVE_HANDLE_FAILED: u32 = 0;
pub const RESOLVE_HANDLE_NO_CLOSE: u32 = 1;
pub const RESOLVE_HANDLE_NORMAL: u32 = 2;
pub const SPAWN_THREAD_USERLAND: u32 = 1;
pub const SPAWN_THREAD_LOW_PRIORITY: u32 = 2;
pub const SPAWN_THREAD_PAUSED: u32 = 4;
pub const SPAWN_THREAD_ASYNC_TASK: u32 = 8;
pub const SPAWN_THREAD_IDLE: u32 = 16;
pub const L1_COMMIT_SIZE_BYTES: u32 = 8388608;
pub const L1_COMMIT_COMMIT_SIZE_BYTES: u32 = 256;
pub const L2_COMMIT_SIZE_BYTES: u32 = 16384;
pub const L3_COMMIT_SIZE_BYTES: u32 = 32;
pub const ES_SHARED_MEMORY_NAME_MAX_LENGTH: u32 = 32;
pub const BITSET_GROUP_SIZE: u32 = 4096;
pub const K_PCI_FEATURE_BAR_0: u32 = 1;
pub const K_PCI_FEATURE_BAR_1: u32 = 2;
pub const K_PCI_FEATURE_BAR_2: u32 = 4;
pub const K_PCI_FEATURE_BAR_3: u32 = 8;
pub const K_PCI_FEATURE_BAR_4: u32 = 16;
pub const K_PCI_FEATURE_BAR_5: u32 = 32;
pub const K_PCI_FEATURE_INTERRUPTS: u32 = 256;
pub const K_PCI_FEATURE_BUSMASTERING_DMA: u32 = 512;
pub const K_PCI_FEATURE_MEMORY_SPACE_ACCESS: u32 = 1024;
pub const K_PCI_FEATURE_IO_PORT_ACCESS: u32 = 2048;
pub const K_ACCESS_READ: u32 = 0;
pub const K_ACCESS_WRITE: u32 = 1;
pub const FS_BLOCK_ACCESS_CACHED: u32 = 1;
pub const FS_BLOCK_ACCESS_SOFT_ERRORS: u32 = 2;
pub const ES_GAME_CONTROLLER_MAX_COUNT: u32 = 16;
pub const PIPE_READER: u32 = 1;
pub const PIPE_WRITER: u32 = 2;
pub const PIPE_BUFFER_SIZE: u32 = 4096;
pub const PIPE_CLOSED: u32 = 0;
pub const RESIZE_FLICKER_TIMEOUT_MS: u32 = 40;
pub const RESIZE_SLOW_THRESHOLD: u32 = 30;
pub const SIGNATURE_RSDP: u64 = 2329016660419433298;
pub const SIGNATURE_RSDT: u32 = 1413763922;
pub const SIGNATURE_XSDT: u32 = 1413763928;
pub const SIGNATURE_MADT: u32 = 1128878145;
pub const SIGNATURE_FADT: u32 = 1346584902;
pub const SIGNATURE_HPET: u32 = 1413828680;
pub const ACPI_DESCRIPTOR_TABLE_HEADER_LENGTH: u32 = 36;
pub const TIMER_INTERRUPT: u32 = 64;
pub const YIELD_IPI: u32 = 65;
pub const IRQ_BASE: u32 = 80;
pub const CALL_FUNCTION_ON_ALL_PROCESSORS_IPI: u32 = 240;
pub const TLB_SHOOTDOWN_IPI: u32 = 241;
pub const KERNEL_PANIC_IPI: u32 = 0;
pub const INTERRUPT_VECTOR_MSI_START: u32 = 112;
pub const INTERRUPT_VECTOR_MSI_COUNT: u32 = 64;
pub const INVALIDATE_ALL_PAGES_THRESHOLD: u32 = 1024;
pub const ENTRIES_PER_PAGE_TABLE: u32 = 512;
pub const ENTRIES_PER_PAGE_TABLE_BITS: u32 = 9;
pub const IO_PIC_1_COMMAND: u32 = 32;
pub const IO_PIC_1_DATA: u32 = 33;
pub const IO_PIT_DATA: u32 = 64;
pub const IO_PIT_COMMAND: u32 = 67;
pub const IO_PS2_DATA: u32 = 96;
pub const IO_PC_SPEAKER: u32 = 97;
pub const IO_PS2_STATUS: u32 = 100;
pub const IO_PS2_COMMAND: u32 = 100;
pub const IO_RTC_INDEX: u32 = 112;
pub const IO_RTC_DATA: u32 = 113;
pub const IO_UNUSED_DELAY: u32 = 128;
pub const IO_PIC_2_COMMAND: u32 = 160;
pub const IO_PIC_2_DATA: u32 = 161;
pub const IO_BGA_INDEX: u32 = 462;
pub const IO_BGA_DATA: u32 = 463;
pub const IO_ATA_1: u32 = 368;
pub const IO_ATA_2: u32 = 496;
pub const IO_COM_4: u32 = 744;
pub const IO_COM_2: u32 = 760;
pub const IO_ATA_3: u32 = 886;
pub const IO_VGA_AC_INDEX: u32 = 960;
pub const IO_VGA_AC_WRITE: u32 = 960;
pub const IO_VGA_AC_READ: u32 = 961;
pub const IO_VGA_MISC_WRITE: u32 = 962;
pub const IO_VGA_MISC_READ: u32 = 972;
pub const IO_VGA_SEQ_INDEX: u32 = 964;
pub const IO_VGA_SEQ_DATA: u32 = 965;
pub const IO_VGA_DAC_READ_INDEX: u32 = 967;
pub const IO_VGA_DAC_WRITE_INDEX: u32 = 968;
pub const IO_VGA_DAC_DATA: u32 = 969;
pub const IO_VGA_GC_INDEX: u32 = 974;
pub const IO_VGA_GC_DATA: u32 = 975;
pub const IO_VGA_CRTC_INDEX: u32 = 980;
pub const IO_VGA_CRTC_DATA: u32 = 981;
pub const IO_VGA_INSTAT_READ: u32 = 986;
pub const IO_COM_3: u32 = 1000;
pub const IO_ATA_4: u32 = 1014;
pub const IO_COM_1: u32 = 1016;
pub const IO_PCI_CONFIG: u32 = 3320;
pub const IO_PCI_DATA: u32 = 3324;
pub const KERNEL_LOG_SIZE: u32 = 262144;
pub const VGA_FONT_WIDTH: u32 = 9;
pub const VGA_FONT_HEIGHT: u32 = 16;
pub const ES_STRING_FORMAT_SIMPLE: u32 = 1;
pub const ELLIPSIS: &'static [u8; 4usize] = b"\xE2\x80\xA6\0";
pub const HYPHENATION_POINT: &'static [u8; 4usize] = b"\xE2\x80\xA7\0";
pub const OPEN_SPEECH: &'static [u8; 4usize] = b"\xE2\x80\x9C\0";
pub const CLOSE_SPEECH: &'static [u8; 4usize] = b"\xE2\x80\x9D\0";
pub const SYSTEM_BRAND_SHORT: &'static [u8; 8usize] = b"Essence\0";
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type size_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type uint64_t_unaligned = u64;
pub type uint32_t_unaligned = u32;
pub type EsListViewIndex = i64;
pub type EsHandle = usize;
pub type EsObjectID = u64;
pub type EsFileOffset = u64;
pub type EsError = isize;
pub type EsNodeType = u8;
pub type EsFileOffsetDifference = i64;
pub type _EsLongConstant = u64;
pub const KernelObjectType_COULD_NOT_RESOLVE_HANDLE: KernelObjectType = 0;
pub const KernelObjectType_KERNEL_OBJECT_NONE: KernelObjectType = 2147483648;
pub const KernelObjectType_KERNEL_OBJECT_PROCESS: KernelObjectType = 1;
pub const KernelObjectType_KERNEL_OBJECT_THREAD: KernelObjectType = 2;
pub const KernelObjectType_KERNEL_OBJECT_WINDOW: KernelObjectType = 4;
pub const KernelObjectType_KERNEL_OBJECT_SHMEM: KernelObjectType = 8;
pub const KernelObjectType_KERNEL_OBJECT_NODE: KernelObjectType = 16;
pub const KernelObjectType_KERNEL_OBJECT_EVENT: KernelObjectType = 32;
pub const KernelObjectType_KERNEL_OBJECT_CONSTANT_BUFFER: KernelObjectType = 64;
pub const KernelObjectType_KERNEL_OBJECT_PIPE: KernelObjectType = 512;
pub const KernelObjectType_KERNEL_OBJECT_EMBEDDED_WINDOW: KernelObjectType = 1024;
pub const KernelObjectType_KERNEL_OBJECT_CONNECTION: KernelObjectType = 16384;
pub const KernelObjectType_KERNEL_OBJECT_DEVICE: KernelObjectType = 32768;
pub type KernelObjectType = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EsHeap {
    pub mutex: KMutex,
    pub regions: [*mut HeapRegion; 12usize],
    pub allocationsCount: size_t,
    pub size: size_t,
    pub blockCount: size_t,
    pub blocks: [*mut ::std::os::raw::c_void; 16usize],
    pub cannotValidate: bool,
}
#[test]
fn bindgen_test_layout_EsHeap() {
    assert_eq!(
        ::std::mem::size_of::<EsHeap>(),
        288usize,
        concat!("Size of: ", stringify!(EsHeap))
    );
    assert_eq!(
        ::std::mem::align_of::<EsHeap>(),
        8usize,
        concat!("Alignment of ", stringify!(EsHeap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsHeap>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsHeap),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsHeap>())).regions as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(EsHeap),
            "::",
            stringify!(regions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsHeap>())).allocationsCount as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(EsHeap),
            "::",
            stringify!(allocationsCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsHeap>())).size as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(EsHeap),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsHeap>())).blockCount as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(EsHeap),
            "::",
            stringify!(blockCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsHeap>())).blocks as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(EsHeap),
            "::",
            stringify!(blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsHeap>())).cannotValidate as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(EsHeap),
            "::",
            stringify!(cannotValidate)
        )
    );
}
extern "C" {
    pub static mut heapCore: EsHeap;
}
extern "C" {
    pub static mut heapFixed: EsHeap;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MMSpace {
    pub data: MMArchVAS,
    pub freeRegionsBase: AVLTree<MMRegion>,
    pub freeRegionsSize: AVLTree<MMRegion>,
    pub usedRegions: AVLTree<MMRegion>,
    pub usedRegionsNonGuard: LinkedList<MMRegion>,
    pub reserveMutex: KMutex,
    pub referenceCount: i32,
    pub user: bool,
    pub commit: u64,
    pub reserve: u64,
    pub removeAsyncTask: KAsyncTask,
}
#[test]
fn bindgen_test_layout_MMSpace() {
    assert_eq!(
        ::std::mem::size_of::<MMSpace>(),
        16888usize,
        concat!("Size of: ", stringify!(MMSpace))
    );
    assert_eq!(
        ::std::mem::align_of::<MMSpace>(),
        8usize,
        concat!("Alignment of ", stringify!(MMSpace))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMSpace>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMSpace),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMSpace>())).freeRegionsBase as *const _ as usize },
        16736usize,
        concat!(
            "Offset of field: ",
            stringify!(MMSpace),
            "::",
            stringify!(freeRegionsBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMSpace>())).freeRegionsSize as *const _ as usize },
        16752usize,
        concat!(
            "Offset of field: ",
            stringify!(MMSpace),
            "::",
            stringify!(freeRegionsSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMSpace>())).usedRegions as *const _ as usize },
        16768usize,
        concat!(
            "Offset of field: ",
            stringify!(MMSpace),
            "::",
            stringify!(usedRegions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMSpace>())).usedRegionsNonGuard as *const _ as usize },
        16784usize,
        concat!(
            "Offset of field: ",
            stringify!(MMSpace),
            "::",
            stringify!(usedRegionsNonGuard)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMSpace>())).reserveMutex as *const _ as usize },
        16808usize,
        concat!(
            "Offset of field: ",
            stringify!(MMSpace),
            "::",
            stringify!(reserveMutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMSpace>())).referenceCount as *const _ as usize },
        16840usize,
        concat!(
            "Offset of field: ",
            stringify!(MMSpace),
            "::",
            stringify!(referenceCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMSpace>())).user as *const _ as usize },
        16844usize,
        concat!(
            "Offset of field: ",
            stringify!(MMSpace),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMSpace>())).commit as *const _ as usize },
        16848usize,
        concat!(
            "Offset of field: ",
            stringify!(MMSpace),
            "::",
            stringify!(commit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMSpace>())).reserve as *const _ as usize },
        16856usize,
        concat!(
            "Offset of field: ",
            stringify!(MMSpace),
            "::",
            stringify!(reserve)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMSpace>())).removeAsyncTask as *const _ as usize },
        16864usize,
        concat!(
            "Offset of field: ",
            stringify!(MMSpace),
            "::",
            stringify!(removeAsyncTask)
        )
    );
}
extern "C" {
    pub static mut _kernelMMSpace: MMSpace;
}
extern "C" {
    pub static mut _coreMMSpace: MMSpace;
}
extern "C" {
    #[link_name = "\u{1}_Z19CloseHandleToObjectPv16KernelObjectTypej"]
    pub fn CloseHandleToObject(
        object: *mut ::std::os::raw::c_void,
        type_: KernelObjectType,
        flags: u32,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z18MMStandardAllocateP7MMSpacemjPvb"]
    pub fn MMStandardAllocate(
        space: *mut MMSpace,
        bytes: size_t,
        flags: u32,
        baseAddress: *mut ::std::os::raw::c_void,
        commitAll: bool,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_Z6MMFreeP7MMSpacePvmb"]
    pub fn MMFree(
        space: *mut MMSpace,
        address: *mut ::std::os::raw::c_void,
        expectedSize: size_t,
        userOnly: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z12EsMemoryFillPvS_h"]
    pub fn EsMemoryFill(
        from: *mut ::std::os::raw::c_void,
        to: *mut ::std::os::raw::c_void,
        byte: u8,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z16EsMemorySumBytesPhm"]
    pub fn EsMemorySumBytes(source: *mut u8, bytes: size_t) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_Z15EsMemoryComparePKvS0_m"]
    pub fn EsMemoryCompare(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
        bytes: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Z12EsMemoryZeroPvm"]
    pub fn EsMemoryZero(destination: *mut ::std::os::raw::c_void, bytes: size_t);
}
extern "C" {
    #[link_name = "\u{1}_Z12EsMemoryCopyPvPKvm"]
    pub fn EsMemoryCopy(
        _destination: *mut ::std::os::raw::c_void,
        _source: *const ::std::os::raw::c_void,
        bytes: size_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z11EsCRTmemcpyPvPKvm"]
    pub fn EsCRTmemcpy(
        dest: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_Z11EsCRTstrlenPKc"]
    pub fn EsCRTstrlen(s: *const ::std::os::raw::c_char) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_Z11EsCRTstrcpyPcPKc"]
    pub fn EsCRTstrcpy(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub const KLogLevel_LOG_VERBOSE: KLogLevel = 0;
pub const KLogLevel_LOG_INFO: KLogLevel = 1;
pub const KLogLevel_LOG_ERROR: KLogLevel = 2;
pub type KLogLevel = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConstantBuffer {
    pub handles: size_t,
    pub bytes: size_t,
    pub isPaged: bool,
}
#[test]
fn bindgen_test_layout_ConstantBuffer() {
    assert_eq!(
        ::std::mem::size_of::<ConstantBuffer>(),
        24usize,
        concat!("Size of: ", stringify!(ConstantBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<ConstantBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(ConstantBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ConstantBuffer>())).handles as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ConstantBuffer),
            "::",
            stringify!(handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ConstantBuffer>())).bytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ConstantBuffer),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ConstantBuffer>())).isPaged as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ConstantBuffer),
            "::",
            stringify!(isPaged)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_Z15EsCStringLengthPKc"]
    pub fn EsCStringLength(string: *const ::std::os::raw::c_char) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_Z18EsStringCompareRawPKclS0_l"]
    pub fn EsStringCompareRaw(
        s1: *const ::std::os::raw::c_char,
        length1: isize,
        s2: *const ::std::os::raw::c_char,
        length2: isize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut _KThreadTerminate: usize;
}
extern "C" {
    pub fn KernelLog(
        level: KLogLevel,
        subsystem: *const ::std::os::raw::c_char,
        event: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn KernelPanic(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn EsPrint(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn EsHeapAllocate(
        size: size_t,
        zeroMemory: bool,
        kernelHeap: *mut EsHeap,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EsHeapFree(
        address: *mut ::std::os::raw::c_void,
        expectedSize: size_t,
        kernelHeap: *mut EsHeap,
    );
}
extern "C" {
    pub fn MMPhysicalActivatePages(pages: usize, count: usize, flags: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn MMCommit(bytes: u64, fixed: bool) -> bool;
}
extern "C" {
    pub fn PMCopy(page: usize, _source: *mut ::std::os::raw::c_void, pageCount: size_t);
}
extern "C" {
    pub fn ProcessorGetRSP() -> usize;
}
extern "C" {
    pub fn ProcessorGetRBP() -> usize;
}
extern "C" {
    pub fn ProcessorDebugOutputByte(byte: u8);
}
extern "C" {
    pub fn SetupProcessor2(storage: *mut NewProcessorStorage);
}
extern "C" {
    pub fn processorGDTR();
}
extern "C" {
    pub fn PostContextSwitch(context: *mut InterruptContext, oldAddressSpace: *mut MMSpace)
        -> bool;
}
extern "C" {
    pub fn InterruptHandler(context: *mut InterruptContext);
}
extern "C" {
    pub fn Syscall(
        argument0: usize,
        argument1: usize,
        argument2: usize,
        returnAddress: usize,
        argument3: usize,
        argument4: usize,
        userStackPointer: *mut usize,
    ) -> usize;
}
extern "C" {
    pub fn PCProcessMemoryMap();
}
extern "C" {
    pub fn ProcessorHalt();
}
extern "C" {
    pub fn ProcessorInstallTSS(gdt: *mut u32, tss: *mut u32);
}
extern "C" {
    pub fn ProcessorAreInterruptsEnabled() -> bool;
}
extern "C" {
    pub fn GetCurrentThread() -> *mut Thread;
}
extern "C" {
    pub fn ProcessorEnableInterrupts();
}
extern "C" {
    pub fn ProcessorReadCR3() -> u64;
}
extern "C" {
    pub fn ProcessorInvalidatePage(virtualAddress: usize);
}
extern "C" {
    pub fn ProcessorOut8(port: u16, value: u8);
}
extern "C" {
    pub fn ProcessorIn8(port: u16) -> u8;
}
extern "C" {
    pub fn ProcessorOut16(port: u16, value: u16);
}
extern "C" {
    pub fn ProcessorIn16(port: u16) -> u16;
}
extern "C" {
    pub fn ProcessorOut32(port: u16, value: u32);
}
extern "C" {
    pub fn ProcessorIn32(port: u16) -> u32;
}
extern "C" {
    pub fn ProcessorReadMXCSR() -> u64;
}
extern "C" {
    pub fn PCSetupCOM1();
}
extern "C" {
    pub fn PCDisablePIC();
}
extern "C" {
    pub fn ProcessCrash(process: *mut Process, crashReason: *mut EsCrashReason);
}
extern "C" {
    pub fn MMInitialise();
}
extern "C" {
    pub fn ArchInitialise();
}
extern "C" {
    pub fn ArchShutdown();
}
extern "C" {
    pub fn ArchNextTimer(ms: size_t);
}
extern "C" {
    pub fn ArchGetTimeMs() -> u64;
}
extern "C" {
    pub fn ArchInitialiseThread(
        kernelStack: usize,
        kernelStackSize: usize,
        thread: *mut Thread,
        startAddress: usize,
        argument1: usize,
        argument2: usize,
        userland: bool,
        stack: usize,
        userStackSize: usize,
    ) -> *mut InterruptContext;
}
extern "C" {
    pub fn ArchSwitchContext(
        context: *mut InterruptContext,
        virtualAddressSpace: *mut MMArchVAS,
        threadKernelStack: usize,
        newThread: *mut Thread,
        oldAddressSpace: *mut MMSpace,
    );
}
extern "C" {
    pub fn ArchApplyRelocation(
        type_: usize,
        buffer: *mut u8,
        offset: usize,
        result: usize,
    ) -> EsError;
}
extern "C" {
    pub fn MMArchMapPage(
        space: *mut MMSpace,
        physicalAddress: usize,
        virtualAddress: usize,
        flags: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn MMArchUnmapPages(
        space: *mut MMSpace,
        virtualAddressStart: usize,
        pageCount: usize,
        flags: ::std::os::raw::c_uint,
        unmapMaximum: size_t,
        resumePosition: *mut usize,
    );
}
extern "C" {
    pub fn MMArchMakePageWritable(space: *mut MMSpace, virtualAddress: usize) -> bool;
}
extern "C" {
    pub fn MMArchHandlePageFault(address: usize, flags: u32) -> bool;
}
extern "C" {
    pub fn MMArchIsBufferInUserRange(baseAddress: usize, byteCount: size_t) -> bool;
}
extern "C" {
    pub fn MMArchSafeCopy(
        destinationAddress: usize,
        sourceAddress: usize,
        byteCount: size_t,
    ) -> bool;
}
extern "C" {
    pub fn MMArchCommitPageTables(space: *mut MMSpace, region: *mut MMRegion) -> bool;
}
extern "C" {
    pub fn MMArchInitialiseUserSpace(space: *mut MMSpace, firstRegion: *mut MMRegion) -> bool;
}
extern "C" {
    pub fn MMArchInitialise();
}
extern "C" {
    pub fn MMArchFreeVAS(space: *mut MMSpace);
}
extern "C" {
    pub fn MMArchFinalizeVAS(space: *mut MMSpace);
}
extern "C" {
    pub fn MMArchEarlyAllocatePage() -> usize;
}
extern "C" {
    pub fn MMArchPopulatePageFrameDatabase() -> u64;
}
extern "C" {
    pub fn MMArchGetPhysicalMemoryHighest() -> usize;
}
extern "C" {
    pub fn ProcessorDisableInterrupts();
}
extern "C" {
    pub fn ProcessorSendYieldIPI(thread: *mut Thread);
}
extern "C" {
    pub fn ProcessorFakeTimerInterrupt();
}
extern "C" {
    pub fn ProcessorInvalidateAllPages();
}
extern "C" {
    pub fn ProcessorFlushCodeCache();
}
extern "C" {
    pub fn ProcessorFlushCache();
}
extern "C" {
    pub fn ProcessorSetLocalStorage(cls: *mut CPULocalStorage);
}
extern "C" {
    pub fn ProcessorSetThreadStorage(tls: usize);
}
extern "C" {
    pub fn ProcessorSetAddressSpace(virtualAddressSpace: *mut MMArchVAS);
}
extern "C" {
    pub fn ProcessorReadTimeStamp() -> u64;
}
extern "C" {
    pub fn GetLocalStorage() -> *mut CPULocalStorage;
}
extern "C" {
    pub fn MMSpaceCloseReference(space: *mut MMSpace);
}
extern "C" {
    pub fn KThreadTerminate();
}
extern "C" {
    pub fn ThreadSetTemporaryAddressSpace(space: *mut MMSpace);
}
extern "C" {
    pub fn ProcessKill(process: *mut Process);
}
extern "C" {
    #[link_name = "\u{1}_Z19EsMemoryCopyReversePvS_m"]
    pub fn EsMemoryCopyReverse(
        _destination: *mut ::std::os::raw::c_void,
        _source: *mut ::std::os::raw::c_void,
        bytes: size_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z12EsMemoryMovePvS_lb"]
    pub fn EsMemoryMove(
        _start: *mut ::std::os::raw::c_void,
        _end: *mut ::std::os::raw::c_void,
        amount: isize,
        zeroEmptySpace: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z18EsAssertionFailurePKci"]
    pub fn EsAssertionFailure(file: *const ::std::os::raw::c_char, line: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EsGeneric {
    pub u: usize,
    pub i: isize,
    pub p: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_EsGeneric() {
    assert_eq!(
        ::std::mem::size_of::<EsGeneric>(),
        8usize,
        concat!("Size of: ", stringify!(EsGeneric))
    );
    assert_eq!(
        ::std::mem::align_of::<EsGeneric>(),
        8usize,
        concat!("Alignment of ", stringify!(EsGeneric))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsGeneric>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsGeneric),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsGeneric>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsGeneric),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsGeneric>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsGeneric),
            "::",
            stringify!(p)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct _EsDefer4<F> {
    pub f: F,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<F>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LinkedItem<T> {
    pub previousItem: *mut LinkedItem<T>,
    pub nextItem: *mut LinkedItem<T>,
    pub list: *mut LinkedList<T>,
    pub thisItem: *mut T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LinkedList<T> {
    pub firstItem: *mut LinkedItem<T>,
    pub lastItem: *mut LinkedItem<T>,
    pub count: size_t,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SimpleList {
    pub __bindgen_anon_1: SimpleList__bindgen_ty_1,
    pub __bindgen_anon_2: SimpleList__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SimpleList__bindgen_ty_1 {
    pub previous: *mut SimpleList,
    pub last: *mut SimpleList,
}
#[test]
fn bindgen_test_layout_SimpleList__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<SimpleList__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(SimpleList__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<SimpleList__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(SimpleList__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SimpleList__bindgen_ty_1>())).previous as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SimpleList__bindgen_ty_1),
            "::",
            stringify!(previous)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SimpleList__bindgen_ty_1>())).last as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SimpleList__bindgen_ty_1),
            "::",
            stringify!(last)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SimpleList__bindgen_ty_2 {
    pub next: *mut SimpleList,
    pub first: *mut SimpleList,
}
#[test]
fn bindgen_test_layout_SimpleList__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<SimpleList__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(SimpleList__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<SimpleList__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(SimpleList__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SimpleList__bindgen_ty_2>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SimpleList__bindgen_ty_2),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SimpleList__bindgen_ty_2>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SimpleList__bindgen_ty_2),
            "::",
            stringify!(first)
        )
    );
}
#[test]
fn bindgen_test_layout_SimpleList() {
    assert_eq!(
        ::std::mem::size_of::<SimpleList>(),
        16usize,
        concat!("Size of: ", stringify!(SimpleList))
    );
    assert_eq!(
        ::std::mem::align_of::<SimpleList>(),
        8usize,
        concat!("Alignment of ", stringify!(SimpleList))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10SimpleList6InsertEPS_b"]
    pub fn SimpleList_Insert(this: *mut SimpleList, link: *mut SimpleList, start: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN10SimpleList6RemoveEv"]
    pub fn SimpleList_Remove(this: *mut SimpleList);
}
impl SimpleList {
    #[inline]
    pub unsafe fn Insert(&mut self, link: *mut SimpleList, start: bool) {
        SimpleList_Insert(self, link, start)
    }
    #[inline]
    pub unsafe fn Remove(&mut self) {
        SimpleList_Remove(self)
    }
}
pub type MMObjectCacheItem = SimpleList;
pub const TreeSearchMode_TREE_SEARCH_EXACT: TreeSearchMode = 0;
pub const TreeSearchMode_TREE_SEARCH_SMALLEST_ABOVE_OR_EQUAL: TreeSearchMode = 1;
pub const TreeSearchMode_TREE_SEARCH_LARGEST_BELOW_OR_EQUAL: TreeSearchMode = 2;
pub type TreeSearchMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVLKey {
    pub __bindgen_anon_1: AVLKey__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AVLKey__bindgen_ty_1 {
    pub shortKey: usize,
    pub __bindgen_anon_1: AVLKey__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVLKey__bindgen_ty_1__bindgen_ty_1 {
    pub longKey: *mut ::std::os::raw::c_void,
    pub longKeyBytes: size_t,
}
#[test]
fn bindgen_test_layout_AVLKey__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<AVLKey__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(AVLKey__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<AVLKey__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(AVLKey__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVLKey__bindgen_ty_1__bindgen_ty_1>())).longKey as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVLKey__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(longKey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVLKey__bindgen_ty_1__bindgen_ty_1>())).longKeyBytes as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVLKey__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(longKeyBytes)
        )
    );
}
#[test]
fn bindgen_test_layout_AVLKey__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<AVLKey__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(AVLKey__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<AVLKey__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(AVLKey__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVLKey__bindgen_ty_1>())).shortKey as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVLKey__bindgen_ty_1),
            "::",
            stringify!(shortKey)
        )
    );
}
#[test]
fn bindgen_test_layout_AVLKey() {
    assert_eq!(
        ::std::mem::size_of::<AVLKey>(),
        16usize,
        concat!("Size of: ", stringify!(AVLKey))
    );
    assert_eq!(
        ::std::mem::align_of::<AVLKey>(),
        8usize,
        concat!("Alignment of ", stringify!(AVLKey))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVLItem<T> {
    pub thisItem: *mut T,
    pub children: [*mut AVLItem<T>; 2usize],
    pub parent: *mut AVLItem<T>,
    pub tree: *mut AVLTree<T>,
    pub key: AVLKey,
    pub height: ::std::os::raw::c_int,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVLTree<T> {
    pub root: *mut AVLItem<T>,
    pub modCheck: bool,
    pub longKeys: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
pub const AVLDuplicateKeyPolicy_AVL_DUPLICATE_KEYS_PANIC: AVLDuplicateKeyPolicy = 0;
pub const AVLDuplicateKeyPolicy_AVL_DUPLICATE_KEYS_ALLOW: AVLDuplicateKeyPolicy = 1;
pub const AVLDuplicateKeyPolicy_AVL_DUPLICATE_KEYS_FAIL: AVLDuplicateKeyPolicy = 2;
pub type AVLDuplicateKeyPolicy = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct KWriterLock {
    pub blockedThreads: LinkedList<Thread>,
    pub state: isize,
}
#[test]
fn bindgen_test_layout_KWriterLock() {
    assert_eq!(
        ::std::mem::size_of::<KWriterLock>(),
        32usize,
        concat!("Size of: ", stringify!(KWriterLock))
    );
    assert_eq!(
        ::std::mem::align_of::<KWriterLock>(),
        8usize,
        concat!("Alignment of ", stringify!(KWriterLock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KWriterLock>())).blockedThreads as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KWriterLock),
            "::",
            stringify!(blockedThreads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KWriterLock>())).state as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(KWriterLock),
            "::",
            stringify!(state)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_Z15KWriterLockTakeP11KWriterLockbb"]
    pub fn KWriterLockTake(lock: *mut KWriterLock, write: bool, poll: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z17KWriterLockReturnP11KWriterLockb"]
    pub fn KWriterLockReturn(lock: *mut KWriterLock, write: bool);
}
extern "C" {
    #[link_name = "\u{1}_Z35KWriterLockConvertExclusiveToSharedP11KWriterLock"]
    pub fn KWriterLockConvertExclusiveToShared(lock: *mut KWriterLock);
}
extern "C" {
    #[link_name = "\u{1}_Z26KWriterLockAssertExclusiveP11KWriterLock"]
    pub fn KWriterLockAssertExclusive(lock: *mut KWriterLock);
}
extern "C" {
    #[link_name = "\u{1}_Z23KWriterLockAssertSharedP11KWriterLock"]
    pub fn KWriterLockAssertShared(lock: *mut KWriterLock);
}
extern "C" {
    #[link_name = "\u{1}_Z23KWriterLockAssertLockedP11KWriterLock"]
    pub fn KWriterLockAssertLocked(lock: *mut KWriterLock);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct KMutex {
    pub owner: *mut Thread,
    pub blockedThreads: LinkedList<Thread>,
}
#[test]
fn bindgen_test_layout_KMutex() {
    assert_eq!(
        ::std::mem::size_of::<KMutex>(),
        32usize,
        concat!("Size of: ", stringify!(KMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<KMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(KMutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KMutex>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KMutex),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KMutex>())).blockedThreads as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(KMutex),
            "::",
            stringify!(blockedThreads)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_Z13KMutexAcquireP6KMutex"]
    pub fn KMutexAcquire(mutex: *mut KMutex) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z13KMutexReleaseP6KMutex"]
    pub fn KMutexRelease(mutex: *mut KMutex);
}
extern "C" {
    #[link_name = "\u{1}_Z18KMutexAssertLockedP6KMutex"]
    pub fn KMutexAssertLocked(mutex: *mut KMutex);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CPULocalStorage {
    pub currentThread: *mut Thread,
    pub idleThread: *mut Thread,
    pub asyncTaskThread: *mut Thread,
    pub panicContext: *mut InterruptContext,
    pub irqSwitchThread: bool,
    pub schedulerReady: bool,
    pub inIRQ: bool,
    pub inAsyncTask: bool,
    pub processorID: u32,
    pub spinlockCount: size_t,
    pub archCPU: *mut ArchCPU,
    pub asyncTaskList: SimpleList,
}
#[test]
fn bindgen_test_layout_CPULocalStorage() {
    assert_eq!(
        ::std::mem::size_of::<CPULocalStorage>(),
        72usize,
        concat!("Size of: ", stringify!(CPULocalStorage))
    );
    assert_eq!(
        ::std::mem::align_of::<CPULocalStorage>(),
        8usize,
        concat!("Alignment of ", stringify!(CPULocalStorage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPULocalStorage>())).currentThread as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPULocalStorage),
            "::",
            stringify!(currentThread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPULocalStorage>())).idleThread as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CPULocalStorage),
            "::",
            stringify!(idleThread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPULocalStorage>())).asyncTaskThread as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CPULocalStorage),
            "::",
            stringify!(asyncTaskThread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPULocalStorage>())).panicContext as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CPULocalStorage),
            "::",
            stringify!(panicContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPULocalStorage>())).irqSwitchThread as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CPULocalStorage),
            "::",
            stringify!(irqSwitchThread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPULocalStorage>())).schedulerReady as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(CPULocalStorage),
            "::",
            stringify!(schedulerReady)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPULocalStorage>())).inIRQ as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(CPULocalStorage),
            "::",
            stringify!(inIRQ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPULocalStorage>())).inAsyncTask as *const _ as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(CPULocalStorage),
            "::",
            stringify!(inAsyncTask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPULocalStorage>())).processorID as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CPULocalStorage),
            "::",
            stringify!(processorID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPULocalStorage>())).spinlockCount as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CPULocalStorage),
            "::",
            stringify!(spinlockCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPULocalStorage>())).archCPU as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CPULocalStorage),
            "::",
            stringify!(archCPU)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPULocalStorage>())).asyncTaskList as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CPULocalStorage),
            "::",
            stringify!(asyncTaskList)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KSpinlock {
    pub state: u8,
    pub ownerCPU: u8,
    pub interruptsEnabled: bool,
}
#[test]
fn bindgen_test_layout_KSpinlock() {
    assert_eq!(
        ::std::mem::size_of::<KSpinlock>(),
        3usize,
        concat!("Size of: ", stringify!(KSpinlock))
    );
    assert_eq!(
        ::std::mem::align_of::<KSpinlock>(),
        1usize,
        concat!("Alignment of ", stringify!(KSpinlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KSpinlock>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KSpinlock),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KSpinlock>())).ownerCPU as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(KSpinlock),
            "::",
            stringify!(ownerCPU)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KSpinlock>())).interruptsEnabled as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(KSpinlock),
            "::",
            stringify!(interruptsEnabled)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_Z16KSpinlockAcquireP9KSpinlock"]
    pub fn KSpinlockAcquire(spinlock: *mut KSpinlock);
}
extern "C" {
    #[link_name = "\u{1}_Z16KSpinlockReleaseP9KSpinlockb"]
    pub fn KSpinlockRelease(spinlock: *mut KSpinlock, force: bool);
}
extern "C" {
    #[link_name = "\u{1}_Z21KSpinlockAssertLockedP9KSpinlock"]
    pub fn KSpinlockAssertLocked(spinlock: *mut KSpinlock);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Pool {
    pub elementSize: size_t,
    pub cache: [*mut ::std::os::raw::c_void; 16usize],
    pub cacheEntries: size_t,
    pub mutex: KMutex,
}
#[test]
fn bindgen_test_layout_Pool() {
    assert_eq!(
        ::std::mem::size_of::<Pool>(),
        176usize,
        concat!("Size of: ", stringify!(Pool))
    );
    assert_eq!(
        ::std::mem::align_of::<Pool>(),
        8usize,
        concat!("Alignment of ", stringify!(Pool))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pool>())).elementSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Pool),
            "::",
            stringify!(elementSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pool>())).cache as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Pool),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pool>())).cacheEntries as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(Pool),
            "::",
            stringify!(cacheEntries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pool>())).mutex as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(Pool),
            "::",
            stringify!(mutex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct KEvent {
    pub autoReset: bool,
    pub state: usize,
    pub blockedThreads: LinkedList<Thread>,
    pub handles: size_t,
}
#[test]
fn bindgen_test_layout_KEvent() {
    assert_eq!(
        ::std::mem::size_of::<KEvent>(),
        48usize,
        concat!("Size of: ", stringify!(KEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<KEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(KEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KEvent>())).autoReset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KEvent),
            "::",
            stringify!(autoReset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KEvent>())).state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(KEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KEvent>())).blockedThreads as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(KEvent),
            "::",
            stringify!(blockedThreads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KEvent>())).handles as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(KEvent),
            "::",
            stringify!(handles)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_Z9KEventSetP6KEventb"]
    pub fn KEventSet(event: *mut KEvent, maybeAlreadySet: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z11KEventResetP6KEvent"]
    pub fn KEventReset(event: *mut KEvent);
}
extern "C" {
    #[link_name = "\u{1}_Z10KEventPollP6KEvent"]
    pub fn KEventPoll(event: *mut KEvent) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z10KEventWaitP6KEventm"]
    pub fn KEventWait(event: *mut KEvent, timeoutMs: u64) -> bool;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HeapRegion {
    pub __bindgen_anon_1: HeapRegion__bindgen_ty_1,
    pub previous: u16,
    pub offset: u16,
    pub used: u16,
    pub __bindgen_anon_2: HeapRegion__bindgen_ty_2,
    pub regionListReference: *mut *mut HeapRegion,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HeapRegion__bindgen_ty_1 {
    pub next: u16,
    pub size: u16,
}
#[test]
fn bindgen_test_layout_HeapRegion__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<HeapRegion__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(HeapRegion__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<HeapRegion__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(HeapRegion__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HeapRegion__bindgen_ty_1>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HeapRegion__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HeapRegion__bindgen_ty_1>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HeapRegion__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HeapRegion__bindgen_ty_2 {
    pub allocationSize: usize,
    pub regionListNext: *mut HeapRegion,
}
#[test]
fn bindgen_test_layout_HeapRegion__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<HeapRegion__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(HeapRegion__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<HeapRegion__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(HeapRegion__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HeapRegion__bindgen_ty_2>())).allocationSize as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HeapRegion__bindgen_ty_2),
            "::",
            stringify!(allocationSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HeapRegion__bindgen_ty_2>())).regionListNext as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HeapRegion__bindgen_ty_2),
            "::",
            stringify!(regionListNext)
        )
    );
}
#[test]
fn bindgen_test_layout_HeapRegion() {
    assert_eq!(
        ::std::mem::size_of::<HeapRegion>(),
        24usize,
        concat!("Size of: ", stringify!(HeapRegion))
    );
    assert_eq!(
        ::std::mem::align_of::<HeapRegion>(),
        8usize,
        concat!("Alignment of ", stringify!(HeapRegion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HeapRegion>())).previous as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(HeapRegion),
            "::",
            stringify!(previous)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HeapRegion>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HeapRegion),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HeapRegion>())).used as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(HeapRegion),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HeapRegion>())).regionListReference as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HeapRegion),
            "::",
            stringify!(regionListReference)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_Z16EsHeapReallocatePvmbP6EsHeap"]
    pub fn EsHeapReallocate(
        oldAddress: *mut ::std::os::raw::c_void,
        newAllocationSize: size_t,
        zeroNewSpace: bool,
        _heap: *mut EsHeap,
    ) -> *mut ::std::os::raw::c_void;
}
pub const EsSyscallType_ES_SYSCALL_MEMORY_ALLOCATE: EsSyscallType = 0;
pub const EsSyscallType_ES_SYSCALL_MEMORY_FREE: EsSyscallType = 1;
pub const EsSyscallType_ES_SYSCALL_MEMORY_MAP_OBJECT: EsSyscallType = 2;
pub const EsSyscallType_ES_SYSCALL_MEMORY_OPEN: EsSyscallType = 3;
pub const EsSyscallType_ES_SYSCALL_MEMORY_COMMIT: EsSyscallType = 4;
pub const EsSyscallType_ES_SYSCALL_MEMORY_FAULT_RANGE: EsSyscallType = 5;
pub const EsSyscallType_ES_SYSCALL_MEMORY_GET_AVAILABLE: EsSyscallType = 6;
pub const EsSyscallType_ES_SYSCALL_EVENT_CREATE: EsSyscallType = 7;
pub const EsSyscallType_ES_SYSCALL_EVENT_RESET: EsSyscallType = 8;
pub const EsSyscallType_ES_SYSCALL_EVENT_SET: EsSyscallType = 9;
pub const EsSyscallType_ES_SYSCALL_PROCESS_CRASH: EsSyscallType = 10;
pub const EsSyscallType_ES_SYSCALL_PROCESS_CREATE: EsSyscallType = 11;
pub const EsSyscallType_ES_SYSCALL_PROCESS_GET_STATE: EsSyscallType = 12;
pub const EsSyscallType_ES_SYSCALL_PROCESS_GET_STATUS: EsSyscallType = 13;
pub const EsSyscallType_ES_SYSCALL_PROCESS_GET_TLS: EsSyscallType = 14;
pub const EsSyscallType_ES_SYSCALL_PROCESS_OPEN: EsSyscallType = 15;
pub const EsSyscallType_ES_SYSCALL_PROCESS_PAUSE: EsSyscallType = 16;
pub const EsSyscallType_ES_SYSCALL_PROCESS_SET_TLS: EsSyscallType = 17;
pub const EsSyscallType_ES_SYSCALL_PROCESS_TERMINATE: EsSyscallType = 18;
pub const EsSyscallType_ES_SYSCALL_SLEEP: EsSyscallType = 19;
pub const EsSyscallType_ES_SYSCALL_THREAD_CREATE: EsSyscallType = 20;
pub const EsSyscallType_ES_SYSCALL_THREAD_GET_ID: EsSyscallType = 21;
pub const EsSyscallType_ES_SYSCALL_THREAD_STACK_SIZE: EsSyscallType = 22;
pub const EsSyscallType_ES_SYSCALL_THREAD_TERMINATE: EsSyscallType = 23;
pub const EsSyscallType_ES_SYSCALL_WAIT: EsSyscallType = 24;
pub const EsSyscallType_ES_SYSCALL_YIELD_SCHEDULER: EsSyscallType = 25;
pub const EsSyscallType_ES_SYSCALL_MESSAGE_GET: EsSyscallType = 26;
pub const EsSyscallType_ES_SYSCALL_MESSAGE_POST: EsSyscallType = 27;
pub const EsSyscallType_ES_SYSCALL_MESSAGE_WAIT: EsSyscallType = 28;
pub const EsSyscallType_ES_SYSCALL_CURSOR_POSITION_GET: EsSyscallType = 29;
pub const EsSyscallType_ES_SYSCALL_CURSOR_POSITION_SET: EsSyscallType = 30;
pub const EsSyscallType_ES_SYSCALL_CURSOR_PROPERTIES_SET: EsSyscallType = 31;
pub const EsSyscallType_ES_SYSCALL_GAME_CONTROLLER_STATE_POLL: EsSyscallType = 32;
pub const EsSyscallType_ES_SYSCALL_EYEDROP_START: EsSyscallType = 33;
pub const EsSyscallType_ES_SYSCALL_SCREEN_WORK_AREA_SET: EsSyscallType = 34;
pub const EsSyscallType_ES_SYSCALL_SCREEN_WORK_AREA_GET: EsSyscallType = 35;
pub const EsSyscallType_ES_SYSCALL_SCREEN_BOUNDS_GET: EsSyscallType = 36;
pub const EsSyscallType_ES_SYSCALL_SCREEN_FORCE_UPDATE: EsSyscallType = 37;
pub const EsSyscallType_ES_SYSCALL_WINDOW_CREATE: EsSyscallType = 38;
pub const EsSyscallType_ES_SYSCALL_WINDOW_CLOSE: EsSyscallType = 39;
pub const EsSyscallType_ES_SYSCALL_WINDOW_REDRAW: EsSyscallType = 40;
pub const EsSyscallType_ES_SYSCALL_WINDOW_MOVE: EsSyscallType = 41;
pub const EsSyscallType_ES_SYSCALL_WINDOW_TRANSFER_PRESS: EsSyscallType = 42;
pub const EsSyscallType_ES_SYSCALL_WINDOW_FIND_BY_POINT: EsSyscallType = 43;
pub const EsSyscallType_ES_SYSCALL_WINDOW_GET_ID: EsSyscallType = 44;
pub const EsSyscallType_ES_SYSCALL_WINDOW_GET_BOUNDS: EsSyscallType = 45;
pub const EsSyscallType_ES_SYSCALL_WINDOW_SET_BITS: EsSyscallType = 46;
pub const EsSyscallType_ES_SYSCALL_WINDOW_SET_CURSOR: EsSyscallType = 47;
pub const EsSyscallType_ES_SYSCALL_WINDOW_SET_PROPERTY: EsSyscallType = 48;
pub const EsSyscallType_ES_SYSCALL_MESSAGE_DESKTOP: EsSyscallType = 49;
pub const EsSyscallType_ES_SYSCALL_NODE_OPEN: EsSyscallType = 50;
pub const EsSyscallType_ES_SYSCALL_NODE_DELETE: EsSyscallType = 51;
pub const EsSyscallType_ES_SYSCALL_NODE_MOVE: EsSyscallType = 52;
pub const EsSyscallType_ES_SYSCALL_FILE_READ_SYNC: EsSyscallType = 53;
pub const EsSyscallType_ES_SYSCALL_FILE_WRITE_SYNC: EsSyscallType = 54;
pub const EsSyscallType_ES_SYSCALL_FILE_RESIZE: EsSyscallType = 55;
pub const EsSyscallType_ES_SYSCALL_FILE_GET_SIZE: EsSyscallType = 56;
pub const EsSyscallType_ES_SYSCALL_FILE_CONTROL: EsSyscallType = 57;
pub const EsSyscallType_ES_SYSCALL_DIRECTORY_ENUMERATE: EsSyscallType = 58;
pub const EsSyscallType_ES_SYSCALL_VOLUME_GET_INFORMATION: EsSyscallType = 59;
pub const EsSyscallType_ES_SYSCALL_DEVICE_CONTROL: EsSyscallType = 60;
pub const EsSyscallType_ES_SYSCALL_DOMAIN_NAME_RESOLVE: EsSyscallType = 61;
pub const EsSyscallType_ES_SYSCALL_ECHO_REQUEST: EsSyscallType = 62;
pub const EsSyscallType_ES_SYSCALL_CONNECTION_OPEN: EsSyscallType = 63;
pub const EsSyscallType_ES_SYSCALL_CONNECTION_POLL: EsSyscallType = 64;
pub const EsSyscallType_ES_SYSCALL_CONNECTION_NOTIFY: EsSyscallType = 65;
pub const EsSyscallType_ES_SYSCALL_CONSTANT_BUFFER_READ: EsSyscallType = 66;
pub const EsSyscallType_ES_SYSCALL_CONSTANT_BUFFER_CREATE: EsSyscallType = 67;
pub const EsSyscallType_ES_SYSCALL_PIPE_CREATE: EsSyscallType = 68;
pub const EsSyscallType_ES_SYSCALL_PIPE_WRITE: EsSyscallType = 69;
pub const EsSyscallType_ES_SYSCALL_PIPE_READ: EsSyscallType = 70;
pub const EsSyscallType_ES_SYSCALL_HANDLE_CLOSE: EsSyscallType = 71;
pub const EsSyscallType_ES_SYSCALL_HANDLE_SHARE: EsSyscallType = 72;
pub const EsSyscallType_ES_SYSCALL_BATCH: EsSyscallType = 73;
pub const EsSyscallType_ES_SYSCALL_DEBUG_COMMAND: EsSyscallType = 74;
pub const EsSyscallType_ES_SYSCALL_POSIX: EsSyscallType = 75;
pub const EsSyscallType_ES_SYSCALL_PRINT: EsSyscallType = 76;
pub const EsSyscallType_ES_SYSCALL_SHUTDOWN: EsSyscallType = 77;
pub const EsSyscallType_ES_SYSCALL_SYSTEM_TAKE_SNAPSHOT: EsSyscallType = 78;
pub const EsSyscallType_ES_SYSCALL_PROCESSOR_COUNT: EsSyscallType = 79;
pub const EsSyscallType_ES_SYSCALL_COUNT: EsSyscallType = 80;
pub type EsSyscallType = ::std::os::raw::c_uint;
pub const EsDeviceType_ES_DEVICE_OTHER: EsDeviceType = 0;
pub const EsDeviceType_ES_DEVICE_CONTROLLER: EsDeviceType = 1;
pub const EsDeviceType_ES_DEVICE_FILE_SYSTEM: EsDeviceType = 2;
pub const EsDeviceType_ES_DEVICE_GRAPHICS_TARGET: EsDeviceType = 3;
pub const EsDeviceType_ES_DEVICE_BLOCK: EsDeviceType = 4;
pub const EsDeviceType_ES_DEVICE_AUDIO: EsDeviceType = 5;
pub const EsDeviceType_ES_DEVICE_KEYBOARD: EsDeviceType = 6;
pub const EsDeviceType_ES_DEVICE_MOUSE: EsDeviceType = 7;
pub const EsDeviceType_ES_DEVICE_GAME_CONTROLLER: EsDeviceType = 8;
pub const EsDeviceType_ES_DEVICE_NETWORK_CARD: EsDeviceType = 9;
pub const EsDeviceType_ES_DEVICE_USB: EsDeviceType = 10;
pub const EsDeviceType_ES_DEVICE_PCI_FUNCTION: EsDeviceType = 11;
pub const EsDeviceType_ES_DEVICE_CLOCK: EsDeviceType = 12;
pub type EsDeviceType = ::std::os::raw::c_uint;
pub const ProcessType_PROCESS_NORMAL: ProcessType = 0;
pub const ProcessType_PROCESS_KERNEL: ProcessType = 1;
pub const ProcessType_PROCESS_DESKTOP: ProcessType = 2;
pub type ProcessType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsUniqueIdentifier {
    pub d: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_EsUniqueIdentifier() {
    assert_eq!(
        ::std::mem::size_of::<EsUniqueIdentifier>(),
        16usize,
        concat!("Size of: ", stringify!(EsUniqueIdentifier))
    );
    assert_eq!(
        ::std::mem::align_of::<EsUniqueIdentifier>(),
        1usize,
        concat!("Alignment of ", stringify!(EsUniqueIdentifier))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsUniqueIdentifier>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsUniqueIdentifier),
            "::",
            stringify!(d)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhysicalMemoryRegion {
    pub baseAddress: u64,
    pub pageCount: u64,
}
#[test]
fn bindgen_test_layout_PhysicalMemoryRegion() {
    assert_eq!(
        ::std::mem::size_of::<PhysicalMemoryRegion>(),
        16usize,
        concat!("Size of: ", stringify!(PhysicalMemoryRegion))
    );
    assert_eq!(
        ::std::mem::align_of::<PhysicalMemoryRegion>(),
        8usize,
        concat!("Alignment of ", stringify!(PhysicalMemoryRegion))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PhysicalMemoryRegion>())).baseAddress as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysicalMemoryRegion),
            "::",
            stringify!(baseAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PhysicalMemoryRegion>())).pageCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PhysicalMemoryRegion),
            "::",
            stringify!(pageCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ArrayHeader {
    pub length: size_t,
    pub allocated: size_t,
}
#[test]
fn bindgen_test_layout__ArrayHeader() {
    assert_eq!(
        ::std::mem::size_of::<_ArrayHeader>(),
        16usize,
        concat!("Size of: ", stringify!(_ArrayHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<_ArrayHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(_ArrayHeader))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ArrayHeader>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ArrayHeader),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ArrayHeader>())).allocated as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ArrayHeader),
            "::",
            stringify!(allocated)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_Z21_ArrayMaybeInitialisePPvmP6EsHeap"]
    pub fn _ArrayMaybeInitialise(
        array: *mut *mut ::std::os::raw::c_void,
        itemSize: size_t,
        heap: *mut EsHeap,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z21_ArrayEnsureAllocatedPPvmmhP6EsHeap"]
    pub fn _ArrayEnsureAllocated(
        array: *mut *mut ::std::os::raw::c_void,
        minimumAllocated: size_t,
        itemSize: size_t,
        additionalHeaderBytes: u8,
        heap: *mut EsHeap,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z15_ArraySetLengthPPvmmhP6EsHeap"]
    pub fn _ArraySetLength(
        array: *mut *mut ::std::os::raw::c_void,
        newLength: size_t,
        itemSize: size_t,
        additionalHeaderBytes: u8,
        heap: *mut EsHeap,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z12_ArrayDeletePvmmm"]
    pub fn _ArrayDelete(
        array: *mut ::std::os::raw::c_void,
        position: usize,
        itemSize: size_t,
        count: size_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z16_ArrayDeleteSwapPvmm"]
    pub fn _ArrayDeleteSwap(array: *mut ::std::os::raw::c_void, position: usize, itemSize: size_t);
}
extern "C" {
    #[link_name = "\u{1}_Z12_ArrayInsertPPvPKvmlhP6EsHeap"]
    pub fn _ArrayInsert(
        array: *mut *mut ::std::os::raw::c_void,
        item: *const ::std::os::raw::c_void,
        itemSize: size_t,
        position: isize,
        additionalHeaderBytes: u8,
        heap: *mut EsHeap,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_Z16_ArrayInsertManyPPvmlmP6EsHeap"]
    pub fn _ArrayInsertMany(
        array: *mut *mut ::std::os::raw::c_void,
        itemSize: size_t,
        position: isize,
        insertCount: size_t,
        heap: *mut EsHeap,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_Z10_ArrayFreePPvmP6EsHeap"]
    pub fn _ArrayFree(array: *mut *mut ::std::os::raw::c_void, itemSize: size_t, heap: *mut EsHeap);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Range {
    pub from: usize,
    pub to: usize,
}
#[test]
fn bindgen_test_layout_Range() {
    assert_eq!(
        ::std::mem::size_of::<Range>(),
        16usize,
        concat!("Size of: ", stringify!(Range))
    );
    assert_eq!(
        ::std::mem::align_of::<Range>(),
        8usize,
        concat!("Alignment of ", stringify!(Range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Range>())).from as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Range),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Range>())).to as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Range), "::", stringify!(to))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeSet {
    pub ranges: u64,
    pub contiguous: usize,
}
#[test]
fn bindgen_test_layout_RangeSet() {
    assert_eq!(
        ::std::mem::size_of::<RangeSet>(),
        16usize,
        concat!("Size of: ", stringify!(RangeSet))
    );
    assert_eq!(
        ::std::mem::align_of::<RangeSet>(),
        8usize,
        concat!("Alignment of ", stringify!(RangeSet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeSet>())).ranges as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeSet),
            "::",
            stringify!(ranges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeSet>())).contiguous as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeSet),
            "::",
            stringify!(contiguous)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KDevice {
    pub cDebugName: *const ::std::os::raw::c_char,
    pub parent: *mut KDevice,
    pub children: u64,
    pub flags: u8,
    pub handles: u32,
    pub type_: EsDeviceType,
    pub objectID: EsObjectID,
    pub shutdown: ::std::option::Option<unsafe extern "C" fn(device: *mut KDevice)>,
    pub dumpState: ::std::option::Option<unsafe extern "C" fn(device: *mut KDevice)>,
    pub removed: ::std::option::Option<unsafe extern "C" fn(device: *mut KDevice)>,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(device: *mut KDevice)>,
}
#[test]
fn bindgen_test_layout_KDevice() {
    assert_eq!(
        ::std::mem::size_of::<KDevice>(),
        80usize,
        concat!("Size of: ", stringify!(KDevice))
    );
    assert_eq!(
        ::std::mem::align_of::<KDevice>(),
        8usize,
        concat!("Alignment of ", stringify!(KDevice))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KDevice>())).cDebugName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KDevice),
            "::",
            stringify!(cDebugName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KDevice>())).parent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(KDevice),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KDevice>())).children as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(KDevice),
            "::",
            stringify!(children)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KDevice>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(KDevice),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KDevice>())).handles as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(KDevice),
            "::",
            stringify!(handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KDevice>())).type_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(KDevice),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KDevice>())).objectID as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(KDevice),
            "::",
            stringify!(objectID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KDevice>())).shutdown as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(KDevice),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KDevice>())).dumpState as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(KDevice),
            "::",
            stringify!(dumpState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KDevice>())).removed as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(KDevice),
            "::",
            stringify!(removed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KDevice>())).destroy as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(KDevice),
            "::",
            stringify!(destroy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsThreadEventLogEntry {
    pub file: [::std::os::raw::c_char; 31usize],
    pub fileBytes: u8,
    pub expression: [::std::os::raw::c_char; 31usize],
    pub expressionBytes: u8,
    pub event: u8,
    pub line: u16,
    pub objectID: EsObjectID,
    pub threadID: EsObjectID,
}
#[test]
fn bindgen_test_layout_EsThreadEventLogEntry() {
    assert_eq!(
        ::std::mem::size_of::<EsThreadEventLogEntry>(),
        88usize,
        concat!("Size of: ", stringify!(EsThreadEventLogEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<EsThreadEventLogEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(EsThreadEventLogEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsThreadEventLogEntry>())).file as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsThreadEventLogEntry),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsThreadEventLogEntry>())).fileBytes as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(EsThreadEventLogEntry),
            "::",
            stringify!(fileBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsThreadEventLogEntry>())).expression as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(EsThreadEventLogEntry),
            "::",
            stringify!(expression)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsThreadEventLogEntry>())).expressionBytes as *const _ as usize
        },
        63usize,
        concat!(
            "Offset of field: ",
            stringify!(EsThreadEventLogEntry),
            "::",
            stringify!(expressionBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsThreadEventLogEntry>())).event as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(EsThreadEventLogEntry),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsThreadEventLogEntry>())).line as *const _ as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(EsThreadEventLogEntry),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsThreadEventLogEntry>())).objectID as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(EsThreadEventLogEntry),
            "::",
            stringify!(objectID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsThreadEventLogEntry>())).threadID as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(EsThreadEventLogEntry),
            "::",
            stringify!(threadID)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsProcessCreateData {
    pub environment: EsHandle,
    pub initialMountPoints: EsHandle,
    pub initialDevices: EsHandle,
}
#[test]
fn bindgen_test_layout_EsProcessCreateData() {
    assert_eq!(
        ::std::mem::size_of::<EsProcessCreateData>(),
        24usize,
        concat!("Size of: ", stringify!(EsProcessCreateData))
    );
    assert_eq!(
        ::std::mem::align_of::<EsProcessCreateData>(),
        8usize,
        concat!("Alignment of ", stringify!(EsProcessCreateData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsProcessCreateData>())).environment as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsProcessCreateData),
            "::",
            stringify!(environment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsProcessCreateData>())).initialMountPoints as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsProcessCreateData),
            "::",
            stringify!(initialMountPoints)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsProcessCreateData>())).initialDevices as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsProcessCreateData),
            "::",
            stringify!(initialDevices)
        )
    );
}
pub const EsFatalError_ES_FATAL_ERROR_ABORT: EsFatalError = 0;
pub const EsFatalError_ES_FATAL_ERROR_INCORRECT_FILE_ACCESS: EsFatalError = 1;
pub const EsFatalError_ES_FATAL_ERROR_INCORRECT_NODE_TYPE: EsFatalError = 2;
pub const EsFatalError_ES_FATAL_ERROR_INSUFFICIENT_PERMISSIONS: EsFatalError = 3;
pub const EsFatalError_ES_FATAL_ERROR_INVALID_BUFFER: EsFatalError = 4;
pub const EsFatalError_ES_FATAL_ERROR_INVALID_HANDLE: EsFatalError = 5;
pub const EsFatalError_ES_FATAL_ERROR_INVALID_MEMORY_REGION: EsFatalError = 6;
pub const EsFatalError_ES_FATAL_ERROR_OUT_OF_RANGE: EsFatalError = 7;
pub const EsFatalError_ES_FATAL_ERROR_PROCESSOR_EXCEPTION: EsFatalError = 8;
pub const EsFatalError_ES_FATAL_ERROR_RECURSIVE_BATCH: EsFatalError = 9;
pub const EsFatalError_ES_FATAL_ERROR_UNKNOWN_SYSCALL: EsFatalError = 10;
pub const EsFatalError_ES_FATAL_ERROR_COUNT: EsFatalError = 11;
pub type EsFatalError = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsCrashReason {
    pub errorCode: EsFatalError,
    pub duringSystemCall: i32,
}
#[test]
fn bindgen_test_layout_EsCrashReason() {
    assert_eq!(
        ::std::mem::size_of::<EsCrashReason>(),
        8usize,
        concat!("Size of: ", stringify!(EsCrashReason))
    );
    assert_eq!(
        ::std::mem::align_of::<EsCrashReason>(),
        4usize,
        concat!("Alignment of ", stringify!(EsCrashReason))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsCrashReason>())).errorCode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsCrashReason),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsCrashReason>())).duringSystemCall as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EsCrashReason),
            "::",
            stringify!(duringSystemCall)
        )
    );
}
pub const ThreadState_THREAD_ACTIVE: ThreadState = 0;
pub const ThreadState_THREAD_WAITING_MUTEX: ThreadState = 1;
pub const ThreadState_THREAD_WAITING_EVENT: ThreadState = 2;
pub const ThreadState_THREAD_WAITING_WRITER_LOCK: ThreadState = 3;
pub const ThreadState_THREAD_TERMINATED: ThreadState = 4;
pub type ThreadState = i8;
pub const ThreadType_THREAD_NORMAL: ThreadType = 0;
pub const ThreadType_THREAD_IDLE: ThreadType = 1;
pub const ThreadType_THREAD_ASYNC_TASK: ThreadType = 2;
pub type ThreadType = i8;
pub const ThreadTerminatableState_THREAD_INVALID_TS: ThreadTerminatableState = 0;
pub const ThreadTerminatableState_THREAD_TERMINATABLE: ThreadTerminatableState = 1;
pub const ThreadTerminatableState_THREAD_IN_SYSCALL: ThreadTerminatableState = 2;
pub const ThreadTerminatableState_THREAD_USER_BLOCK_REQUEST: ThreadTerminatableState = 3;
pub type ThreadTerminatableState = i8;
pub type KAsyncTaskCallback = ::std::option::Option<unsafe extern "C" fn(task: *mut KAsyncTask)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct KAsyncTask {
    pub item: SimpleList,
    pub callback: KAsyncTaskCallback,
}
#[test]
fn bindgen_test_layout_KAsyncTask() {
    assert_eq!(
        ::std::mem::size_of::<KAsyncTask>(),
        24usize,
        concat!("Size of: ", stringify!(KAsyncTask))
    );
    assert_eq!(
        ::std::mem::align_of::<KAsyncTask>(),
        8usize,
        concat!("Alignment of ", stringify!(KAsyncTask))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KAsyncTask>())).item as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KAsyncTask),
            "::",
            stringify!(item)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KAsyncTask>())).callback as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(KAsyncTask),
            "::",
            stringify!(callback)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Thread {
    pub inSafeCopy: bool,
    pub item: LinkedItem<Thread>,
    pub allItem: LinkedItem<Thread>,
    pub processItem: LinkedItem<Thread>,
    pub process: *mut Process,
    pub id: EsObjectID,
    pub cpuTimeSlices: usize,
    pub handles: size_t,
    pub executingProcessorID: u32,
    pub userStackBase: usize,
    pub kernelStackBase: usize,
    pub kernelStack: usize,
    pub tlsAddress: usize,
    pub userStackReserve: size_t,
    pub userStackCommit: size_t,
    pub type_: ThreadType,
    pub isKernelThread: bool,
    pub isPageGenerator: bool,
    pub priority: i8,
    pub blockedThreadPriorities: [i32; 2usize],
    pub state: ThreadState,
    pub terminatableState: ThreadTerminatableState,
    pub executing: bool,
    pub terminating: bool,
    pub paused: bool,
    pub receivedYieldIPI: bool,
    pub blocking: Thread__bindgen_ty_1,
    pub killedEvent: KEvent,
    pub killAsyncTask: KAsyncTask,
    pub temporaryAddressSpace: *mut MMSpace,
    pub interruptContext: *mut InterruptContext,
    pub lastKnownExecutionAddress: usize,
    pub cName: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Thread__bindgen_ty_1 {
    pub mutex: *mut KMutex,
    pub __bindgen_anon_1: Thread__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: Thread__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Thread__bindgen_ty_1__bindgen_ty_1 {
    pub writerLock: *mut KWriterLock,
    pub writerLockType: bool,
}
#[test]
fn bindgen_test_layout_Thread__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<Thread__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(Thread__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<Thread__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(Thread__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Thread__bindgen_ty_1__bindgen_ty_1>())).writerLock as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(writerLock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Thread__bindgen_ty_1__bindgen_ty_1>())).writerLockType
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(writerLockType)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Thread__bindgen_ty_1__bindgen_ty_2 {
    pub eventItems: *mut LinkedItem<Thread>,
    pub events: [*mut KEvent; 8usize],
    pub eventCount: size_t,
}
#[test]
fn bindgen_test_layout_Thread__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<Thread__bindgen_ty_1__bindgen_ty_2>(),
        80usize,
        concat!("Size of: ", stringify!(Thread__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<Thread__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(Thread__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Thread__bindgen_ty_1__bindgen_ty_2>())).eventItems as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(eventItems)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Thread__bindgen_ty_1__bindgen_ty_2>())).events as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Thread__bindgen_ty_1__bindgen_ty_2>())).eventCount as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(eventCount)
        )
    );
}
#[test]
fn bindgen_test_layout_Thread__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<Thread__bindgen_ty_1>(),
        80usize,
        concat!("Size of: ", stringify!(Thread__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<Thread__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Thread__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread__bindgen_ty_1>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread__bindgen_ty_1),
            "::",
            stringify!(mutex)
        )
    );
}
#[test]
fn bindgen_test_layout_Thread() {
    assert_eq!(
        ::std::mem::size_of::<Thread>(),
        400usize,
        concat!("Size of: ", stringify!(Thread))
    );
    assert_eq!(
        ::std::mem::align_of::<Thread>(),
        8usize,
        concat!("Alignment of ", stringify!(Thread))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).inSafeCopy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(inSafeCopy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).item as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(item)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).allItem as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(allItem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).processItem as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(processItem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).process as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(process)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).id as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).cpuTimeSlices as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(cpuTimeSlices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).handles as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).executingProcessorID as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(executingProcessorID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).userStackBase as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(userStackBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).kernelStackBase as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(kernelStackBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).kernelStack as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(kernelStack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).tlsAddress as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(tlsAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).userStackReserve as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(userStackReserve)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).userStackCommit as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(userStackCommit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).type_ as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).isKernelThread as *const _ as usize },
        193usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(isKernelThread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).isPageGenerator as *const _ as usize },
        194usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(isPageGenerator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).priority as *const _ as usize },
        195usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).blockedThreadPriorities as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(blockedThreadPriorities)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).state as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).terminatableState as *const _ as usize },
        205usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(terminatableState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).executing as *const _ as usize },
        206usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(executing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).terminating as *const _ as usize },
        207usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(terminating)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).paused as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(paused)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).receivedYieldIPI as *const _ as usize },
        209usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(receivedYieldIPI)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).blocking as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(blocking)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).killedEvent as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(killedEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).killAsyncTask as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(killAsyncTask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).temporaryAddressSpace as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(temporaryAddressSpace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).interruptContext as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(interruptContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Thread>())).lastKnownExecutionAddress as *const _ as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(lastKnownExecutionAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Thread>())).cName as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(cName)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct KNode {
    pub driverNode: *mut ::std::os::raw::c_void,
    pub handles: size_t,
    pub directoryEntry: *mut FSDirectoryEntry,
    pub fileSystem: *mut KFileSystem,
    pub id: u64,
    pub writerLock: KWriterLock,
    pub error: EsError,
    pub flags: u32,
    pub cacheItem: MMObjectCacheItem,
}
#[test]
fn bindgen_test_layout_KNode() {
    assert_eq!(
        ::std::mem::size_of::<KNode>(),
        104usize,
        concat!("Size of: ", stringify!(KNode))
    );
    assert_eq!(
        ::std::mem::align_of::<KNode>(),
        8usize,
        concat!("Alignment of ", stringify!(KNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KNode>())).driverNode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KNode),
            "::",
            stringify!(driverNode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KNode>())).handles as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(KNode),
            "::",
            stringify!(handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KNode>())).directoryEntry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(KNode),
            "::",
            stringify!(directoryEntry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KNode>())).fileSystem as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(KNode),
            "::",
            stringify!(fileSystem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KNode>())).id as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(KNode), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KNode>())).writerLock as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(KNode),
            "::",
            stringify!(writerLock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KNode>())).error as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(KNode),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KNode>())).flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(KNode),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KNode>())).cacheItem as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(KNode),
            "::",
            stringify!(cacheItem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KNodeMetadata {
    pub type_: EsNodeType,
    pub removingNodeFromCache: bool,
    pub removingThisFromCache: bool,
    pub totalSize: EsFileOffset,
    pub directoryChildren: EsFileOffsetDifference,
}
#[test]
fn bindgen_test_layout_KNodeMetadata() {
    assert_eq!(
        ::std::mem::size_of::<KNodeMetadata>(),
        24usize,
        concat!("Size of: ", stringify!(KNodeMetadata))
    );
    assert_eq!(
        ::std::mem::align_of::<KNodeMetadata>(),
        8usize,
        concat!("Alignment of ", stringify!(KNodeMetadata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KNodeMetadata>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KNodeMetadata),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<KNodeMetadata>())).removingNodeFromCache as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(KNodeMetadata),
            "::",
            stringify!(removingNodeFromCache)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<KNodeMetadata>())).removingThisFromCache as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(KNodeMetadata),
            "::",
            stringify!(removingThisFromCache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KNodeMetadata>())).totalSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(KNodeMetadata),
            "::",
            stringify!(totalSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KNodeMetadata>())).directoryChildren as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(KNodeMetadata),
            "::",
            stringify!(directoryChildren)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FSDirectoryEntry {
    pub _base: KNodeMetadata,
    pub cacheItem: MMObjectCacheItem,
    pub item: AVLItem<FSDirectoryEntry>,
    pub parent: *mut FSDirectory,
    pub node: *mut KNode,
    pub inlineName: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_FSDirectoryEntry() {
    assert_eq!(
        ::std::mem::size_of::<FSDirectoryEntry>(),
        136usize,
        concat!("Size of: ", stringify!(FSDirectoryEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<FSDirectoryEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(FSDirectoryEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSDirectoryEntry>())).cacheItem as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FSDirectoryEntry),
            "::",
            stringify!(cacheItem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSDirectoryEntry>())).item as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FSDirectoryEntry),
            "::",
            stringify!(item)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSDirectoryEntry>())).parent as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(FSDirectoryEntry),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSDirectoryEntry>())).node as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(FSDirectoryEntry),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSDirectoryEntry>())).inlineName as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(FSDirectoryEntry),
            "::",
            stringify!(inlineName)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FSDirectory {
    pub _base: KNode,
    pub entries: AVLTree<FSDirectoryEntry>,
    pub entryCount: size_t,
}
#[test]
fn bindgen_test_layout_FSDirectory() {
    assert_eq!(
        ::std::mem::size_of::<FSDirectory>(),
        128usize,
        concat!("Size of: ", stringify!(FSDirectory))
    );
    assert_eq!(
        ::std::mem::align_of::<FSDirectory>(),
        8usize,
        concat!("Alignment of ", stringify!(FSDirectory))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSDirectory>())).entries as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(FSDirectory),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSDirectory>())).entryCount as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(FSDirectory),
            "::",
            stringify!(entryCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCCachedSection {
    pub offset: EsFileOffset,
    pub pageCount: EsFileOffset,
    pub mappedRegionsCount: size_t,
    pub data: *mut usize,
}
#[test]
fn bindgen_test_layout_CCCachedSection() {
    assert_eq!(
        ::std::mem::size_of::<CCCachedSection>(),
        32usize,
        concat!("Size of: ", stringify!(CCCachedSection))
    );
    assert_eq!(
        ::std::mem::align_of::<CCCachedSection>(),
        8usize,
        concat!("Alignment of ", stringify!(CCCachedSection))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCCachedSection>())).offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CCCachedSection),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCCachedSection>())).pageCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CCCachedSection),
            "::",
            stringify!(pageCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CCCachedSection>())).mappedRegionsCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CCCachedSection),
            "::",
            stringify!(mappedRegionsCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCCachedSection>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CCCachedSection),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCSpaceCallbacks {
    pub readInto: ::std::option::Option<
        unsafe extern "C" fn(
            fileCache: *mut CCSpace,
            buffer: *mut ::std::os::raw::c_void,
            offset: EsFileOffset,
            count: EsFileOffset,
        ) -> EsError,
    >,
    pub writeFrom: ::std::option::Option<
        unsafe extern "C" fn(
            fileCache: *mut CCSpace,
            buffer: *const ::std::os::raw::c_void,
            offset: EsFileOffset,
            count: EsFileOffset,
        ) -> EsError,
    >,
}
#[test]
fn bindgen_test_layout_CCSpaceCallbacks() {
    assert_eq!(
        ::std::mem::size_of::<CCSpaceCallbacks>(),
        16usize,
        concat!("Size of: ", stringify!(CCSpaceCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<CCSpaceCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(CCSpaceCallbacks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCSpaceCallbacks>())).readInto as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CCSpaceCallbacks),
            "::",
            stringify!(readInto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCSpaceCallbacks>())).writeFrom as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CCSpaceCallbacks),
            "::",
            stringify!(writeFrom)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CCSpace {
    pub cachedSectionsMutex: KMutex,
    pub cachedSections: u64,
    pub activeSectionsMutex: KMutex,
    pub activeSections: u64,
    pub writeComplete: KEvent,
    pub callbacks: *const CCSpaceCallbacks,
}
#[test]
fn bindgen_test_layout_CCSpace() {
    assert_eq!(
        ::std::mem::size_of::<CCSpace>(),
        136usize,
        concat!("Size of: ", stringify!(CCSpace))
    );
    assert_eq!(
        ::std::mem::align_of::<CCSpace>(),
        8usize,
        concat!("Alignment of ", stringify!(CCSpace))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCSpace>())).cachedSectionsMutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CCSpace),
            "::",
            stringify!(cachedSectionsMutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCSpace>())).cachedSections as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CCSpace),
            "::",
            stringify!(cachedSections)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCSpace>())).activeSectionsMutex as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CCSpace),
            "::",
            stringify!(activeSectionsMutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCSpace>())).activeSections as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CCSpace),
            "::",
            stringify!(activeSections)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCSpace>())).writeComplete as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CCSpace),
            "::",
            stringify!(writeComplete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCSpace>())).callbacks as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CCSpace),
            "::",
            stringify!(callbacks)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FSFile {
    pub _base: KNode,
    pub countWrite: i32,
    pub blockResize: i32,
    pub fsFileSize: EsFileOffset,
    pub fsZeroAfter: EsFileOffset,
    pub cache: CCSpace,
    pub resizeLock: KWriterLock,
}
#[test]
fn bindgen_test_layout_FSFile() {
    assert_eq!(
        ::std::mem::size_of::<FSFile>(),
        296usize,
        concat!("Size of: ", stringify!(FSFile))
    );
    assert_eq!(
        ::std::mem::align_of::<FSFile>(),
        8usize,
        concat!("Alignment of ", stringify!(FSFile))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSFile>())).countWrite as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(FSFile),
            "::",
            stringify!(countWrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSFile>())).blockResize as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(FSFile),
            "::",
            stringify!(blockResize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSFile>())).fsFileSize as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(FSFile),
            "::",
            stringify!(fsFileSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSFile>())).fsZeroAfter as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(FSFile),
            "::",
            stringify!(fsZeroAfter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSFile>())).cache as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(FSFile),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FSFile>())).resizeLock as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(FSFile),
            "::",
            stringify!(resizeLock)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsRectangle {
    pub l: i32,
    pub r: i32,
    pub t: i32,
    pub b: i32,
}
#[test]
fn bindgen_test_layout_EsRectangle() {
    assert_eq!(
        ::std::mem::size_of::<EsRectangle>(),
        16usize,
        concat!("Size of: ", stringify!(EsRectangle))
    );
    assert_eq!(
        ::std::mem::align_of::<EsRectangle>(),
        4usize,
        concat!("Alignment of ", stringify!(EsRectangle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsRectangle>())).l as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsRectangle),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsRectangle>())).r as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EsRectangle),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsRectangle>())).t as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsRectangle),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsRectangle>())).b as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(EsRectangle),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsElement {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsBundle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Instance {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMountPoint {
    _unused: [u8; 0],
}
pub const EsMessageType_ES_MSG_INVALID: EsMessageType = 0;
pub const EsMessageType_ES_MSG_WM_START: EsMessageType = 4096;
pub const EsMessageType_ES_MSG_MOUSE_MOVED: EsMessageType = 4097;
pub const EsMessageType_ES_MSG_WINDOW_ACTIVATED: EsMessageType = 4098;
pub const EsMessageType_ES_MSG_WINDOW_DEACTIVATED: EsMessageType = 4099;
pub const EsMessageType_ES_MSG_WINDOW_DESTROYED: EsMessageType = 4100;
pub const EsMessageType_ES_MSG_MOUSE_EXIT: EsMessageType = 4102;
pub const EsMessageType_ES_MSG_WINDOW_RESIZED: EsMessageType = 4103;
pub const EsMessageType_ES_MSG_MOUSE_LEFT_DOWN: EsMessageType = 4104;
pub const EsMessageType_ES_MSG_MOUSE_LEFT_UP: EsMessageType = 4105;
pub const EsMessageType_ES_MSG_MOUSE_RIGHT_DOWN: EsMessageType = 4106;
pub const EsMessageType_ES_MSG_MOUSE_RIGHT_UP: EsMessageType = 4107;
pub const EsMessageType_ES_MSG_MOUSE_MIDDLE_DOWN: EsMessageType = 4108;
pub const EsMessageType_ES_MSG_MOUSE_MIDDLE_UP: EsMessageType = 4109;
pub const EsMessageType_ES_MSG_KEY_DOWN: EsMessageType = 4110;
pub const EsMessageType_ES_MSG_KEY_UP: EsMessageType = 4111;
pub const EsMessageType_ES_MSG_UPDATE_WINDOW: EsMessageType = 4112;
pub const EsMessageType_ES_MSG_SCROLL_WHEEL: EsMessageType = 4113;
pub const EsMessageType_ES_MSG_WM_END: EsMessageType = 5119;
pub const EsMessageType_ES_MSG_PAINT: EsMessageType = 8192;
pub const EsMessageType_ES_MSG_PAINT_BACKGROUND: EsMessageType = 8193;
pub const EsMessageType_ES_MSG_GET_CURSOR: EsMessageType = 8195;
pub const EsMessageType_ES_MSG_ANIMATE: EsMessageType = 8196;
pub const EsMessageType_ES_MSG_Z_ORDER: EsMessageType = 8197;
pub const EsMessageType_ES_MSG_DESTROY: EsMessageType = 8198;
pub const EsMessageType_ES_MSG_GET_WIDTH: EsMessageType = 8199;
pub const EsMessageType_ES_MSG_GET_HEIGHT: EsMessageType = 8200;
pub const EsMessageType_ES_MSG_LAYOUT: EsMessageType = 8201;
pub const EsMessageType_ES_MSG_ENSURE_VISIBLE: EsMessageType = 8202;
pub const EsMessageType_ES_MSG_ADD_CHILD: EsMessageType = 8203;
pub const EsMessageType_ES_MSG_REMOVE_CHILD: EsMessageType = 8204;
pub const EsMessageType_ES_MSG_PRE_ADD_CHILD: EsMessageType = 8205;
pub const EsMessageType_ES_MSG_HIT_TEST: EsMessageType = 8206;
pub const EsMessageType_ES_MSG_KEY_TYPED: EsMessageType = 8209;
pub const EsMessageType_ES_MSG_SCROLL_X: EsMessageType = 8210;
pub const EsMessageType_ES_MSG_SCROLL_Y: EsMessageType = 8211;
pub const EsMessageType_ES_MSG_STRONG_FOCUS_END: EsMessageType = 8212;
pub const EsMessageType_ES_MSG_BEFORE_Z_ORDER: EsMessageType = 8213;
pub const EsMessageType_ES_MSG_AFTER_Z_ORDER: EsMessageType = 8214;
pub const EsMessageType_ES_MSG_PAINT_CHILDREN: EsMessageType = 8215;
pub const EsMessageType_ES_MSG_DESTROY_CONTENTS: EsMessageType = 8216;
pub const EsMessageType_ES_MSG_GET_INSPECTOR_INFORMATION: EsMessageType = 8217;
pub const EsMessageType_ES_MSG_NOT_VISIBLE: EsMessageType = 8224;
pub const EsMessageType_ES_MSG_GET_CHILD_STYLE_VARIANT: EsMessageType = 8225;
pub const EsMessageType_ES_MSG_PAINT_ICON: EsMessageType = 8226;
pub const EsMessageType_ES_MSG_MOUSE_LEFT_CLICK: EsMessageType = 8227;
pub const EsMessageType_ES_MSG_MOUSE_RIGHT_CLICK: EsMessageType = 8228;
pub const EsMessageType_ES_MSG_MOUSE_MIDDLE_CLICK: EsMessageType = 8229;
pub const EsMessageType_ES_MSG_MOUSE_LEFT_DRAG: EsMessageType = 8230;
pub const EsMessageType_ES_MSG_MOUSE_RIGHT_DRAG: EsMessageType = 8231;
pub const EsMessageType_ES_MSG_MOUSE_MIDDLE_DRAG: EsMessageType = 8232;
pub const EsMessageType_ES_MSG_GET_ACCESS_KEY_HINT_BOUNDS: EsMessageType = 8233;
pub const EsMessageType_ES_MSG_UI_SCALE_CHANGED: EsMessageType = 8234;
pub const EsMessageType_ES_MSG_TRANSITION_COMPLETE: EsMessageType = 8235;
pub const EsMessageType_ES_MSG_STATE_CHANGE_MESSAGE_START: EsMessageType = 8320;
pub const EsMessageType_ES_MSG_HOVERED_START: EsMessageType = 8321;
pub const EsMessageType_ES_MSG_HOVERED_END: EsMessageType = 8322;
pub const EsMessageType_ES_MSG_PRESSED_START: EsMessageType = 8323;
pub const EsMessageType_ES_MSG_PRESSED_END: EsMessageType = 8324;
pub const EsMessageType_ES_MSG_FOCUSED_START: EsMessageType = 8325;
pub const EsMessageType_ES_MSG_FOCUSED_END: EsMessageType = 8326;
pub const EsMessageType_ES_MSG_FOCUS_WITHIN_START: EsMessageType = 8327;
pub const EsMessageType_ES_MSG_FOCUS_WITHIN_END: EsMessageType = 8328;
pub const EsMessageType_ES_MSG_STATE_CHANGE_MESSAGE_END: EsMessageType = 8447;
pub const EsMessageType_ES_MSG_SCROLLBAR_MOVED: EsMessageType = 12288;
pub const EsMessageType_ES_MSG_CHECK_UPDATED: EsMessageType = 12289;
pub const EsMessageType_ES_MSG_RADIO_GROUP_UPDATED: EsMessageType = 12290;
pub const EsMessageType_ES_MSG_COLOR_CHANGED: EsMessageType = 12291;
pub const EsMessageType_ES_MSG_LIST_DISPLAY_GET_MARKER: EsMessageType = 12292;
pub const EsMessageType_ES_MSG_SLIDER_MOVED: EsMessageType = 12294;
pub const EsMessageType_ES_MSG_EMBEDDED_WINDOW_DESTROYED: EsMessageType = 18434;
pub const EsMessageType_ES_MSG_SET_SCREEN_RESOLUTION: EsMessageType = 18435;
pub const EsMessageType_ES_MSG_REGISTER_FILE_SYSTEM: EsMessageType = 18436;
pub const EsMessageType_ES_MSG_UNREGISTER_FILE_SYSTEM: EsMessageType = 18437;
pub const EsMessageType_ES_MSG_DESKTOP: EsMessageType = 18438;
pub const EsMessageType_ES_MSG_DEVICE_CONNECTED: EsMessageType = 18439;
pub const EsMessageType_ES_MSG_DEVICE_DISCONNECTED: EsMessageType = 18440;
pub const EsMessageType_ES_MSG_TAB_INSPECT_UI: EsMessageType = 18945;
pub const EsMessageType_ES_MSG_TAB_CLOSE_REQUEST: EsMessageType = 18946;
pub const EsMessageType_ES_MSG_INSTANCE_SAVE_RESPONSE: EsMessageType = 18947;
pub const EsMessageType_ES_MSG_INSTANCE_DOCUMENT_RENAMED: EsMessageType = 18948;
pub const EsMessageType_ES_MSG_INSTANCE_DOCUMENT_UPDATED: EsMessageType = 18949;
pub const EsMessageType_ES_MSG_PRIMARY_CLIPBOARD_UPDATED: EsMessageType = 18950;
pub const EsMessageType_ES_MSG_INSTANCE_RENAME_RESPONSE: EsMessageType = 18951;
pub const EsMessageType_ES_MSG_APPLICATION_CRASH: EsMessageType = 19456;
pub const EsMessageType_ES_MSG_PROCESS_TERMINATED: EsMessageType = 19457;
pub const EsMessageType_ES_MSG_UNDO_CANCEL: EsMessageType = 19712;
pub const EsMessageType_ES_MSG_UNDO_INVOKE: EsMessageType = 19713;
pub const EsMessageType_ES_MSG_UNDO_TO_STRING: EsMessageType = 19714;
pub const EsMessageType_ES_MSG_EYEDROP_REPORT: EsMessageType = 20481;
pub const EsMessageType_ES_MSG_TIMER: EsMessageType = 20483;
pub const EsMessageType_ES_MSG_PING: EsMessageType = 20484;
pub const EsMessageType_ES_MSG_WAKEUP: EsMessageType = 20485;
pub const EsMessageType_ES_MSG_FILE_MANAGER_FILE_MODIFIED: EsMessageType = 20736;
pub const EsMessageType_ES_MSG_FILE_MANAGER_PATH_MOVED: EsMessageType = 20737;
pub const EsMessageType_ES_MSG_FILE_MANAGER_DOCUMENT_UPDATE: EsMessageType = 20738;
pub const EsMessageType_ES_MSG_TEXTBOX_UPDATED: EsMessageType = 20992;
pub const EsMessageType_ES_MSG_TEXTBOX_EDIT_START: EsMessageType = 20993;
pub const EsMessageType_ES_MSG_TEXTBOX_EDIT_END: EsMessageType = 20994;
pub const EsMessageType_ES_MSG_TEXTBOX_NUMBER_DRAG_START: EsMessageType = 20995;
pub const EsMessageType_ES_MSG_TEXTBOX_NUMBER_DRAG_END: EsMessageType = 20996;
pub const EsMessageType_ES_MSG_TEXTBOX_NUMBER_DRAG_DELTA: EsMessageType = 20997;
pub const EsMessageType_ES_MSG_TEXTBOX_NUMBER_UPDATED: EsMessageType = 20998;
pub const EsMessageType_ES_MSG_TEXTBOX_GET_BREADCRUMB: EsMessageType = 20999;
pub const EsMessageType_ES_MSG_TEXTBOX_ACTIVATE_BREADCRUMB: EsMessageType = 21000;
pub const EsMessageType_ES_MSG_LIST_VIEW_FIND_INDEX: EsMessageType = 21253;
pub const EsMessageType_ES_MSG_LIST_VIEW_MEASURE_RANGE: EsMessageType = 21255;
pub const EsMessageType_ES_MSG_LIST_VIEW_MEASURE_ITEM: EsMessageType = 21256;
pub const EsMessageType_ES_MSG_LIST_VIEW_CREATE_ITEM: EsMessageType = 21257;
pub const EsMessageType_ES_MSG_LIST_VIEW_GET_CONTENT: EsMessageType = 21258;
pub const EsMessageType_ES_MSG_LIST_VIEW_GET_INDENT: EsMessageType = 21259;
pub const EsMessageType_ES_MSG_LIST_VIEW_FIND_POSITION: EsMessageType = 21260;
pub const EsMessageType_ES_MSG_LIST_VIEW_IS_SELECTED: EsMessageType = 21261;
pub const EsMessageType_ES_MSG_LIST_VIEW_SELECT: EsMessageType = 21262;
pub const EsMessageType_ES_MSG_LIST_VIEW_SELECT_RANGE: EsMessageType = 21263;
pub const EsMessageType_ES_MSG_LIST_VIEW_CHOOSE_ITEM: EsMessageType = 21264;
pub const EsMessageType_ES_MSG_LIST_VIEW_SEARCH: EsMessageType = 21265;
pub const EsMessageType_ES_MSG_LIST_VIEW_CONTEXT_MENU: EsMessageType = 21266;
pub const EsMessageType_ES_MSG_LIST_VIEW_COLUMN_MENU: EsMessageType = 21267;
pub const EsMessageType_ES_MSG_LIST_VIEW_GET_SUMMARY: EsMessageType = 21268;
pub const EsMessageType_ES_MSG_LIST_VIEW_GET_COLUMN_SORT: EsMessageType = 21269;
pub const EsMessageType_ES_MSG_REORDER_ITEM_TEST: EsMessageType = 21504;
pub const EsMessageType_ES_MSG_REORDER_ITEM_MOVED: EsMessageType = 21505;
pub const EsMessageType_ES_MSG_APPLICATION_EXIT: EsMessageType = 28673;
pub const EsMessageType_ES_MSG_INSTANCE_CREATE: EsMessageType = 28674;
pub const EsMessageType_ES_MSG_INSTANCE_OPEN: EsMessageType = 28675;
pub const EsMessageType_ES_MSG_INSTANCE_SAVE: EsMessageType = 28676;
pub const EsMessageType_ES_MSG_INSTANCE_DESTROY: EsMessageType = 28677;
pub const EsMessageType_ES_MSG_INSTANCE_CLOSE: EsMessageType = 28678;
pub const EsMessageType_ES_MSG_USER_START: EsMessageType = 32768;
pub const EsMessageType_ES_MSG_USER_END: EsMessageType = 49151;
pub type EsMessageType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EsFileStore {
    pub type_: u8,
    pub operationComplete: bool,
    pub handles: u32,
    pub error: EsError,
    pub __bindgen_anon_1: EsFileStore__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EsFileStore__bindgen_ty_1 {
    pub handle: EsHandle,
    pub __bindgen_anon_1: EsFileStore__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsFileStore__bindgen_ty_1__bindgen_ty_1 {
    pub bundle: *const EsBundle,
    pub path: *mut ::std::os::raw::c_char,
    pub pathBytes: size_t,
}
#[test]
fn bindgen_test_layout_EsFileStore__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<EsFileStore__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(EsFileStore__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<EsFileStore__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(EsFileStore__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsFileStore__bindgen_ty_1__bindgen_ty_1>())).bundle as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsFileStore__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(bundle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsFileStore__bindgen_ty_1__bindgen_ty_1>())).path as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsFileStore__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsFileStore__bindgen_ty_1__bindgen_ty_1>())).pathBytes
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsFileStore__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pathBytes)
        )
    );
}
#[test]
fn bindgen_test_layout_EsFileStore__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<EsFileStore__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(EsFileStore__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<EsFileStore__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(EsFileStore__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsFileStore__bindgen_ty_1>())).handle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsFileStore__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
}
#[test]
fn bindgen_test_layout_EsFileStore() {
    assert_eq!(
        ::std::mem::size_of::<EsFileStore>(),
        40usize,
        concat!("Size of: ", stringify!(EsFileStore))
    );
    assert_eq!(
        ::std::mem::align_of::<EsFileStore>(),
        8usize,
        concat!("Alignment of ", stringify!(EsFileStore))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsFileStore>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsFileStore),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsFileStore>())).operationComplete as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(EsFileStore),
            "::",
            stringify!(operationComplete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsFileStore>())).handles as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EsFileStore),
            "::",
            stringify!(handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsFileStore>())).error as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsFileStore),
            "::",
            stringify!(error)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EsBuffer {
    pub __bindgen_anon_1: EsBuffer__bindgen_ty_1,
    pub position: size_t,
    pub bytes: size_t,
    pub context: *mut ::std::os::raw::c_void,
    pub fileStore: *mut EsFileStore,
    pub error: bool,
    pub canGrow: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EsBuffer__bindgen_ty_1 {
    pub in_: *const u8,
    pub out: *mut u8,
}
#[test]
fn bindgen_test_layout_EsBuffer__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<EsBuffer__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(EsBuffer__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<EsBuffer__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(EsBuffer__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsBuffer__bindgen_ty_1>())).in_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsBuffer__bindgen_ty_1),
            "::",
            stringify!(in_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsBuffer__bindgen_ty_1>())).out as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsBuffer__bindgen_ty_1),
            "::",
            stringify!(out)
        )
    );
}
#[test]
fn bindgen_test_layout_EsBuffer() {
    assert_eq!(
        ::std::mem::size_of::<EsBuffer>(),
        48usize,
        concat!("Size of: ", stringify!(EsBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<EsBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(EsBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsBuffer>())).position as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsBuffer),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsBuffer>())).bytes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsBuffer),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsBuffer>())).context as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EsBuffer),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsBuffer>())).fileStore as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(EsBuffer),
            "::",
            stringify!(fileStore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsBuffer>())).error as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(EsBuffer),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsBuffer>())).canGrow as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(EsBuffer),
            "::",
            stringify!(canGrow)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageMouseMotion {
    pub newPositionX: ::std::os::raw::c_int,
    pub newPositionY: ::std::os::raw::c_int,
    pub originalPositionX: ::std::os::raw::c_int,
    pub originalPositionY: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_EsMessageMouseMotion() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageMouseMotion>(),
        16usize,
        concat!("Size of: ", stringify!(EsMessageMouseMotion))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageMouseMotion>(),
        4usize,
        concat!("Alignment of ", stringify!(EsMessageMouseMotion))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessageMouseMotion>())).newPositionX as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageMouseMotion),
            "::",
            stringify!(newPositionX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessageMouseMotion>())).newPositionY as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageMouseMotion),
            "::",
            stringify!(newPositionY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessageMouseMotion>())).originalPositionX as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageMouseMotion),
            "::",
            stringify!(originalPositionX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessageMouseMotion>())).originalPositionY as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageMouseMotion),
            "::",
            stringify!(originalPositionY)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageMouseButton {
    pub positionX: ::std::os::raw::c_int,
    pub positionY: ::std::os::raw::c_int,
    pub clickChainCount: u8,
}
#[test]
fn bindgen_test_layout_EsMessageMouseButton() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageMouseButton>(),
        12usize,
        concat!("Size of: ", stringify!(EsMessageMouseButton))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageMouseButton>(),
        4usize,
        concat!("Alignment of ", stringify!(EsMessageMouseButton))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageMouseButton>())).positionX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageMouseButton),
            "::",
            stringify!(positionX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageMouseButton>())).positionY as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageMouseButton),
            "::",
            stringify!(positionY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessageMouseButton>())).clickChainCount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageMouseButton),
            "::",
            stringify!(clickChainCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageKeyboard {
    pub scancode: u16,
    pub modifiers: u8,
    pub repeat: bool,
    pub numpad: bool,
    pub numlock: bool,
    pub single: bool,
}
#[test]
fn bindgen_test_layout_EsMessageKeyboard() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageKeyboard>(),
        8usize,
        concat!("Size of: ", stringify!(EsMessageKeyboard))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageKeyboard>(),
        2usize,
        concat!("Alignment of ", stringify!(EsMessageKeyboard))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageKeyboard>())).scancode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageKeyboard),
            "::",
            stringify!(scancode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageKeyboard>())).modifiers as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageKeyboard),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageKeyboard>())).repeat as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageKeyboard),
            "::",
            stringify!(repeat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageKeyboard>())).numpad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageKeyboard),
            "::",
            stringify!(numpad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageKeyboard>())).numlock as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageKeyboard),
            "::",
            stringify!(numlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageKeyboard>())).single as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageKeyboard),
            "::",
            stringify!(single)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageWindowActivated {
    pub leftModifiers: u8,
    pub rightModifiers: u8,
}
#[test]
fn bindgen_test_layout_EsMessageWindowActivated() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageWindowActivated>(),
        2usize,
        concat!("Size of: ", stringify!(EsMessageWindowActivated))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageWindowActivated>(),
        1usize,
        concat!("Alignment of ", stringify!(EsMessageWindowActivated))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessageWindowActivated>())).leftModifiers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageWindowActivated),
            "::",
            stringify!(leftModifiers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessageWindowActivated>())).rightModifiers as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageWindowActivated),
            "::",
            stringify!(rightModifiers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageScrollWheel {
    pub dx: i32,
    pub dy: i32,
}
#[test]
fn bindgen_test_layout_EsMessageScrollWheel() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageScrollWheel>(),
        8usize,
        concat!("Size of: ", stringify!(EsMessageScrollWheel))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageScrollWheel>(),
        4usize,
        concat!("Alignment of ", stringify!(EsMessageScrollWheel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageScrollWheel>())).dx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageScrollWheel),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageScrollWheel>())).dy as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageScrollWheel),
            "::",
            stringify!(dy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageAnimate {
    pub deltaMs: i64,
    pub waitMs: i64,
    pub complete: bool,
}
#[test]
fn bindgen_test_layout_EsMessageAnimate() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageAnimate>(),
        24usize,
        concat!("Size of: ", stringify!(EsMessageAnimate))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageAnimate>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageAnimate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageAnimate>())).deltaMs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageAnimate),
            "::",
            stringify!(deltaMs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageAnimate>())).waitMs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageAnimate),
            "::",
            stringify!(waitMs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageAnimate>())).complete as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageAnimate),
            "::",
            stringify!(complete)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageLayout {
    pub sizeChanged: bool,
}
#[test]
fn bindgen_test_layout_EsMessageLayout() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageLayout>(),
        1usize,
        concat!("Size of: ", stringify!(EsMessageLayout))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageLayout>(),
        1usize,
        concat!("Alignment of ", stringify!(EsMessageLayout))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageLayout>())).sizeChanged as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageLayout),
            "::",
            stringify!(sizeChanged)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageWindowResized {
    pub content: EsRectangle,
    pub hidden: bool,
}
#[test]
fn bindgen_test_layout_EsMessageWindowResized() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageWindowResized>(),
        20usize,
        concat!("Size of: ", stringify!(EsMessageWindowResized))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageWindowResized>(),
        4usize,
        concat!("Alignment of ", stringify!(EsMessageWindowResized))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageWindowResized>())).content as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageWindowResized),
            "::",
            stringify!(content)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageWindowResized>())).hidden as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageWindowResized),
            "::",
            stringify!(hidden)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageMeasure {
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_EsMessageMeasure() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageMeasure>(),
        8usize,
        concat!("Size of: ", stringify!(EsMessageMeasure))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageMeasure>(),
        4usize,
        concat!("Alignment of ", stringify!(EsMessageMeasure))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageMeasure>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageMeasure),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageMeasure>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageMeasure),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageHitTest {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub inside: bool,
}
#[test]
fn bindgen_test_layout_EsMessageHitTest() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageHitTest>(),
        12usize,
        concat!("Size of: ", stringify!(EsMessageHitTest))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageHitTest>(),
        4usize,
        concat!("Alignment of ", stringify!(EsMessageHitTest))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageHitTest>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageHitTest),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageHitTest>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageHitTest),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageHitTest>())).inside as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageHitTest),
            "::",
            stringify!(inside)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageZOrder {
    pub index: usize,
    pub child: *mut EsElement,
}
#[test]
fn bindgen_test_layout_EsMessageZOrder() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageZOrder>(),
        16usize,
        concat!("Size of: ", stringify!(EsMessageZOrder))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageZOrder>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageZOrder))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageZOrder>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageZOrder),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageZOrder>())).child as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageZOrder),
            "::",
            stringify!(child)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageBeforeZOrder {
    pub start: usize,
    pub end: usize,
    pub nonClient: usize,
    pub clip: EsRectangle,
}
#[test]
fn bindgen_test_layout_EsMessageBeforeZOrder() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageBeforeZOrder>(),
        40usize,
        concat!("Size of: ", stringify!(EsMessageBeforeZOrder))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageBeforeZOrder>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageBeforeZOrder))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageBeforeZOrder>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageBeforeZOrder),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageBeforeZOrder>())).end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageBeforeZOrder),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageBeforeZOrder>())).nonClient as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageBeforeZOrder),
            "::",
            stringify!(nonClient)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageBeforeZOrder>())).clip as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageBeforeZOrder),
            "::",
            stringify!(clip)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EsMessageItemToString {
    pub item: EsGeneric,
    pub text: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_EsMessageItemToString() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageItemToString>(),
        16usize,
        concat!("Size of: ", stringify!(EsMessageItemToString))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageItemToString>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageItemToString))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageItemToString>())).item as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageItemToString),
            "::",
            stringify!(item)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageItemToString>())).text as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageItemToString),
            "::",
            stringify!(text)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageIterateIndex {
    pub group: EsListViewIndex,
    pub index: EsListViewIndex,
    pub position: i64,
}
#[test]
fn bindgen_test_layout_EsMessageIterateIndex() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageIterateIndex>(),
        24usize,
        concat!("Size of: ", stringify!(EsMessageIterateIndex))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageIterateIndex>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageIterateIndex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageIterateIndex>())).group as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageIterateIndex),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageIterateIndex>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageIterateIndex),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageIterateIndex>())).position as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageIterateIndex),
            "::",
            stringify!(position)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageItemRange {
    pub group: EsListViewIndex,
    pub firstIndex: EsListViewIndex,
    pub count: u64,
    pub result: i64,
}
#[test]
fn bindgen_test_layout_EsMessageItemRange() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageItemRange>(),
        32usize,
        concat!("Size of: ", stringify!(EsMessageItemRange))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageItemRange>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageItemRange))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageItemRange>())).group as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageItemRange),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageItemRange>())).firstIndex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageItemRange),
            "::",
            stringify!(firstIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageItemRange>())).count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageItemRange),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageItemRange>())).result as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageItemRange),
            "::",
            stringify!(result)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageMeasureItem {
    pub group: EsListViewIndex,
    pub index: EsListViewIndex,
    pub result: i64,
}
#[test]
fn bindgen_test_layout_EsMessageMeasureItem() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageMeasureItem>(),
        24usize,
        concat!("Size of: ", stringify!(EsMessageMeasureItem))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageMeasureItem>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageMeasureItem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageMeasureItem>())).group as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageMeasureItem),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageMeasureItem>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageMeasureItem),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageMeasureItem>())).result as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageMeasureItem),
            "::",
            stringify!(result)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageCreateItem {
    pub group: EsListViewIndex,
    pub index: EsListViewIndex,
    pub item: *mut EsElement,
}
#[test]
fn bindgen_test_layout_EsMessageCreateItem() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageCreateItem>(),
        24usize,
        concat!("Size of: ", stringify!(EsMessageCreateItem))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageCreateItem>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageCreateItem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageCreateItem>())).group as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageCreateItem),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageCreateItem>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageCreateItem),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageCreateItem>())).item as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageCreateItem),
            "::",
            stringify!(item)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageGetContent {
    pub index: EsListViewIndex,
    pub group: EsListViewIndex,
    pub icon: u32,
    pub drawContentFlags: u32,
    pub buffer: *mut EsBuffer,
    pub column: u8,
}
#[test]
fn bindgen_test_layout_EsMessageGetContent() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageGetContent>(),
        40usize,
        concat!("Size of: ", stringify!(EsMessageGetContent))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageGetContent>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageGetContent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageGetContent>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageGetContent),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageGetContent>())).group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageGetContent),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageGetContent>())).icon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageGetContent),
            "::",
            stringify!(icon)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessageGetContent>())).drawContentFlags as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageGetContent),
            "::",
            stringify!(drawContentFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageGetContent>())).buffer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageGetContent),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageGetContent>())).column as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageGetContent),
            "::",
            stringify!(column)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageGetIndent {
    pub group: EsListViewIndex,
    pub index: EsListViewIndex,
    pub indent: u8,
}
#[test]
fn bindgen_test_layout_EsMessageGetIndent() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageGetIndent>(),
        24usize,
        concat!("Size of: ", stringify!(EsMessageGetIndent))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageGetIndent>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageGetIndent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageGetIndent>())).group as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageGetIndent),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageGetIndent>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageGetIndent),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageGetIndent>())).indent as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageGetIndent),
            "::",
            stringify!(indent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageSelectRange {
    pub fromIndex: EsListViewIndex,
    pub toIndex: EsListViewIndex,
    pub group: EsListViewIndex,
    pub select: bool,
    pub toggle: bool,
}
#[test]
fn bindgen_test_layout_EsMessageSelectRange() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageSelectRange>(),
        32usize,
        concat!("Size of: ", stringify!(EsMessageSelectRange))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageSelectRange>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageSelectRange))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageSelectRange>())).fromIndex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageSelectRange),
            "::",
            stringify!(fromIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageSelectRange>())).toIndex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageSelectRange),
            "::",
            stringify!(toIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageSelectRange>())).group as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageSelectRange),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageSelectRange>())).select as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageSelectRange),
            "::",
            stringify!(select)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageSelectRange>())).toggle as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageSelectRange),
            "::",
            stringify!(toggle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageSelectItem {
    pub group: EsListViewIndex,
    pub index: EsListViewIndex,
    pub isSelected: bool,
}
#[test]
fn bindgen_test_layout_EsMessageSelectItem() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageSelectItem>(),
        24usize,
        concat!("Size of: ", stringify!(EsMessageSelectItem))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageSelectItem>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageSelectItem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageSelectItem>())).group as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageSelectItem),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageSelectItem>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageSelectItem),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageSelectItem>())).isSelected as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageSelectItem),
            "::",
            stringify!(isSelected)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageChooseItem {
    pub group: EsListViewIndex,
    pub index: EsListViewIndex,
}
#[test]
fn bindgen_test_layout_EsMessageChooseItem() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageChooseItem>(),
        16usize,
        concat!("Size of: ", stringify!(EsMessageChooseItem))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageChooseItem>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageChooseItem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageChooseItem>())).group as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageChooseItem),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageChooseItem>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageChooseItem),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageSearchItem {
    pub group: EsListViewIndex,
    pub index: EsListViewIndex,
    pub query: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_EsMessageSearchItem() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageSearchItem>(),
        24usize,
        concat!("Size of: ", stringify!(EsMessageSearchItem))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageSearchItem>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageSearchItem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageSearchItem>())).group as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageSearchItem),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageSearchItem>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageSearchItem),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageSearchItem>())).query as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageSearchItem),
            "::",
            stringify!(query)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageFocus {
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_EsMessageFocus() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageFocus>(),
        4usize,
        concat!("Size of: ", stringify!(EsMessageFocus))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageFocus>(),
        4usize,
        concat!("Alignment of ", stringify!(EsMessageFocus))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageFocus>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageFocus),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageColumnMenu {
    pub index: u8,
    pub source: *mut EsElement,
}
#[test]
fn bindgen_test_layout_EsMessageColumnMenu() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageColumnMenu>(),
        16usize,
        concat!("Size of: ", stringify!(EsMessageColumnMenu))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageColumnMenu>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageColumnMenu))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageColumnMenu>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageColumnMenu),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageColumnMenu>())).source as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageColumnMenu),
            "::",
            stringify!(source)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageGetColumnSort {
    pub index: u8,
}
#[test]
fn bindgen_test_layout_EsMessageGetColumnSort() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageGetColumnSort>(),
        1usize,
        concat!("Size of: ", stringify!(EsMessageGetColumnSort))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageGetColumnSort>(),
        1usize,
        concat!("Alignment of ", stringify!(EsMessageGetColumnSort))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageGetColumnSort>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageGetColumnSort),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageScrollbarMoved {
    pub scroll: ::std::os::raw::c_int,
    pub previous: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_EsMessageScrollbarMoved() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageScrollbarMoved>(),
        8usize,
        concat!("Size of: ", stringify!(EsMessageScrollbarMoved))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageScrollbarMoved>(),
        4usize,
        concat!("Alignment of ", stringify!(EsMessageScrollbarMoved))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageScrollbarMoved>())).scroll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageScrollbarMoved),
            "::",
            stringify!(scroll)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessageScrollbarMoved>())).previous as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageScrollbarMoved),
            "::",
            stringify!(previous)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageSliderMoved {
    pub value: f64,
    pub previous: f64,
    pub inDrag: bool,
}
#[test]
fn bindgen_test_layout_EsMessageSliderMoved() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageSliderMoved>(),
        24usize,
        concat!("Size of: ", stringify!(EsMessageSliderMoved))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageSliderMoved>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageSliderMoved))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageSliderMoved>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageSliderMoved),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageSliderMoved>())).previous as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageSliderMoved),
            "::",
            stringify!(previous)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageSliderMoved>())).inDrag as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageSliderMoved),
            "::",
            stringify!(inDrag)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageColorChanged {
    pub newColor: u32,
    pub pickerClosed: bool,
}
#[test]
fn bindgen_test_layout_EsMessageColorChanged() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageColorChanged>(),
        8usize,
        concat!("Size of: ", stringify!(EsMessageColorChanged))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageColorChanged>(),
        4usize,
        concat!("Alignment of ", stringify!(EsMessageColorChanged))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageColorChanged>())).newColor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageColorChanged),
            "::",
            stringify!(newColor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessageColorChanged>())).pickerClosed as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageColorChanged),
            "::",
            stringify!(pickerClosed)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageNumberDragDelta {
    pub delta: ::std::os::raw::c_int,
    pub hoverCharacter: i32,
    pub fast: bool,
}
#[test]
fn bindgen_test_layout_EsMessageNumberDragDelta() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageNumberDragDelta>(),
        12usize,
        concat!("Size of: ", stringify!(EsMessageNumberDragDelta))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageNumberDragDelta>(),
        4usize,
        concat!("Alignment of ", stringify!(EsMessageNumberDragDelta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageNumberDragDelta>())).delta as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageNumberDragDelta),
            "::",
            stringify!(delta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessageNumberDragDelta>())).hoverCharacter as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageNumberDragDelta),
            "::",
            stringify!(hoverCharacter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageNumberDragDelta>())).fast as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageNumberDragDelta),
            "::",
            stringify!(fast)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageNumberUpdated {
    pub delta: f64,
    pub newValue: f64,
}
#[test]
fn bindgen_test_layout_EsMessageNumberUpdated() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageNumberUpdated>(),
        16usize,
        concat!("Size of: ", stringify!(EsMessageNumberUpdated))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageNumberUpdated>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageNumberUpdated))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageNumberUpdated>())).delta as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageNumberUpdated),
            "::",
            stringify!(delta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageNumberUpdated>())).newValue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageNumberUpdated),
            "::",
            stringify!(newValue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageGetBreadcrumb {
    pub index: usize,
    pub buffer: *mut EsBuffer,
    pub icon: u32,
}
#[test]
fn bindgen_test_layout_EsMessageGetBreadcrumb() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageGetBreadcrumb>(),
        24usize,
        concat!("Size of: ", stringify!(EsMessageGetBreadcrumb))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageGetBreadcrumb>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageGetBreadcrumb))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageGetBreadcrumb>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageGetBreadcrumb),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageGetBreadcrumb>())).buffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageGetBreadcrumb),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageGetBreadcrumb>())).icon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageGetBreadcrumb),
            "::",
            stringify!(icon)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageEndEdit {
    pub rejected: bool,
    pub unchanged: bool,
}
#[test]
fn bindgen_test_layout_EsMessageEndEdit() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageEndEdit>(),
        2usize,
        concat!("Size of: ", stringify!(EsMessageEndEdit))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageEndEdit>(),
        1usize,
        concat!("Alignment of ", stringify!(EsMessageEndEdit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageEndEdit>())).rejected as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageEndEdit),
            "::",
            stringify!(rejected)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageEndEdit>())).unchanged as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageEndEdit),
            "::",
            stringify!(unchanged)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageInstanceOpen {
    pub instance: *mut Instance,
    pub file: *mut EsFileStore,
    pub name: *const ::std::os::raw::c_char,
    pub update: bool,
}
#[test]
fn bindgen_test_layout_EsMessageInstanceOpen() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageInstanceOpen>(),
        32usize,
        concat!("Size of: ", stringify!(EsMessageInstanceOpen))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageInstanceOpen>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageInstanceOpen))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageInstanceOpen>())).instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageInstanceOpen),
            "::",
            stringify!(instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageInstanceOpen>())).file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageInstanceOpen),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageInstanceOpen>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageInstanceOpen),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageInstanceOpen>())).update as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageInstanceOpen),
            "::",
            stringify!(update)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageInstanceSave {
    pub instance: *mut Instance,
    pub file: *mut EsFileStore,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_EsMessageInstanceSave() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageInstanceSave>(),
        24usize,
        concat!("Size of: ", stringify!(EsMessageInstanceSave))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageInstanceSave>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageInstanceSave))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageInstanceSave>())).instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageInstanceSave),
            "::",
            stringify!(instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageInstanceSave>())).file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageInstanceSave),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageInstanceSave>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageInstanceSave),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageInstanceDestroy {
    pub instance: *mut Instance,
}
#[test]
fn bindgen_test_layout_EsMessageInstanceDestroy() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageInstanceDestroy>(),
        8usize,
        concat!("Size of: ", stringify!(EsMessageInstanceDestroy))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageInstanceDestroy>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageInstanceDestroy))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessageInstanceDestroy>())).instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageInstanceDestroy),
            "::",
            stringify!(instance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageInstanceClose {
    pub instance: *mut Instance,
}
#[test]
fn bindgen_test_layout_EsMessageInstanceClose() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageInstanceClose>(),
        8usize,
        concat!("Size of: ", stringify!(EsMessageInstanceClose))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageInstanceClose>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageInstanceClose))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageInstanceClose>())).instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageInstanceClose),
            "::",
            stringify!(instance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageProcessCrash {
    pub reason: EsCrashReason,
    pub pid: usize,
}
#[test]
fn bindgen_test_layout_EsMessageProcessCrash() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageProcessCrash>(),
        16usize,
        concat!("Size of: ", stringify!(EsMessageProcessCrash))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageProcessCrash>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageProcessCrash))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageProcessCrash>())).reason as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageProcessCrash),
            "::",
            stringify!(reason)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageProcessCrash>())).pid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageProcessCrash),
            "::",
            stringify!(pid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageDesktop {
    pub windowID: EsObjectID,
    pub processID: EsObjectID,
    pub buffer: EsHandle,
    pub pipe: EsHandle,
    pub bytes: size_t,
}
#[test]
fn bindgen_test_layout_EsMessageDesktop() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageDesktop>(),
        40usize,
        concat!("Size of: ", stringify!(EsMessageDesktop))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageDesktop>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageDesktop))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageDesktop>())).windowID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageDesktop),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageDesktop>())).processID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageDesktop),
            "::",
            stringify!(processID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageDesktop>())).buffer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageDesktop),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageDesktop>())).pipe as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageDesktop),
            "::",
            stringify!(pipe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageDesktop>())).bytes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageDesktop),
            "::",
            stringify!(bytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageEyedrop {
    pub color: u32,
    pub cancelled: bool,
}
#[test]
fn bindgen_test_layout_EsMessageEyedrop() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageEyedrop>(),
        8usize,
        concat!("Size of: ", stringify!(EsMessageEyedrop))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageEyedrop>(),
        4usize,
        concat!("Alignment of ", stringify!(EsMessageEyedrop))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageEyedrop>())).color as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageEyedrop),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageEyedrop>())).cancelled as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageEyedrop),
            "::",
            stringify!(cancelled)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageCreateInstance {
    pub window: EsHandle,
    pub data: EsHandle,
    pub dataBytes: size_t,
}
#[test]
fn bindgen_test_layout_EsMessageCreateInstance() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageCreateInstance>(),
        24usize,
        concat!("Size of: ", stringify!(EsMessageCreateInstance))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageCreateInstance>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageCreateInstance))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageCreateInstance>())).window as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageCreateInstance),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageCreateInstance>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageCreateInstance),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessageCreateInstance>())).dataBytes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageCreateInstance),
            "::",
            stringify!(dataBytes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EsMessageTabOperation {
    pub id: EsObjectID,
    pub handle: EsHandle,
    pub __bindgen_anon_1: EsMessageTabOperation__bindgen_ty_1,
    pub error: EsError,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EsMessageTabOperation__bindgen_ty_1 {
    pub bytes: size_t,
    pub isSource: bool,
}
#[test]
fn bindgen_test_layout_EsMessageTabOperation__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageTabOperation__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(EsMessageTabOperation__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageTabOperation__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(EsMessageTabOperation__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessageTabOperation__bindgen_ty_1>())).bytes as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageTabOperation__bindgen_ty_1),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessageTabOperation__bindgen_ty_1>())).isSource as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageTabOperation__bindgen_ty_1),
            "::",
            stringify!(isSource)
        )
    );
}
#[test]
fn bindgen_test_layout_EsMessageTabOperation() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageTabOperation>(),
        32usize,
        concat!("Size of: ", stringify!(EsMessageTabOperation))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageTabOperation>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageTabOperation))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageTabOperation>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageTabOperation),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageTabOperation>())).handle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageTabOperation),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageTabOperation>())).error as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageTabOperation),
            "::",
            stringify!(error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageRegisterFileSystem {
    pub rootDirectory: EsHandle,
    pub isBootFileSystem: bool,
    pub mountPoint: *mut EsMountPoint,
}
#[test]
fn bindgen_test_layout_EsMessageRegisterFileSystem() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageRegisterFileSystem>(),
        24usize,
        concat!("Size of: ", stringify!(EsMessageRegisterFileSystem))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageRegisterFileSystem>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageRegisterFileSystem))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessageRegisterFileSystem>())).rootDirectory as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageRegisterFileSystem),
            "::",
            stringify!(rootDirectory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessageRegisterFileSystem>())).isBootFileSystem as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageRegisterFileSystem),
            "::",
            stringify!(isBootFileSystem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessageRegisterFileSystem>())).mountPoint as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageRegisterFileSystem),
            "::",
            stringify!(mountPoint)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageUnregisterFileSystem {
    pub id: EsObjectID,
    pub mountPoint: *mut EsMountPoint,
}
#[test]
fn bindgen_test_layout_EsMessageUnregisterFileSystem() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageUnregisterFileSystem>(),
        16usize,
        concat!("Size of: ", stringify!(EsMessageUnregisterFileSystem))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageUnregisterFileSystem>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageUnregisterFileSystem))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessageUnregisterFileSystem>())).id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageUnregisterFileSystem),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessageUnregisterFileSystem>())).mountPoint as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageUnregisterFileSystem),
            "::",
            stringify!(mountPoint)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessageDevice {
    pub id: EsObjectID,
    pub handle: EsHandle,
    pub type_: EsDeviceType,
}
#[test]
fn bindgen_test_layout_EsMessageDevice() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageDevice>(),
        24usize,
        concat!("Size of: ", stringify!(EsMessageDevice))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageDevice>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageDevice))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageDevice>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageDevice),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageDevice>())).handle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageDevice),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageDevice>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageDevice),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EsMessageUser {
    pub context1: EsGeneric,
    pub context2: EsGeneric,
    pub context3: EsGeneric,
    pub context4: EsGeneric,
}
#[test]
fn bindgen_test_layout_EsMessageUser() {
    assert_eq!(
        ::std::mem::size_of::<EsMessageUser>(),
        32usize,
        concat!("Size of: ", stringify!(EsMessageUser))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessageUser>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessageUser))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageUser>())).context1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageUser),
            "::",
            stringify!(context1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageUser>())).context2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageUser),
            "::",
            stringify!(context2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageUser>())).context3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageUser),
            "::",
            stringify!(context3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessageUser>())).context4 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessageUser),
            "::",
            stringify!(context4)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsStyle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsPainter {
    _unused: [u8; 0],
}
pub const EsCursorStyle_ES_CURSOR_NORMAL: EsCursorStyle = 0;
pub const EsCursorStyle_ES_CURSOR_TEXT: EsCursorStyle = 1;
pub const EsCursorStyle_ES_CURSOR_RESIZE_VERTICAL: EsCursorStyle = 2;
pub const EsCursorStyle_ES_CURSOR_RESIZE_HORIZONTAL: EsCursorStyle = 3;
pub const EsCursorStyle_ES_CURSOR_RESIZE_DIAGONAL_1: EsCursorStyle = 4;
pub const EsCursorStyle_ES_CURSOR_RESIZE_DIAGONAL_2: EsCursorStyle = 5;
pub const EsCursorStyle_ES_CURSOR_SPLIT_VERTICAL: EsCursorStyle = 6;
pub const EsCursorStyle_ES_CURSOR_SPLIT_HORIZONTAL: EsCursorStyle = 7;
pub const EsCursorStyle_ES_CURSOR_HAND_HOVER: EsCursorStyle = 8;
pub const EsCursorStyle_ES_CURSOR_HAND_DRAG: EsCursorStyle = 9;
pub const EsCursorStyle_ES_CURSOR_HAND_POINT: EsCursorStyle = 10;
pub const EsCursorStyle_ES_CURSOR_SCROLL_UP_LEFT: EsCursorStyle = 11;
pub const EsCursorStyle_ES_CURSOR_SCROLL_UP: EsCursorStyle = 12;
pub const EsCursorStyle_ES_CURSOR_SCROLL_UP_RIGHT: EsCursorStyle = 13;
pub const EsCursorStyle_ES_CURSOR_SCROLL_LEFT: EsCursorStyle = 14;
pub const EsCursorStyle_ES_CURSOR_SCROLL_CENTER: EsCursorStyle = 15;
pub const EsCursorStyle_ES_CURSOR_SCROLL_RIGHT: EsCursorStyle = 16;
pub const EsCursorStyle_ES_CURSOR_SCROLL_DOWN_LEFT: EsCursorStyle = 17;
pub const EsCursorStyle_ES_CURSOR_SCROLL_DOWN: EsCursorStyle = 18;
pub const EsCursorStyle_ES_CURSOR_SCROLL_DOWN_RIGHT: EsCursorStyle = 19;
pub const EsCursorStyle_ES_CURSOR_SELECT_LINES: EsCursorStyle = 20;
pub const EsCursorStyle_ES_CURSOR_DROP_TEXT: EsCursorStyle = 21;
pub const EsCursorStyle_ES_CURSOR_CROSS_HAIR_PICK: EsCursorStyle = 22;
pub const EsCursorStyle_ES_CURSOR_CROSS_HAIR_RESIZE: EsCursorStyle = 23;
pub const EsCursorStyle_ES_CURSOR_MOVE_HOVER: EsCursorStyle = 24;
pub const EsCursorStyle_ES_CURSOR_MOVE_DRAG: EsCursorStyle = 25;
pub const EsCursorStyle_ES_CURSOR_ROTATE_HOVER: EsCursorStyle = 26;
pub const EsCursorStyle_ES_CURSOR_ROTATE_DRAG: EsCursorStyle = 27;
pub const EsCursorStyle_ES_CURSOR_BLANK: EsCursorStyle = 28;
pub const EsCursorStyle_ES_CURSOR_COUNT: EsCursorStyle = 29;
pub type EsCursorStyle = ::std::os::raw::c_uint;
pub const EsCheckState_ES_CHECK_UNCHECKED: EsCheckState = 0;
pub const EsCheckState_ES_CHECK_CHECKED: EsCheckState = 1;
pub const EsCheckState_ES_CHECK_INDETERMINATE: EsCheckState = 2;
pub type EsCheckState = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EsMessage {
    pub type_: EsMessageType,
    pub __bindgen_anon_1: EsMessage__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EsMessage__bindgen_ty_1 {
    pub _size: EsMessage__bindgen_ty_1__bindgen_ty_1,
    pub user: EsMessageUser,
    pub mouseMoved: EsMessageMouseMotion,
    pub mouseDragged: EsMessageMouseMotion,
    pub mouseDown: EsMessageMouseButton,
    pub keyboard: EsMessageKeyboard,
    pub windowResized: EsMessageWindowResized,
    pub animate: EsMessageAnimate,
    pub layout: EsMessageLayout,
    pub measure: EsMessageMeasure,
    pub hitTest: EsMessageHitTest,
    pub zOrder: EsMessageZOrder,
    pub beforeZOrder: EsMessageBeforeZOrder,
    pub itemToString: EsMessageItemToString,
    pub focus: EsMessageFocus,
    pub scrollWheel: EsMessageScrollWheel,
    pub windowActivated: EsMessageWindowActivated,
    pub childStyleVariant: *const EsStyle,
    pub accessKeyHintBounds: *mut EsRectangle,
    pub painter: *mut EsPainter,
    pub child: *mut EsElement,
    pub cursorStyle: EsCursorStyle,
    pub iterateIndex: EsMessageIterateIndex,
    pub itemRange: EsMessageItemRange,
    pub measureItem: EsMessageMeasureItem,
    pub createItem: EsMessageCreateItem,
    pub getContent: EsMessageGetContent,
    pub getIndent: EsMessageGetIndent,
    pub selectRange: EsMessageSelectRange,
    pub selectItem: EsMessageSelectItem,
    pub chooseItem: EsMessageChooseItem,
    pub searchItem: EsMessageSearchItem,
    pub columnMenu: EsMessageColumnMenu,
    pub getColumnSort: EsMessageGetColumnSort,
    pub scrollbarMoved: EsMessageScrollbarMoved,
    pub sliderMoved: EsMessageSliderMoved,
    pub colorChanged: EsMessageColorChanged,
    pub numberDragDelta: EsMessageNumberDragDelta,
    pub numberUpdated: EsMessageNumberUpdated,
    pub getBreadcrumb: EsMessageGetBreadcrumb,
    pub endEdit: EsMessageEndEdit,
    pub activateBreadcrumb: usize,
    pub checkState: EsCheckState,
    pub instanceOpen: EsMessageInstanceOpen,
    pub instanceSave: EsMessageInstanceSave,
    pub instanceDestroy: EsMessageInstanceDestroy,
    pub instanceClose: EsMessageInstanceClose,
    pub _argument: *mut ::std::os::raw::c_void,
    pub crash: EsMessageProcessCrash,
    pub desktop: EsMessageDesktop,
    pub eyedrop: EsMessageEyedrop,
    pub createInstance: EsMessageCreateInstance,
    pub tabOperation: EsMessageTabOperation,
    pub registerFileSystem: EsMessageRegisterFileSystem,
    pub unregisterFileSystem: EsMessageUnregisterFileSystem,
    pub device: EsMessageDevice,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsMessage__bindgen_ty_1__bindgen_ty_1 {
    pub _size: [usize; 4usize],
}
#[test]
fn bindgen_test_layout_EsMessage__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<EsMessage__bindgen_ty_1__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(EsMessage__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessage__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(EsMessage__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1__bindgen_ty_1>()))._size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_size)
        )
    );
}
#[test]
fn bindgen_test_layout_EsMessage__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<EsMessage__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(EsMessage__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessage__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessage__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>()))._size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).user as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).mouseMoved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(mouseMoved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).mouseDragged as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(mouseDragged)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).mouseDown as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(mouseDown)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).keyboard as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(keyboard)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).windowResized as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(windowResized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).animate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(animate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).layout as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).measure as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(measure)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).hitTest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(hitTest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).zOrder as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(zOrder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).beforeZOrder as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(beforeZOrder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).itemToString as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(itemToString)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).focus as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(focus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).scrollWheel as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(scrollWheel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).windowActivated as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(windowActivated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).childStyleVariant as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(childStyleVariant)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).accessKeyHintBounds as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(accessKeyHintBounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).painter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(painter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).child as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).cursorStyle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(cursorStyle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).iterateIndex as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(iterateIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).itemRange as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(itemRange)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).measureItem as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(measureItem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).createItem as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(createItem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).getContent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(getContent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).getIndent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(getIndent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).selectRange as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(selectRange)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).selectItem as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(selectItem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).chooseItem as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(chooseItem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).searchItem as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(searchItem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).columnMenu as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(columnMenu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).getColumnSort as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(getColumnSort)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).scrollbarMoved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(scrollbarMoved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).sliderMoved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(sliderMoved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).colorChanged as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(colorChanged)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).numberDragDelta as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(numberDragDelta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).numberUpdated as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(numberUpdated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).getBreadcrumb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(getBreadcrumb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).endEdit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(endEdit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).activateBreadcrumb as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(activateBreadcrumb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).checkState as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(checkState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).instanceOpen as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(instanceOpen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).instanceSave as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(instanceSave)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).instanceDestroy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(instanceDestroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).instanceClose as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(instanceClose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>()))._argument as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(_argument)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).crash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(crash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).desktop as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(desktop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).eyedrop as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(eyedrop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).createInstance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(createInstance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).tabOperation as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(tabOperation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).registerFileSystem as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(registerFileSystem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).unregisterFileSystem as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(unregisterFileSystem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessage__bindgen_ty_1>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage__bindgen_ty_1),
            "::",
            stringify!(device)
        )
    );
}
#[test]
fn bindgen_test_layout_EsMessage() {
    assert_eq!(
        ::std::mem::size_of::<EsMessage>(),
        48usize,
        concat!("Size of: ", stringify!(EsMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<EsMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(EsMessage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsMessage>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsMessage),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EsMessageWithObject {
    pub object: *mut ::std::os::raw::c_void,
    pub message: EsMessage,
}
#[test]
fn bindgen_test_layout__EsMessageWithObject() {
    assert_eq!(
        ::std::mem::size_of::<_EsMessageWithObject>(),
        56usize,
        concat!("Size of: ", stringify!(_EsMessageWithObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_EsMessageWithObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_EsMessageWithObject))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EsMessageWithObject>())).object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EsMessageWithObject),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EsMessageWithObject>())).message as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_EsMessageWithObject),
            "::",
            stringify!(message)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MessageQueue {
    pub messages: u64,
    pub mouseMovedMessage: usize,
    pub windowResizedMessage: usize,
    pub eyedropResultMessage: usize,
    pub keyRepeatMessage: usize,
    pub pinged: bool,
    pub mutex: KMutex,
    pub notEmpty: KEvent,
}
#[test]
fn bindgen_test_layout_MessageQueue() {
    assert_eq!(
        ::std::mem::size_of::<MessageQueue>(),
        128usize,
        concat!("Size of: ", stringify!(MessageQueue))
    );
    assert_eq!(
        ::std::mem::align_of::<MessageQueue>(),
        8usize,
        concat!("Alignment of ", stringify!(MessageQueue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MessageQueue>())).messages as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MessageQueue),
            "::",
            stringify!(messages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MessageQueue>())).mouseMovedMessage as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MessageQueue),
            "::",
            stringify!(mouseMovedMessage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MessageQueue>())).windowResizedMessage as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MessageQueue),
            "::",
            stringify!(windowResizedMessage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MessageQueue>())).eyedropResultMessage as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MessageQueue),
            "::",
            stringify!(eyedropResultMessage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MessageQueue>())).keyRepeatMessage as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MessageQueue),
            "::",
            stringify!(keyRepeatMessage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MessageQueue>())).pinged as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MessageQueue),
            "::",
            stringify!(pinged)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MessageQueue>())).mutex as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MessageQueue),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MessageQueue>())).notEmpty as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MessageQueue),
            "::",
            stringify!(notEmpty)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12MessageQueue11SendMessageEPvP9EsMessage"]
    pub fn MessageQueue_SendMessage(
        this: *mut MessageQueue,
        target: *mut ::std::os::raw::c_void,
        message: *mut EsMessage,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12MessageQueue11SendMessageEP20_EsMessageWithObject"]
    pub fn MessageQueue_SendMessage1(
        this: *mut MessageQueue,
        message: *mut _EsMessageWithObject,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12MessageQueue10GetMessageEP20_EsMessageWithObject"]
    pub fn MessageQueue_GetMessage(
        this: *mut MessageQueue,
        message: *mut _EsMessageWithObject,
    ) -> bool;
}
impl MessageQueue {
    #[inline]
    pub unsafe fn SendMessage(
        &mut self,
        target: *mut ::std::os::raw::c_void,
        message: *mut EsMessage,
    ) -> bool {
        MessageQueue_SendMessage(self, target, message)
    }
    #[inline]
    pub unsafe fn SendMessage1(&mut self, message: *mut _EsMessageWithObject) -> bool {
        MessageQueue_SendMessage1(self, message)
    }
    #[inline]
    pub unsafe fn GetMessage(&mut self, message: *mut _EsMessageWithObject) -> bool {
        MessageQueue_GetMessage(self, message)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Handle {
    pub object: *mut ::std::os::raw::c_void,
    pub flags: u32,
    pub type_: KernelObjectType,
}
#[test]
fn bindgen_test_layout_Handle() {
    assert_eq!(
        ::std::mem::size_of::<Handle>(),
        16usize,
        concat!("Size of: ", stringify!(Handle))
    );
    assert_eq!(
        ::std::mem::align_of::<Handle>(),
        8usize,
        concat!("Alignment of ", stringify!(Handle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Handle>())).object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Handle),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Handle>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Handle),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Handle>())).type_ as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Handle),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    pub static mut totalHandleCount: u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HandleTableL2 {
    pub t: [Handle; 256usize],
}
#[test]
fn bindgen_test_layout_HandleTableL2() {
    assert_eq!(
        ::std::mem::size_of::<HandleTableL2>(),
        4096usize,
        concat!("Size of: ", stringify!(HandleTableL2))
    );
    assert_eq!(
        ::std::mem::align_of::<HandleTableL2>(),
        8usize,
        concat!("Alignment of ", stringify!(HandleTableL2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HandleTableL2>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HandleTableL2),
            "::",
            stringify!(t)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HandleTableL1 {
    pub t: [*mut HandleTableL2; 256usize],
    pub u: [u16; 256usize],
}
#[test]
fn bindgen_test_layout_HandleTableL1() {
    assert_eq!(
        ::std::mem::size_of::<HandleTableL1>(),
        2560usize,
        concat!("Size of: ", stringify!(HandleTableL1))
    );
    assert_eq!(
        ::std::mem::align_of::<HandleTableL1>(),
        8usize,
        concat!("Alignment of ", stringify!(HandleTableL1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HandleTableL1>())).t as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HandleTableL1),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HandleTableL1>())).u as *const _ as usize },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(HandleTableL1),
            "::",
            stringify!(u)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HandleTable {
    pub l1r: HandleTableL1,
    pub lock: KMutex,
    pub process: *mut Process,
    pub destroyed: bool,
    pub handleCount: u32,
}
#[test]
fn bindgen_test_layout_HandleTable() {
    assert_eq!(
        ::std::mem::size_of::<HandleTable>(),
        2608usize,
        concat!("Size of: ", stringify!(HandleTable))
    );
    assert_eq!(
        ::std::mem::align_of::<HandleTable>(),
        8usize,
        concat!("Alignment of ", stringify!(HandleTable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HandleTable>())).l1r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HandleTable),
            "::",
            stringify!(l1r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HandleTable>())).lock as *const _ as usize },
        2560usize,
        concat!(
            "Offset of field: ",
            stringify!(HandleTable),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HandleTable>())).process as *const _ as usize },
        2592usize,
        concat!(
            "Offset of field: ",
            stringify!(HandleTable),
            "::",
            stringify!(process)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HandleTable>())).destroyed as *const _ as usize },
        2600usize,
        concat!(
            "Offset of field: ",
            stringify!(HandleTable),
            "::",
            stringify!(destroyed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HandleTable>())).handleCount as *const _ as usize },
        2604usize,
        concat!(
            "Offset of field: ",
            stringify!(HandleTable),
            "::",
            stringify!(handleCount)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11HandleTable10OpenHandleEPvj16KernelObjectTypem"]
    pub fn HandleTable_OpenHandle(
        this: *mut HandleTable,
        _object: *mut ::std::os::raw::c_void,
        _flags: u32,
        _type: KernelObjectType,
        at: EsHandle,
    ) -> EsHandle;
}
extern "C" {
    #[link_name = "\u{1}_ZN11HandleTable11CloseHandleEm"]
    pub fn HandleTable_CloseHandle(this: *mut HandleTable, handle: EsHandle) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11HandleTable11ModifyFlagsEmj"]
    pub fn HandleTable_ModifyFlags(this: *mut HandleTable, handle: EsHandle, newFlags: u32);
}
extern "C" {
    #[link_name = "\u{1}_ZN11HandleTable13ResolveHandleEP6Handlem16KernelObjectType"]
    pub fn HandleTable_ResolveHandle(
        this: *mut HandleTable,
        outHandle: *mut Handle,
        inHandle: EsHandle,
        typeMask: KernelObjectType,
    ) -> u8;
}
impl HandleTable {
    #[inline]
    pub unsafe fn OpenHandle(
        &mut self,
        _object: *mut ::std::os::raw::c_void,
        _flags: u32,
        _type: KernelObjectType,
        at: EsHandle,
    ) -> EsHandle {
        HandleTable_OpenHandle(self, _object, _flags, _type, at)
    }
    #[inline]
    pub unsafe fn CloseHandle(&mut self, handle: EsHandle) -> bool {
        HandleTable_CloseHandle(self, handle)
    }
    #[inline]
    pub unsafe fn ModifyFlags(&mut self, handle: EsHandle, newFlags: u32) {
        HandleTable_ModifyFlags(self, handle, newFlags)
    }
    #[inline]
    pub unsafe fn ResolveHandle(
        &mut self,
        outHandle: *mut Handle,
        inHandle: EsHandle,
        typeMask: KernelObjectType,
    ) -> u8 {
        HandleTable_ResolveHandle(self, outHandle, inHandle, typeMask)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Process {
    pub vmm: *mut MMSpace,
    pub messageQueue: MessageQueue,
    pub handleTable: HandleTable,
    pub threads: LinkedList<Thread>,
    pub threadsMutex: KMutex,
    pub executableNode: *mut KNode,
    pub cExecutableName: [::std::os::raw::c_char; 32usize],
    pub data: EsProcessCreateData,
    pub permissions: u64,
    pub creationFlags: u32,
    pub type_: ProcessType,
    pub id: EsObjectID,
    pub handles: size_t,
    pub allItem: LinkedItem<Process>,
    pub crashMutex: KMutex,
    pub crashReason: EsCrashReason,
    pub crashed: bool,
    pub allThreadsTerminated: bool,
    pub blockShutdown: bool,
    pub preventNewThreads: bool,
    pub exitStatus: ::std::os::raw::c_int,
    pub killedEvent: KEvent,
    pub executableState: u8,
    pub executableStartRequest: bool,
    pub executableLoadAttemptComplete: KEvent,
    pub executableMainThread: *mut Thread,
    pub cpuTimeSlices: usize,
    pub idleTimeSlices: usize,
}
#[test]
fn bindgen_test_layout_Process() {
    assert_eq!(
        ::std::mem::size_of::<Process>(),
        3104usize,
        concat!("Size of: ", stringify!(Process))
    );
    assert_eq!(
        ::std::mem::align_of::<Process>(),
        8usize,
        concat!("Alignment of ", stringify!(Process))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).vmm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(vmm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).messageQueue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(messageQueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).handleTable as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(handleTable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).threads as *const _ as usize },
        2744usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(threads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).threadsMutex as *const _ as usize },
        2768usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(threadsMutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).executableNode as *const _ as usize },
        2800usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(executableNode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).cExecutableName as *const _ as usize },
        2808usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(cExecutableName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).data as *const _ as usize },
        2840usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).permissions as *const _ as usize },
        2864usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(permissions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).creationFlags as *const _ as usize },
        2872usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(creationFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).type_ as *const _ as usize },
        2876usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).id as *const _ as usize },
        2880usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).handles as *const _ as usize },
        2888usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).allItem as *const _ as usize },
        2896usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(allItem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).crashMutex as *const _ as usize },
        2928usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(crashMutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).crashReason as *const _ as usize },
        2960usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(crashReason)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).crashed as *const _ as usize },
        2968usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(crashed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).allThreadsTerminated as *const _ as usize },
        2969usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(allThreadsTerminated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).blockShutdown as *const _ as usize },
        2970usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(blockShutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).preventNewThreads as *const _ as usize },
        2971usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(preventNewThreads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).exitStatus as *const _ as usize },
        2972usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(exitStatus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).killedEvent as *const _ as usize },
        2976usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(killedEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).executableState as *const _ as usize },
        3024usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(executableState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).executableStartRequest as *const _ as usize },
        3025usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(executableStartRequest)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Process>())).executableLoadAttemptComplete as *const _ as usize
        },
        3032usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(executableLoadAttemptComplete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).executableMainThread as *const _ as usize },
        3080usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(executableMainThread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).cpuTimeSlices as *const _ as usize },
        3088usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(cpuTimeSlices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Process>())).idleTimeSlices as *const _ as usize },
        3096usize,
        concat!(
            "Offset of field: ",
            stringify!(Process),
            "::",
            stringify!(idleTimeSlices)
        )
    );
}
extern "C" {
    pub static mut _kernelProcess: Process;
}
extern "C" {
    pub static mut _desktopProcess: Process;
}
extern "C" {
    pub static mut kernelProcess: *mut Process;
}
extern "C" {
    pub static mut desktopProcess: *mut Process;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct KTimer {
    pub event: KEvent,
    pub asyncTask: KAsyncTask,
    pub item: LinkedItem<KTimer>,
    pub triggerTimeMs: u64,
    pub callback: KAsyncTaskCallback,
    pub argument: EsGeneric,
}
#[test]
fn bindgen_test_layout_KTimer() {
    assert_eq!(
        ::std::mem::size_of::<KTimer>(),
        128usize,
        concat!("Size of: ", stringify!(KTimer))
    );
    assert_eq!(
        ::std::mem::align_of::<KTimer>(),
        8usize,
        concat!("Alignment of ", stringify!(KTimer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KTimer>())).event as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KTimer),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KTimer>())).asyncTask as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(KTimer),
            "::",
            stringify!(asyncTask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KTimer>())).item as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(KTimer),
            "::",
            stringify!(item)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KTimer>())).triggerTimeMs as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(KTimer),
            "::",
            stringify!(triggerTimeMs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KTimer>())).callback as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(KTimer),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KTimer>())).argument as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(KTimer),
            "::",
            stringify!(argument)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_Z9KTimerSetP6KTimermPFvP10KAsyncTaskE9EsGeneric"]
    pub fn KTimerSet(
        timer: *mut KTimer,
        triggerInMs: u64,
        callback: KAsyncTaskCallback,
        argument: EsGeneric,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z12KTimerRemoveP6KTimer"]
    pub fn KTimerRemove(timer: *mut KTimer);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Scheduler {
    pub dispatchSpinlock: KSpinlock,
    pub activeTimersSpinlock: KSpinlock,
    pub activeThreads: [LinkedList<Thread>; 2usize],
    pub pausedThreads: LinkedList<Thread>,
    pub activeTimers: LinkedList<KTimer>,
    pub allThreadsMutex: KMutex,
    pub allProcessesMutex: KMutex,
    pub asyncTaskSpinlock: KSpinlock,
    pub allThreads: LinkedList<Thread>,
    pub allProcesses: LinkedList<Process>,
    pub threadPool: Pool,
    pub processPool: Pool,
    pub mmSpacePool: Pool,
    pub nextThreadID: EsObjectID,
    pub nextProcessID: EsObjectID,
    pub nextProcessorID: EsObjectID,
    pub allProcessesTerminatedEvent: KEvent,
    pub blockShutdownProcessCount: usize,
    pub activeProcessCount: size_t,
    pub started: bool,
    pub panic: bool,
    pub shutdown: bool,
    pub timeMs: u64,
}
#[test]
fn bindgen_test_layout_Scheduler() {
    assert_eq!(
        ::std::mem::size_of::<Scheduler>(),
        856usize,
        concat!("Size of: ", stringify!(Scheduler))
    );
    assert_eq!(
        ::std::mem::align_of::<Scheduler>(),
        8usize,
        concat!("Alignment of ", stringify!(Scheduler))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scheduler>())).dispatchSpinlock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(dispatchSpinlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scheduler>())).activeTimersSpinlock as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(activeTimersSpinlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scheduler>())).activeThreads as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(activeThreads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scheduler>())).pausedThreads as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(pausedThreads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scheduler>())).activeTimers as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(activeTimers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scheduler>())).allThreadsMutex as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(allThreadsMutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scheduler>())).allProcessesMutex as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(allProcessesMutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scheduler>())).asyncTaskSpinlock as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(asyncTaskSpinlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scheduler>())).allThreads as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(allThreads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scheduler>())).allProcesses as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(allProcesses)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scheduler>())).threadPool as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(threadPool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scheduler>())).processPool as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(processPool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scheduler>())).mmSpacePool as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(mmSpacePool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scheduler>())).nextThreadID as *const _ as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(nextThreadID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scheduler>())).nextProcessID as *const _ as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(nextProcessID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scheduler>())).nextProcessorID as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(nextProcessorID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Scheduler>())).allProcessesTerminatedEvent as *const _ as usize
        },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(allProcessesTerminatedEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Scheduler>())).blockShutdownProcessCount as *const _ as usize
        },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(blockShutdownProcessCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scheduler>())).activeProcessCount as *const _ as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(activeProcessCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scheduler>())).started as *const _ as usize },
        840usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(started)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scheduler>())).panic as *const _ as usize },
        841usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(panic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scheduler>())).shutdown as *const _ as usize },
        842usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scheduler>())).timeMs as *const _ as usize },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(Scheduler),
            "::",
            stringify!(timeMs)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9Scheduler5YieldEP16InterruptContext"]
    pub fn Scheduler_Yield(this: *mut Scheduler, context: *mut InterruptContext);
}
extern "C" {
    #[link_name = "\u{1}_ZN9Scheduler22CreateProcessorThreadsEP15CPULocalStorage"]
    pub fn Scheduler_CreateProcessorThreads(this: *mut Scheduler, local: *mut CPULocalStorage);
}
extern "C" {
    #[link_name = "\u{1}_ZN9Scheduler21MaybeUpdateActiveListEP6Thread"]
    pub fn Scheduler_MaybeUpdateActiveList(this: *mut Scheduler, thread: *mut Thread);
}
extern "C" {
    #[link_name = "\u{1}_ZN9Scheduler10PickThreadEP15CPULocalStorage"]
    pub fn Scheduler_PickThread(this: *mut Scheduler, local: *mut CPULocalStorage) -> *mut Thread;
}
extern "C" {
    #[link_name = "\u{1}_ZN9Scheduler26GetThreadEffectivePriorityEP6Thread"]
    pub fn Scheduler_GetThreadEffectivePriority(this: *mut Scheduler, thread: *mut Thread) -> i8;
}
impl Scheduler {
    #[inline]
    pub unsafe fn Yield(&mut self, context: *mut InterruptContext) {
        Scheduler_Yield(self, context)
    }
    #[inline]
    pub unsafe fn CreateProcessorThreads(&mut self, local: *mut CPULocalStorage) {
        Scheduler_CreateProcessorThreads(self, local)
    }
    #[inline]
    pub unsafe fn MaybeUpdateActiveList(&mut self, thread: *mut Thread) {
        Scheduler_MaybeUpdateActiveList(self, thread)
    }
    #[inline]
    pub unsafe fn PickThread(&mut self, local: *mut CPULocalStorage) -> *mut Thread {
        Scheduler_PickThread(self, local)
    }
    #[inline]
    pub unsafe fn GetThreadEffectivePriority(&mut self, thread: *mut Thread) -> i8 {
        Scheduler_GetThreadEffectivePriority(self, thread)
    }
}
extern "C" {
    pub static mut scheduler: Scheduler;
}
extern "C" {
    #[link_name = "\u{1}_Z18KEventWaitMultiplePP6KEventm"]
    pub fn KEventWaitMultiple(events: *mut *mut KEvent, count: size_t) -> usize;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MMArchVAS {
    pub cr3: usize,
    pub l1Commit: *mut u8,
    pub l1CommitCommit: [u8; 256usize],
    pub l2Commit: [u8; 16384usize],
    pub l3Commit: [u8; 32usize],
    pub pageTablesCommitted: size_t,
    pub pageTablesActive: size_t,
    pub mutex: KMutex,
}
#[test]
fn bindgen_test_layout_MMArchVAS() {
    assert_eq!(
        ::std::mem::size_of::<MMArchVAS>(),
        16736usize,
        concat!("Size of: ", stringify!(MMArchVAS))
    );
    assert_eq!(
        ::std::mem::align_of::<MMArchVAS>(),
        8usize,
        concat!("Alignment of ", stringify!(MMArchVAS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMArchVAS>())).cr3 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMArchVAS),
            "::",
            stringify!(cr3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMArchVAS>())).l1Commit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMArchVAS),
            "::",
            stringify!(l1Commit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMArchVAS>())).l1CommitCommit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMArchVAS),
            "::",
            stringify!(l1CommitCommit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMArchVAS>())).l2Commit as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(MMArchVAS),
            "::",
            stringify!(l2Commit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMArchVAS>())).l3Commit as *const _ as usize },
        16656usize,
        concat!(
            "Offset of field: ",
            stringify!(MMArchVAS),
            "::",
            stringify!(l3Commit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMArchVAS>())).pageTablesCommitted as *const _ as usize },
        16688usize,
        concat!(
            "Offset of field: ",
            stringify!(MMArchVAS),
            "::",
            stringify!(pageTablesCommitted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMArchVAS>())).pageTablesActive as *const _ as usize },
        16696usize,
        concat!(
            "Offset of field: ",
            stringify!(MMArchVAS),
            "::",
            stringify!(pageTablesActive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMArchVAS>())).mutex as *const _ as usize },
        16704usize,
        concat!(
            "Offset of field: ",
            stringify!(MMArchVAS),
            "::",
            stringify!(mutex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GlobalData {
    pub clickChainTimeoutMs: i32,
    pub uiScale: f32,
    pub swapLeftAndRightButtons: bool,
    pub showCursorShadow: bool,
    pub useSmartQuotes: bool,
    pub enableHoverState: bool,
    pub animationTimeMultiplier: f32,
    pub schedulerTimeMs: u64,
    pub schedulerTimeOffset: u64,
    pub keyboardLayout: u16,
}
#[test]
fn bindgen_test_layout_GlobalData() {
    assert_eq!(
        ::std::mem::size_of::<GlobalData>(),
        40usize,
        concat!("Size of: ", stringify!(GlobalData))
    );
    assert_eq!(
        ::std::mem::align_of::<GlobalData>(),
        8usize,
        concat!("Alignment of ", stringify!(GlobalData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GlobalData>())).clickChainTimeoutMs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalData),
            "::",
            stringify!(clickChainTimeoutMs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GlobalData>())).uiScale as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalData),
            "::",
            stringify!(uiScale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GlobalData>())).swapLeftAndRightButtons as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalData),
            "::",
            stringify!(swapLeftAndRightButtons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GlobalData>())).showCursorShadow as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalData),
            "::",
            stringify!(showCursorShadow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GlobalData>())).useSmartQuotes as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalData),
            "::",
            stringify!(useSmartQuotes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GlobalData>())).enableHoverState as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalData),
            "::",
            stringify!(enableHoverState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GlobalData>())).animationTimeMultiplier as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalData),
            "::",
            stringify!(animationTimeMultiplier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GlobalData>())).schedulerTimeMs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalData),
            "::",
            stringify!(schedulerTimeMs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GlobalData>())).schedulerTimeOffset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalData),
            "::",
            stringify!(schedulerTimeOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GlobalData>())).keyboardLayout as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalData),
            "::",
            stringify!(keyboardLayout)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MMRegion {
    pub baseAddress: usize,
    pub pageCount: size_t,
    pub flags: u32,
    pub data: MMRegion__bindgen_ty_1,
    pub __bindgen_anon_1: MMRegion__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MMRegion__bindgen_ty_1 {
    pub __bindgen_anon_1: MMRegion__bindgen_ty_1__bindgen_ty_1,
    pub pin: KWriterLock,
    pub mapMutex: KMutex,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MMRegion__bindgen_ty_1__bindgen_ty_1 {
    pub physical: MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub shared: MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    pub file: MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3,
    pub normal: MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub offset: usize,
}
#[test]
fn bindgen_test_layout_MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).offset
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub region: *mut MMSharedRegion,
    pub offset: usize,
}
#[test]
fn bindgen_test_layout_MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>())).region
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(region)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>())).offset
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3 {
    pub node: *mut FSFile,
    pub offset: EsFileOffset,
    pub zeroedBytes: size_t,
    pub fileHandleFlags: u64,
}
#[test]
fn bindgen_test_layout_MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3>())).node
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3>())).offset
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3>()))
                .zeroedBytes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(zeroedBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3>()))
                .fileHandleFlags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(fileHandleFlags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4 {
    pub commit: RangeSet,
    pub commitPageCount: size_t,
    pub guardBefore: *mut MMRegion,
    pub guardAfter: *mut MMRegion,
}
#[test]
fn bindgen_test_layout_MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4>())).commit
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(commit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4>()))
                .commitPageCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(commitPageCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4>()))
                .guardBefore as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(guardBefore)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4>()))
                .guardAfter as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(guardAfter)
        )
    );
}
#[test]
fn bindgen_test_layout_MMRegion__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MMRegion__bindgen_ty_1__bindgen_ty_1>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMRegion__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMRegion__bindgen_ty_1__bindgen_ty_1>())).physical as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(physical)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMRegion__bindgen_ty_1__bindgen_ty_1>())).shared as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMRegion__bindgen_ty_1__bindgen_ty_1>())).file as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMRegion__bindgen_ty_1__bindgen_ty_1>())).normal as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(normal)
        )
    );
}
#[test]
fn bindgen_test_layout_MMRegion__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MMRegion__bindgen_ty_1>(),
        104usize,
        concat!("Size of: ", stringify!(MMRegion__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<MMRegion__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(MMRegion__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMRegion__bindgen_ty_1>())).pin as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion__bindgen_ty_1),
            "::",
            stringify!(pin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMRegion__bindgen_ty_1>())).mapMutex as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion__bindgen_ty_1),
            "::",
            stringify!(mapMutex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MMRegion__bindgen_ty_2 {
    pub __bindgen_anon_1: MMRegion__bindgen_ty_2__bindgen_ty_1,
    pub core: MMRegion__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MMRegion__bindgen_ty_2__bindgen_ty_1 {
    pub itemBase: AVLItem<MMRegion>,
    pub __bindgen_anon_1: MMRegion__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MMRegion__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub itemSize: AVLItem<MMRegion>,
    pub itemNonGuard: LinkedItem<MMRegion>,
}
#[test]
fn bindgen_test_layout_MMRegion__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MMRegion__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(MMRegion__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMRegion__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MMRegion__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMRegion__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>())).itemSize
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(itemSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMRegion__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>()))
                .itemNonGuard as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(itemNonGuard)
        )
    );
}
#[test]
fn bindgen_test_layout_MMRegion__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MMRegion__bindgen_ty_2__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(MMRegion__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMRegion__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MMRegion__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMRegion__bindgen_ty_2__bindgen_ty_1>())).itemBase as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(itemBase)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMRegion__bindgen_ty_2__bindgen_ty_2 {
    pub used: bool,
}
#[test]
fn bindgen_test_layout_MMRegion__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<MMRegion__bindgen_ty_2__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(MMRegion__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMRegion__bindgen_ty_2__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(MMRegion__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMRegion__bindgen_ty_2__bindgen_ty_2>())).used as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(used)
        )
    );
}
#[test]
fn bindgen_test_layout_MMRegion__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<MMRegion__bindgen_ty_2>(),
        128usize,
        concat!("Size of: ", stringify!(MMRegion__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<MMRegion__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(MMRegion__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMRegion__bindgen_ty_2>())).core as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion__bindgen_ty_2),
            "::",
            stringify!(core)
        )
    );
}
#[test]
fn bindgen_test_layout_MMRegion() {
    assert_eq!(
        ::std::mem::size_of::<MMRegion>(),
        256usize,
        concat!("Size of: ", stringify!(MMRegion))
    );
    assert_eq!(
        ::std::mem::align_of::<MMRegion>(),
        8usize,
        concat!("Alignment of ", stringify!(MMRegion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMRegion>())).baseAddress as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion),
            "::",
            stringify!(baseAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMRegion>())).pageCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion),
            "::",
            stringify!(pageCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMRegion>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMRegion>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMRegion),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_Z18MMFindAndPinRegionP7MMSpacemm"]
    pub fn MMFindAndPinRegion(space: *mut MMSpace, address: usize, size: usize) -> *mut MMRegion;
}
extern "C" {
    #[link_name = "\u{1}_Z13MMCommitRangeP7MMSpaceP8MMRegionmm"]
    pub fn MMCommitRange(
        space: *mut MMSpace,
        region: *mut MMRegion,
        pageOffset: usize,
        pageCount: size_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z13MMUnpinRegionP7MMSpaceP8MMRegion"]
    pub fn MMUnpinRegion(space: *mut MMSpace, region: *mut MMRegion);
}
extern "C" {
    #[link_name = "\u{1}_Z23KWriterLockTakeMultiplePP11KWriterLockmb"]
    pub fn KWriterLockTakeMultiple(locks: *mut *mut KWriterLock, lockCount: size_t, write: bool);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MMSharedRegion {
    pub sizeBytes: size_t,
    pub handles: size_t,
    pub mutex: KMutex,
    pub namedItem: LinkedItem<MMSharedRegion>,
    pub cName: [::std::os::raw::c_char; 33usize],
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MMSharedRegion() {
    assert_eq!(
        ::std::mem::size_of::<MMSharedRegion>(),
        128usize,
        concat!("Size of: ", stringify!(MMSharedRegion))
    );
    assert_eq!(
        ::std::mem::align_of::<MMSharedRegion>(),
        8usize,
        concat!("Alignment of ", stringify!(MMSharedRegion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMSharedRegion>())).sizeBytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMSharedRegion),
            "::",
            stringify!(sizeBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMSharedRegion>())).handles as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMSharedRegion),
            "::",
            stringify!(handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMSharedRegion>())).mutex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMSharedRegion),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMSharedRegion>())).namedItem as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MMSharedRegion),
            "::",
            stringify!(namedItem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMSharedRegion>())).cName as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MMSharedRegion),
            "::",
            stringify!(cName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMSharedRegion>())).data as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(MMSharedRegion),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_Z18OpenHandleToObjectPv16KernelObjectTypej"]
    pub fn OpenHandleToObject(
        object: *mut ::std::os::raw::c_void,
        type_: KernelObjectType,
        flags: u32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z11ThreadSpawnPKcmmjP7Processm"]
    pub fn ThreadSpawn(
        cName: *const ::std::os::raw::c_char,
        startAddress: usize,
        argument1: usize,
        flags: u32,
        process: *mut Process,
        argument2: usize,
    ) -> *mut Thread;
}
extern "C" {
    #[link_name = "\u{1}_Z13KThreadCreatePKcPFvmEm"]
    pub fn KThreadCreate(
        cName: *const ::std::os::raw::c_char,
        startAddress: ::std::option::Option<unsafe extern "C" fn(arg1: usize)>,
        argument: usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z12ProcessSpawn11ProcessType"]
    pub fn ProcessSpawn(processType: ProcessType) -> *mut Process;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MMPageFrame {
    pub state: MMPageFrame__bindgen_ty_1,
    pub flags: u8,
    pub cacheReference: *mut usize,
    pub __bindgen_anon_1: MMPageFrame__bindgen_ty_2,
}
pub const MMPageFrame_UNUSABLE: u8 = 0;
pub const MMPageFrame_BAD: u8 = 1;
pub const MMPageFrame_ZEROED: u8 = 2;
pub const MMPageFrame_FREE: u8 = 3;
pub const MMPageFrame_STANDBY: u8 = 4;
pub const MMPageFrame_ACTIVE: u8 = 5;
pub type MMPageFrame__bindgen_ty_1 = u8;
#[repr(C)]
#[derive(Copy, Clone)]
pub union MMPageFrame__bindgen_ty_2 {
    pub list: MMPageFrame__bindgen_ty_2__bindgen_ty_1,
    pub active: MMPageFrame__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMPageFrame__bindgen_ty_2__bindgen_ty_1 {
    pub next: usize,
    pub previous: *mut usize,
}
#[test]
fn bindgen_test_layout_MMPageFrame__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MMPageFrame__bindgen_ty_2__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(MMPageFrame__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMPageFrame__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MMPageFrame__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMPageFrame__bindgen_ty_2__bindgen_ty_1>())).next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMPageFrame__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMPageFrame__bindgen_ty_2__bindgen_ty_1>())).previous as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMPageFrame__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(previous)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MMPageFrame__bindgen_ty_2__bindgen_ty_2 {
    pub references: usize,
}
#[test]
fn bindgen_test_layout_MMPageFrame__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<MMPageFrame__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(MMPageFrame__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MMPageFrame__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MMPageFrame__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMPageFrame__bindgen_ty_2__bindgen_ty_2>())).references
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMPageFrame__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(references)
        )
    );
}
#[test]
fn bindgen_test_layout_MMPageFrame__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<MMPageFrame__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(MMPageFrame__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<MMPageFrame__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(MMPageFrame__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMPageFrame__bindgen_ty_2>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMPageFrame__bindgen_ty_2),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMPageFrame__bindgen_ty_2>())).active as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMPageFrame__bindgen_ty_2),
            "::",
            stringify!(active)
        )
    );
}
#[test]
fn bindgen_test_layout_MMPageFrame() {
    assert_eq!(
        ::std::mem::size_of::<MMPageFrame>(),
        32usize,
        concat!("Size of: ", stringify!(MMPageFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<MMPageFrame>(),
        8usize,
        concat!("Alignment of ", stringify!(MMPageFrame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMPageFrame>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMPageFrame),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMPageFrame>())).flags as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MMPageFrame),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMPageFrame>())).cacheReference as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMPageFrame),
            "::",
            stringify!(cacheReference)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bitset {
    pub singleUsage: *mut u32,
    pub groupUsage: *mut u16,
    pub singleCount: size_t,
    pub groupCount: size_t,
}
#[test]
fn bindgen_test_layout_Bitset() {
    assert_eq!(
        ::std::mem::size_of::<Bitset>(),
        32usize,
        concat!("Size of: ", stringify!(Bitset))
    );
    assert_eq!(
        ::std::mem::align_of::<Bitset>(),
        8usize,
        concat!("Alignment of ", stringify!(Bitset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Bitset>())).singleUsage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bitset),
            "::",
            stringify!(singleUsage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Bitset>())).groupUsage as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Bitset),
            "::",
            stringify!(groupUsage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Bitset>())).singleCount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Bitset),
            "::",
            stringify!(singleCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Bitset>())).groupCount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Bitset),
            "::",
            stringify!(groupCount)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6Bitset10InitialiseEmb"]
    pub fn Bitset_Initialise(this: *mut Bitset, count: size_t, mapAll: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN6Bitset6PutAllEv"]
    pub fn Bitset_PutAll(this: *mut Bitset);
}
extern "C" {
    #[link_name = "\u{1}_ZN6Bitset3GetEmmm"]
    pub fn Bitset_Get(this: *mut Bitset, count: size_t, align: usize, below: usize) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN6Bitset3PutEm"]
    pub fn Bitset_Put(this: *mut Bitset, index: usize);
}
extern "C" {
    #[link_name = "\u{1}_ZN6Bitset4TakeEm"]
    pub fn Bitset_Take(this: *mut Bitset, index: usize);
}
extern "C" {
    #[link_name = "\u{1}_ZN6Bitset4ReadEm"]
    pub fn Bitset_Read(this: *mut Bitset, index: usize) -> bool;
}
impl Bitset {
    #[inline]
    pub unsafe fn Initialise(&mut self, count: size_t, mapAll: bool) {
        Bitset_Initialise(self, count, mapAll)
    }
    #[inline]
    pub unsafe fn PutAll(&mut self) {
        Bitset_PutAll(self)
    }
    #[inline]
    pub unsafe fn Get(&mut self, count: size_t, align: usize, below: usize) -> usize {
        Bitset_Get(self, count, align, below)
    }
    #[inline]
    pub unsafe fn Put(&mut self, index: usize) {
        Bitset_Put(self, index)
    }
    #[inline]
    pub unsafe fn Take(&mut self, index: usize) {
        Bitset_Take(self, index)
    }
    #[inline]
    pub unsafe fn Read(&mut self, index: usize) -> bool {
        Bitset_Read(self, index)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MMObjectCache {
    pub lock: KSpinlock,
    pub items: SimpleList,
    pub count: size_t,
    pub trim: ::std::option::Option<unsafe extern "C" fn(cache: *mut MMObjectCache) -> bool>,
    pub trimLock: KWriterLock,
    pub item: LinkedItem<MMObjectCache>,
    pub averageObjectBytes: size_t,
}
#[test]
fn bindgen_test_layout_MMObjectCache() {
    assert_eq!(
        ::std::mem::size_of::<MMObjectCache>(),
        112usize,
        concat!("Size of: ", stringify!(MMObjectCache))
    );
    assert_eq!(
        ::std::mem::align_of::<MMObjectCache>(),
        8usize,
        concat!("Alignment of ", stringify!(MMObjectCache))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMObjectCache>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMObjectCache),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMObjectCache>())).items as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMObjectCache),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMObjectCache>())).count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMObjectCache),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMObjectCache>())).trim as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MMObjectCache),
            "::",
            stringify!(trim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMObjectCache>())).trimLock as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MMObjectCache),
            "::",
            stringify!(trimLock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMObjectCache>())).item as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MMObjectCache),
            "::",
            stringify!(item)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMObjectCache>())).averageObjectBytes as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(MMObjectCache),
            "::",
            stringify!(averageObjectBytes)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_Z18MMPhysicalAllocatejmmm"]
    pub fn MMPhysicalAllocate(
        flags: ::std::os::raw::c_uint,
        count: usize,
        align: usize,
        below: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_Z14MMPhysicalFreembm"]
    pub fn MMPhysicalFree(page: usize, mutexAlreadyAcquired: bool, count: size_t);
}
extern "C" {
    #[link_name = "\u{1}_Z24MMPhysicalAllocateAndMapmmmbmPPhPm"]
    pub fn MMPhysicalAllocateAndMap(
        sizeBytes: size_t,
        alignmentBytes: size_t,
        maximumBits: size_t,
        zeroed: bool,
        caching: u64,
        virtualAddress: *mut *mut u8,
        physicalAddress: *mut usize,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z22MMPhysicalFreeAndUnmapPvm"]
    pub fn MMPhysicalFreeAndUnmap(
        virtualAddress: *mut ::std::os::raw::c_void,
        physicalAddress: usize,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PMM {
    pub pageFrames: *mut MMPageFrame,
    pub pageFrameDatabaseInitialised: bool,
    pub pageFrameDatabaseCount: usize,
    pub firstFreePage: usize,
    pub firstZeroedPage: usize,
    pub firstStandbyPage: usize,
    pub lastStandbyPage: usize,
    pub freeOrZeroedPageBitset: Bitset,
    pub countZeroedPages: usize,
    pub countFreePages: usize,
    pub countStandbyPages: usize,
    pub countActivePages: usize,
    pub commitFixed: i64,
    pub commitPageable: i64,
    pub commitFixedLimit: i64,
    pub commitLimit: i64,
    pub commitMutex: KMutex,
    pub pageFrameMutex: KMutex,
    pub pmManipulationLock: KMutex,
    pub pmManipulationProcessorLock: KSpinlock,
    pub pmManipulationRegion: *mut ::std::os::raw::c_void,
    pub zeroPageThread: *mut Thread,
    pub zeroPageEvent: KEvent,
    pub objectCacheList: LinkedList<MMObjectCache>,
    pub objectCacheListMutex: KMutex,
    pub availableCritical: KEvent,
    pub availableLow: KEvent,
    pub availableNotCritical: KEvent,
    pub approximateTotalObjectCacheBytes: usize,
    pub trimObjectCaches: KEvent,
    pub nextProcessToBalance: *mut Process,
    pub nextRegionToBalance: *mut MMRegion,
    pub balanceResumePosition: usize,
}
#[test]
fn bindgen_test_layout_PMM() {
    assert_eq!(
        ::std::mem::size_of::<PMM>(),
        600usize,
        concat!("Size of: ", stringify!(PMM))
    );
    assert_eq!(
        ::std::mem::align_of::<PMM>(),
        8usize,
        concat!("Alignment of ", stringify!(PMM))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).pageFrames as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(pageFrames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PMM>())).pageFrameDatabaseInitialised as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(pageFrameDatabaseInitialised)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).pageFrameDatabaseCount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(pageFrameDatabaseCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).firstFreePage as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(firstFreePage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).firstZeroedPage as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(firstZeroedPage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).firstStandbyPage as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(firstStandbyPage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).lastStandbyPage as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(lastStandbyPage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).freeOrZeroedPageBitset as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(freeOrZeroedPageBitset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).countZeroedPages as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(countZeroedPages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).countFreePages as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(countFreePages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).countStandbyPages as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(countStandbyPages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).countActivePages as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(countActivePages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).commitFixed as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(commitFixed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).commitPageable as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(commitPageable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).commitFixedLimit as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(commitFixedLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).commitLimit as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(commitLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).commitMutex as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(commitMutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).pageFrameMutex as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(pageFrameMutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).pmManipulationLock as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(pmManipulationLock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).pmManipulationProcessorLock as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(pmManipulationProcessorLock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).pmManipulationRegion as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(pmManipulationRegion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).zeroPageThread as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(zeroPageThread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).zeroPageEvent as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(zeroPageEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).objectCacheList as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(objectCacheList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).objectCacheListMutex as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(objectCacheListMutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).availableCritical as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(availableCritical)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).availableLow as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(availableLow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).availableNotCritical as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(availableNotCritical)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PMM>())).approximateTotalObjectCacheBytes as *const _ as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(approximateTotalObjectCacheBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).trimObjectCaches as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(trimObjectCaches)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).nextProcessToBalance as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(nextProcessToBalance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).nextRegionToBalance as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(nextRegionToBalance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PMM>())).balanceResumePosition as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(PMM),
            "::",
            stringify!(balanceResumePosition)
        )
    );
}
extern "C" {
    pub static mut pmm: PMM;
}
extern "C" {
    pub static mut mmCoreRegions: *mut MMRegion;
}
extern "C" {
    pub static mut mmCoreRegionCount: size_t;
}
extern "C" {
    pub static mut mmCoreRegionArrayCommit: size_t;
}
#[test]
fn __bindgen_test_layout_LinkedList_open0_MMSharedRegion_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<LinkedList<MMSharedRegion>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedList<MMSharedRegion>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedList<MMSharedRegion>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedList<MMSharedRegion>)
        )
    );
}
extern "C" {
    pub static mut mmNamedSharedRegions: LinkedList<MMSharedRegion>;
}
extern "C" {
    pub static mut mmNamedSharedRegionsMutex: KMutex;
}
extern "C" {
    pub static mut globalData: *mut GlobalData;
}
pub type KIRQHandler = ::std::option::Option<
    unsafe extern "C" fn(interruptIndex: usize, context: *mut ::std::os::raw::c_void) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KPCIDevice {
    pub _base: KDevice,
    pub deviceID: u32,
    pub subsystemID: u32,
    pub domain: u32,
    pub classCode: u8,
    pub subclassCode: u8,
    pub progIF: u8,
    pub bus: u8,
    pub slot: u8,
    pub function: u8,
    pub interruptPin: u8,
    pub interruptLine: u8,
    pub baseAddressesVirtual: [*mut u8; 6usize],
    pub baseAddressesPhysical: [usize; 6usize],
    pub baseAddressesSizes: [size_t; 6usize],
    pub baseAddresses: [u32; 6usize],
}
#[test]
fn bindgen_test_layout_KPCIDevice() {
    assert_eq!(
        ::std::mem::size_of::<KPCIDevice>(),
        272usize,
        concat!("Size of: ", stringify!(KPCIDevice))
    );
    assert_eq!(
        ::std::mem::align_of::<KPCIDevice>(),
        8usize,
        concat!("Alignment of ", stringify!(KPCIDevice))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KPCIDevice>())).deviceID as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(KPCIDevice),
            "::",
            stringify!(deviceID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KPCIDevice>())).subsystemID as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(KPCIDevice),
            "::",
            stringify!(subsystemID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KPCIDevice>())).domain as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(KPCIDevice),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KPCIDevice>())).classCode as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(KPCIDevice),
            "::",
            stringify!(classCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KPCIDevice>())).subclassCode as *const _ as usize },
        93usize,
        concat!(
            "Offset of field: ",
            stringify!(KPCIDevice),
            "::",
            stringify!(subclassCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KPCIDevice>())).progIF as *const _ as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(KPCIDevice),
            "::",
            stringify!(progIF)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KPCIDevice>())).bus as *const _ as usize },
        95usize,
        concat!(
            "Offset of field: ",
            stringify!(KPCIDevice),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KPCIDevice>())).slot as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(KPCIDevice),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KPCIDevice>())).function as *const _ as usize },
        97usize,
        concat!(
            "Offset of field: ",
            stringify!(KPCIDevice),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KPCIDevice>())).interruptPin as *const _ as usize },
        98usize,
        concat!(
            "Offset of field: ",
            stringify!(KPCIDevice),
            "::",
            stringify!(interruptPin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KPCIDevice>())).interruptLine as *const _ as usize },
        99usize,
        concat!(
            "Offset of field: ",
            stringify!(KPCIDevice),
            "::",
            stringify!(interruptLine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KPCIDevice>())).baseAddressesVirtual as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(KPCIDevice),
            "::",
            stringify!(baseAddressesVirtual)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<KPCIDevice>())).baseAddressesPhysical as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(KPCIDevice),
            "::",
            stringify!(baseAddressesPhysical)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KPCIDevice>())).baseAddressesSizes as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(KPCIDevice),
            "::",
            stringify!(baseAddressesSizes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KPCIDevice>())).baseAddresses as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(KPCIDevice),
            "::",
            stringify!(baseAddresses)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10KPCIDevice9WriteBAR8Emmh"]
    pub fn KPCIDevice_WriteBAR8(this: *mut KPCIDevice, index: usize, offset: usize, value: u8);
}
extern "C" {
    #[link_name = "\u{1}_ZN10KPCIDevice8ReadBAR8Emm"]
    pub fn KPCIDevice_ReadBAR8(this: *mut KPCIDevice, index: usize, offset: usize) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN10KPCIDevice10WriteBAR16Emmt"]
    pub fn KPCIDevice_WriteBAR16(this: *mut KPCIDevice, index: usize, offset: usize, value: u16);
}
extern "C" {
    #[link_name = "\u{1}_ZN10KPCIDevice9ReadBAR16Emm"]
    pub fn KPCIDevice_ReadBAR16(this: *mut KPCIDevice, index: usize, offset: usize) -> u16;
}
extern "C" {
    #[link_name = "\u{1}_ZN10KPCIDevice10WriteBAR32Emmj"]
    pub fn KPCIDevice_WriteBAR32(this: *mut KPCIDevice, index: usize, offset: usize, value: u32);
}
extern "C" {
    #[link_name = "\u{1}_ZN10KPCIDevice9ReadBAR32Emm"]
    pub fn KPCIDevice_ReadBAR32(this: *mut KPCIDevice, index: usize, offset: usize) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN10KPCIDevice10WriteBAR64Emmm"]
    pub fn KPCIDevice_WriteBAR64(this: *mut KPCIDevice, index: usize, offset: usize, value: u64);
}
extern "C" {
    #[link_name = "\u{1}_ZN10KPCIDevice9ReadBAR64Emm"]
    pub fn KPCIDevice_ReadBAR64(this: *mut KPCIDevice, index: usize, offset: usize) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN10KPCIDevice12WriteConfig8Emh"]
    pub fn KPCIDevice_WriteConfig8(this: *mut KPCIDevice, offset: usize, value: u8);
}
extern "C" {
    #[link_name = "\u{1}_ZN10KPCIDevice11ReadConfig8Em"]
    pub fn KPCIDevice_ReadConfig8(this: *mut KPCIDevice, offset: usize) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN10KPCIDevice13WriteConfig16Emt"]
    pub fn KPCIDevice_WriteConfig16(this: *mut KPCIDevice, offset: usize, value: u16);
}
extern "C" {
    #[link_name = "\u{1}_ZN10KPCIDevice12ReadConfig16Em"]
    pub fn KPCIDevice_ReadConfig16(this: *mut KPCIDevice, offset: usize) -> u16;
}
extern "C" {
    #[link_name = "\u{1}_ZN10KPCIDevice13WriteConfig32Emj"]
    pub fn KPCIDevice_WriteConfig32(this: *mut KPCIDevice, offset: usize, value: u32);
}
extern "C" {
    #[link_name = "\u{1}_ZN10KPCIDevice12ReadConfig32Em"]
    pub fn KPCIDevice_ReadConfig32(this: *mut KPCIDevice, offset: usize) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN10KPCIDevice14EnableFeaturesEm"]
    pub fn KPCIDevice_EnableFeatures(this: *mut KPCIDevice, features: u64) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10KPCIDevice21EnableSingleInterruptEPFbmPvES0_PKc"]
    pub fn KPCIDevice_EnableSingleInterrupt(
        this: *mut KPCIDevice,
        irqHandler: KIRQHandler,
        context: *mut ::std::os::raw::c_void,
        cOwnerName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10KPCIDevice9EnableMSIEPFbmPvES0_PKc"]
    pub fn KPCIDevice_EnableMSI(
        this: *mut KPCIDevice,
        irqHandler: KIRQHandler,
        context: *mut ::std::os::raw::c_void,
        cOwnerName: *const ::std::os::raw::c_char,
    ) -> bool;
}
impl KPCIDevice {
    #[inline]
    pub unsafe fn WriteBAR8(&mut self, index: usize, offset: usize, value: u8) {
        KPCIDevice_WriteBAR8(self, index, offset, value)
    }
    #[inline]
    pub unsafe fn ReadBAR8(&mut self, index: usize, offset: usize) -> u8 {
        KPCIDevice_ReadBAR8(self, index, offset)
    }
    #[inline]
    pub unsafe fn WriteBAR16(&mut self, index: usize, offset: usize, value: u16) {
        KPCIDevice_WriteBAR16(self, index, offset, value)
    }
    #[inline]
    pub unsafe fn ReadBAR16(&mut self, index: usize, offset: usize) -> u16 {
        KPCIDevice_ReadBAR16(self, index, offset)
    }
    #[inline]
    pub unsafe fn WriteBAR32(&mut self, index: usize, offset: usize, value: u32) {
        KPCIDevice_WriteBAR32(self, index, offset, value)
    }
    #[inline]
    pub unsafe fn ReadBAR32(&mut self, index: usize, offset: usize) -> u32 {
        KPCIDevice_ReadBAR32(self, index, offset)
    }
    #[inline]
    pub unsafe fn WriteBAR64(&mut self, index: usize, offset: usize, value: u64) {
        KPCIDevice_WriteBAR64(self, index, offset, value)
    }
    #[inline]
    pub unsafe fn ReadBAR64(&mut self, index: usize, offset: usize) -> u64 {
        KPCIDevice_ReadBAR64(self, index, offset)
    }
    #[inline]
    pub unsafe fn WriteConfig8(&mut self, offset: usize, value: u8) {
        KPCIDevice_WriteConfig8(self, offset, value)
    }
    #[inline]
    pub unsafe fn ReadConfig8(&mut self, offset: usize) -> u8 {
        KPCIDevice_ReadConfig8(self, offset)
    }
    #[inline]
    pub unsafe fn WriteConfig16(&mut self, offset: usize, value: u16) {
        KPCIDevice_WriteConfig16(self, offset, value)
    }
    #[inline]
    pub unsafe fn ReadConfig16(&mut self, offset: usize) -> u16 {
        KPCIDevice_ReadConfig16(self, offset)
    }
    #[inline]
    pub unsafe fn WriteConfig32(&mut self, offset: usize, value: u32) {
        KPCIDevice_WriteConfig32(self, offset, value)
    }
    #[inline]
    pub unsafe fn ReadConfig32(&mut self, offset: usize) -> u32 {
        KPCIDevice_ReadConfig32(self, offset)
    }
    #[inline]
    pub unsafe fn EnableFeatures(&mut self, features: u64) -> bool {
        KPCIDevice_EnableFeatures(self, features)
    }
    #[inline]
    pub unsafe fn EnableSingleInterrupt(
        &mut self,
        irqHandler: KIRQHandler,
        context: *mut ::std::os::raw::c_void,
        cOwnerName: *const ::std::os::raw::c_char,
    ) -> bool {
        KPCIDevice_EnableSingleInterrupt(self, irqHandler, context, cOwnerName)
    }
    #[inline]
    pub unsafe fn EnableMSI(
        &mut self,
        irqHandler: KIRQHandler,
        context: *mut ::std::os::raw::c_void,
        cOwnerName: *const ::std::os::raw::c_char,
    ) -> bool {
        KPCIDevice_EnableMSI(self, irqHandler, context, cOwnerName)
    }
}
extern "C" {
    #[link_name = "\u{1}_Z12MMFindRegionP7MMSpacem"]
    pub fn MMFindRegion(space: *mut MMSpace, address: usize) -> *mut MMRegion;
}
extern "C" {
    #[link_name = "\u{1}_Z10MMDecommitmb"]
    pub fn MMDecommit(bytes: u64, fixed: bool);
}
extern "C" {
    #[link_name = "\u{1}_Z15MMDecommitRangeP7MMSpaceP8MMRegionmm"]
    pub fn MMDecommitRange(
        space: *mut MMSpace,
        region: *mut MMRegion,
        pageOffset: usize,
        pageCount: size_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z22MMArchTranslateAddressP7MMSpacemb"]
    pub fn MMArchTranslateAddress(
        arg1: *mut MMSpace,
        virtualAddress: usize,
        writeAccess: bool,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCActiveSectionReference {
    pub offset: EsFileOffset,
    pub index: usize,
}
#[test]
fn bindgen_test_layout_CCActiveSectionReference() {
    assert_eq!(
        ::std::mem::size_of::<CCActiveSectionReference>(),
        16usize,
        concat!("Size of: ", stringify!(CCActiveSectionReference))
    );
    assert_eq!(
        ::std::mem::align_of::<CCActiveSectionReference>(),
        8usize,
        concat!("Alignment of ", stringify!(CCActiveSectionReference))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCActiveSectionReference>())).offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CCActiveSectionReference),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCActiveSectionReference>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CCActiveSectionReference),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CCActiveSection {
    pub loadCompleteEvent: KEvent,
    pub writeCompleteEvent: KEvent,
    pub listItem: LinkedItem<CCActiveSection>,
    pub offset: EsFileOffset,
    pub cache: *mut CCSpace,
    pub accessors: size_t,
    pub loading: bool,
    pub writing: bool,
    pub modified: bool,
    pub flush: bool,
    pub referencedPageCount: u16,
    pub referencedPages: [u8; 8usize],
    pub modifiedPages: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_CCActiveSection() {
    assert_eq!(
        ::std::mem::size_of::<CCActiveSection>(),
        176usize,
        concat!("Size of: ", stringify!(CCActiveSection))
    );
    assert_eq!(
        ::std::mem::align_of::<CCActiveSection>(),
        8usize,
        concat!("Alignment of ", stringify!(CCActiveSection))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CCActiveSection>())).loadCompleteEvent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CCActiveSection),
            "::",
            stringify!(loadCompleteEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CCActiveSection>())).writeCompleteEvent as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CCActiveSection),
            "::",
            stringify!(writeCompleteEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCActiveSection>())).listItem as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CCActiveSection),
            "::",
            stringify!(listItem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCActiveSection>())).offset as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CCActiveSection),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCActiveSection>())).cache as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CCActiveSection),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCActiveSection>())).accessors as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(CCActiveSection),
            "::",
            stringify!(accessors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCActiveSection>())).loading as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(CCActiveSection),
            "::",
            stringify!(loading)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCActiveSection>())).writing as *const _ as usize },
        153usize,
        concat!(
            "Offset of field: ",
            stringify!(CCActiveSection),
            "::",
            stringify!(writing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCActiveSection>())).modified as *const _ as usize },
        154usize,
        concat!(
            "Offset of field: ",
            stringify!(CCActiveSection),
            "::",
            stringify!(modified)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCActiveSection>())).flush as *const _ as usize },
        155usize,
        concat!(
            "Offset of field: ",
            stringify!(CCActiveSection),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CCActiveSection>())).referencedPageCount as *const _ as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(CCActiveSection),
            "::",
            stringify!(referencedPageCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCActiveSection>())).referencedPages as *const _ as usize },
        158usize,
        concat!(
            "Offset of field: ",
            stringify!(CCActiveSection),
            "::",
            stringify!(referencedPages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCActiveSection>())).modifiedPages as *const _ as usize },
        166usize,
        concat!(
            "Offset of field: ",
            stringify!(CCActiveSection),
            "::",
            stringify!(modifiedPages)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MMActiveSectionManager {
    pub sections: *mut CCActiveSection,
    pub sectionCount: size_t,
    pub baseAddress: *mut u8,
    pub mutex: KMutex,
    pub lruList: LinkedList<CCActiveSection>,
    pub modifiedList: LinkedList<CCActiveSection>,
    pub modifiedNonEmpty: KEvent,
    pub modifiedNonFull: KEvent,
    pub modifiedGettingFull: KEvent,
    pub writeBackThread: *mut Thread,
}
#[test]
fn bindgen_test_layout_MMActiveSectionManager() {
    assert_eq!(
        ::std::mem::size_of::<MMActiveSectionManager>(),
        256usize,
        concat!("Size of: ", stringify!(MMActiveSectionManager))
    );
    assert_eq!(
        ::std::mem::align_of::<MMActiveSectionManager>(),
        8usize,
        concat!("Alignment of ", stringify!(MMActiveSectionManager))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMActiveSectionManager>())).sections as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MMActiveSectionManager),
            "::",
            stringify!(sections)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMActiveSectionManager>())).sectionCount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MMActiveSectionManager),
            "::",
            stringify!(sectionCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMActiveSectionManager>())).baseAddress as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MMActiveSectionManager),
            "::",
            stringify!(baseAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMActiveSectionManager>())).mutex as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MMActiveSectionManager),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MMActiveSectionManager>())).lruList as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MMActiveSectionManager),
            "::",
            stringify!(lruList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMActiveSectionManager>())).modifiedList as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MMActiveSectionManager),
            "::",
            stringify!(modifiedList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMActiveSectionManager>())).modifiedNonEmpty as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(MMActiveSectionManager),
            "::",
            stringify!(modifiedNonEmpty)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMActiveSectionManager>())).modifiedNonFull as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(MMActiveSectionManager),
            "::",
            stringify!(modifiedNonFull)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMActiveSectionManager>())).modifiedGettingFull as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(MMActiveSectionManager),
            "::",
            stringify!(modifiedGettingFull)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MMActiveSectionManager>())).writeBackThread as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(MMActiveSectionManager),
            "::",
            stringify!(writeBackThread)
        )
    );
}
extern "C" {
    pub static mut activeSectionManager: MMActiveSectionManager;
}
extern "C" {
    #[link_name = "\u{1}_Z26CCDereferenceActiveSectionP15CCActiveSectionm"]
    pub fn CCDereferenceActiveSection(section: *mut CCActiveSection, startingPage: usize);
}
extern "C" {
    #[link_name = "\u{1}_Z29CCFindCachedSectionContainingP7CCSpacem"]
    pub fn CCFindCachedSectionContaining(
        cache: *mut CCSpace,
        sectionOffset: EsFileOffset,
    ) -> *mut CCCachedSection;
}
extern "C" {
    #[link_name = "\u{1}_Z14CCSpaceUncoverP7CCSpacemm"]
    pub fn CCSpaceUncover(cache: *mut CCSpace, removeStart: EsFileOffset, removeEnd: EsFileOffset);
}
extern "C" {
    #[link_name = "\u{1}_Z12CCSpaceCoverP7CCSpacemm"]
    pub fn CCSpaceCover(
        cache: *mut CCSpace,
        insertStart: EsFileOffset,
        insertEnd: EsFileOffset,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z14CCWriteSectionP15CCActiveSection"]
    pub fn CCWriteSection(section: *mut CCActiveSection);
}
extern "C" {
    #[link_name = "\u{1}_Z21CCWriteSectionPrepareP15CCActiveSection"]
    pub fn CCWriteSectionPrepare(section: *mut CCActiveSection);
}
extern "C" {
    #[link_name = "\u{1}_Z28CCActiveSectionReturnToListsP15CCActiveSectionb"]
    pub fn CCActiveSectionReturnToLists(section: *mut CCActiveSection, writeBack: bool);
}
extern "C" {
    #[link_name = "\u{1}_Z13CCSpaceAccessP7CCSpacePvmmjP7MMSpacej"]
    pub fn CCSpaceAccess(
        cache: *mut CCSpace,
        _buffer: *mut ::std::os::raw::c_void,
        offset: EsFileOffset,
        count: EsFileOffset,
        flags: u32,
        mapSpace: *mut MMSpace,
        mapFlags: ::std::os::raw::c_uint,
    ) -> EsError;
}
extern "C" {
    #[link_name = "\u{1}_Z17MMHandlePageFaultP7MMSpacemj"]
    pub fn MMHandlePageFault(
        space: *mut MMSpace,
        address: usize,
        faultFlags: ::std::os::raw::c_uint,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KDMABuffer {
    pub virtualAddress: usize,
    pub totalByteCount: size_t,
    pub offsetBytes: usize,
}
#[test]
fn bindgen_test_layout_KDMABuffer() {
    assert_eq!(
        ::std::mem::size_of::<KDMABuffer>(),
        24usize,
        concat!("Size of: ", stringify!(KDMABuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<KDMABuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(KDMABuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KDMABuffer>())).virtualAddress as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KDMABuffer),
            "::",
            stringify!(virtualAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KDMABuffer>())).totalByteCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(KDMABuffer),
            "::",
            stringify!(totalByteCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KDMABuffer>())).offsetBytes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(KDMABuffer),
            "::",
            stringify!(offsetBytes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct KWorkGroup {
    pub remaining: usize,
    pub success: usize,
    pub event: KEvent,
}
#[test]
fn bindgen_test_layout_KWorkGroup() {
    assert_eq!(
        ::std::mem::size_of::<KWorkGroup>(),
        64usize,
        concat!("Size of: ", stringify!(KWorkGroup))
    );
    assert_eq!(
        ::std::mem::align_of::<KWorkGroup>(),
        8usize,
        concat!("Alignment of ", stringify!(KWorkGroup))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KWorkGroup>())).remaining as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KWorkGroup),
            "::",
            stringify!(remaining)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KWorkGroup>())).success as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(KWorkGroup),
            "::",
            stringify!(success)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KWorkGroup>())).event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(KWorkGroup),
            "::",
            stringify!(event)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsBlockDeviceInformation {
    pub sectorSize: size_t,
    pub sectorCount: EsFileOffset,
    pub readOnly: bool,
    pub nestLevel: u8,
    pub driveType: u8,
    pub modelBytes: u8,
    pub model: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_EsBlockDeviceInformation() {
    assert_eq!(
        ::std::mem::size_of::<EsBlockDeviceInformation>(),
        88usize,
        concat!("Size of: ", stringify!(EsBlockDeviceInformation))
    );
    assert_eq!(
        ::std::mem::align_of::<EsBlockDeviceInformation>(),
        8usize,
        concat!("Alignment of ", stringify!(EsBlockDeviceInformation))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsBlockDeviceInformation>())).sectorSize as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsBlockDeviceInformation),
            "::",
            stringify!(sectorSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsBlockDeviceInformation>())).sectorCount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsBlockDeviceInformation),
            "::",
            stringify!(sectorCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsBlockDeviceInformation>())).readOnly as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsBlockDeviceInformation),
            "::",
            stringify!(readOnly)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsBlockDeviceInformation>())).nestLevel as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(EsBlockDeviceInformation),
            "::",
            stringify!(nestLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsBlockDeviceInformation>())).driveType as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(EsBlockDeviceInformation),
            "::",
            stringify!(driveType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsBlockDeviceInformation>())).modelBytes as *const _ as usize
        },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(EsBlockDeviceInformation),
            "::",
            stringify!(modelBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsBlockDeviceInformation>())).model as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(EsBlockDeviceInformation),
            "::",
            stringify!(model)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KBlockDeviceAccessRequest {
    pub device: *mut KBlockDevice,
    pub offset: EsFileOffset,
    pub count: size_t,
    pub operation: ::std::os::raw::c_int,
    pub buffer: *mut KDMABuffer,
    pub flags: u64,
    pub dispatchGroup: *mut KWorkGroup,
}
#[test]
fn bindgen_test_layout_KBlockDeviceAccessRequest() {
    assert_eq!(
        ::std::mem::size_of::<KBlockDeviceAccessRequest>(),
        56usize,
        concat!("Size of: ", stringify!(KBlockDeviceAccessRequest))
    );
    assert_eq!(
        ::std::mem::align_of::<KBlockDeviceAccessRequest>(),
        8usize,
        concat!("Alignment of ", stringify!(KBlockDeviceAccessRequest))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<KBlockDeviceAccessRequest>())).device as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KBlockDeviceAccessRequest),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<KBlockDeviceAccessRequest>())).offset as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(KBlockDeviceAccessRequest),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KBlockDeviceAccessRequest>())).count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(KBlockDeviceAccessRequest),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<KBlockDeviceAccessRequest>())).operation as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(KBlockDeviceAccessRequest),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<KBlockDeviceAccessRequest>())).buffer as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(KBlockDeviceAccessRequest),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KBlockDeviceAccessRequest>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(KBlockDeviceAccessRequest),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<KBlockDeviceAccessRequest>())).dispatchGroup as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(KBlockDeviceAccessRequest),
            "::",
            stringify!(dispatchGroup)
        )
    );
}
pub type KDeviceAccessCallbackFunction =
    ::std::option::Option<unsafe extern "C" fn(request: KBlockDeviceAccessRequest)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct KBlockDevice {
    pub _base: KDevice,
    pub access: KDeviceAccessCallbackFunction,
    pub information: EsBlockDeviceInformation,
    pub maxAccessSectorCount: size_t,
    pub signatureBlock: *mut u8,
    pub detectFileSystemMutex: KMutex,
}
#[test]
fn bindgen_test_layout_KBlockDevice() {
    assert_eq!(
        ::std::mem::size_of::<KBlockDevice>(),
        224usize,
        concat!("Size of: ", stringify!(KBlockDevice))
    );
    assert_eq!(
        ::std::mem::align_of::<KBlockDevice>(),
        8usize,
        concat!("Alignment of ", stringify!(KBlockDevice))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KBlockDevice>())).access as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(KBlockDevice),
            "::",
            stringify!(access)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KBlockDevice>())).information as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(KBlockDevice),
            "::",
            stringify!(information)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<KBlockDevice>())).maxAccessSectorCount as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(KBlockDevice),
            "::",
            stringify!(maxAccessSectorCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KBlockDevice>())).signatureBlock as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(KBlockDevice),
            "::",
            stringify!(signatureBlock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<KBlockDevice>())).detectFileSystemMutex as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(KBlockDevice),
            "::",
            stringify!(detectFileSystemMutex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct KFileSystem {
    pub _base: KDevice,
    pub block: *mut KBlockDevice,
    pub rootDirectory: *mut KNode,
    pub name: [::std::os::raw::c_char; 64usize],
    pub nameBytes: size_t,
    pub directoryEntryDataBytes: size_t,
    pub nodeDataBytes: size_t,
    pub rootDirectoryInitialChildren: EsFileOffsetDifference,
    pub spaceTotal: EsFileOffset,
    pub spaceUsed: EsFileOffset,
    pub identifier: EsUniqueIdentifier,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            node: *mut KNode,
            buffer: *mut ::std::os::raw::c_void,
            offset: EsFileOffset,
            count: EsFileOffset,
        ) -> size_t,
    >,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            node: *mut KNode,
            buffer: *const ::std::os::raw::c_void,
            offset: EsFileOffset,
            count: EsFileOffset,
        ) -> size_t,
    >,
    pub sync: ::std::option::Option<unsafe extern "C" fn(directory: *mut KNode, node: *mut KNode)>,
    pub scan: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            nameLength: size_t,
            directory: *mut KNode,
        ) -> EsError,
    >,
    pub load: ::std::option::Option<
        unsafe extern "C" fn(
            directory: *mut KNode,
            node: *mut KNode,
            metadata: *mut KNodeMetadata,
            entryData: *const ::std::os::raw::c_void,
        ) -> EsError,
    >,
    pub resize: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut KNode,
            newSize: EsFileOffset,
            error: *mut EsError,
        ) -> EsFileOffset,
    >,
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            nameLength: size_t,
            type_: EsNodeType,
            parent: *mut KNode,
            node: *mut KNode,
            driverData: *mut ::std::os::raw::c_void,
        ) -> EsError,
    >,
    pub enumerate: ::std::option::Option<unsafe extern "C" fn(directory: *mut KNode) -> EsError>,
    pub remove: ::std::option::Option<
        unsafe extern "C" fn(directory: *mut KNode, file: *mut KNode) -> EsError,
    >,
    pub move_: ::std::option::Option<
        unsafe extern "C" fn(
            oldDirectory: *mut KNode,
            file: *mut KNode,
            newDirectory: *mut KNode,
            newName: *const ::std::os::raw::c_char,
            newNameLength: size_t,
        ) -> EsError,
    >,
    pub close: ::std::option::Option<unsafe extern "C" fn(node: *mut KNode)>,
    pub unmount: ::std::option::Option<unsafe extern "C" fn(fileSystem: *mut KFileSystem)>,
    pub moveMutex: KMutex,
    pub isBootFileSystem: bool,
    pub unmounting: bool,
    pub installationIdentifier: EsUniqueIdentifier,
    pub totalHandleCount: u64,
    pub cacheSpace: CCSpace,
    pub cachedDirectoryEntries: MMObjectCache,
    pub cachedNodes: MMObjectCache,
}
#[test]
fn bindgen_test_layout_KFileSystem() {
    assert_eq!(
        ::std::mem::size_of::<KFileSystem>(),
        744usize,
        concat!("Size of: ", stringify!(KFileSystem))
    );
    assert_eq!(
        ::std::mem::align_of::<KFileSystem>(),
        8usize,
        concat!("Alignment of ", stringify!(KFileSystem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).block as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).rootDirectory as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(rootDirectory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).name as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).nameBytes as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(nameBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<KFileSystem>())).directoryEntryDataBytes as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(directoryEntryDataBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).nodeDataBytes as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(nodeDataBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<KFileSystem>())).rootDirectoryInitialChildren as *const _
                as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(rootDirectoryInitialChildren)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).spaceTotal as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(spaceTotal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).spaceUsed as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(spaceUsed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).identifier as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(identifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).read as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).write as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).sync as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(sync)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).scan as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).load as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).resize as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(resize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).create as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).enumerate as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(enumerate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).remove as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).move_ as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(move_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).close as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).unmount as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(unmount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).moveMutex as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(moveMutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).isBootFileSystem as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(isBootFileSystem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).unmounting as *const _ as usize },
        353usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(unmounting)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<KFileSystem>())).installationIdentifier as *const _ as usize
        },
        354usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(installationIdentifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).totalHandleCount as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(totalHandleCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).cacheSpace as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(cacheSpace)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<KFileSystem>())).cachedDirectoryEntries as *const _ as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(cachedDirectoryEntries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KFileSystem>())).cachedNodes as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(KFileSystem),
            "::",
            stringify!(cachedNodes)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11KFileSystem6AccessEmmiPvjP10KWorkGroup"]
    pub fn KFileSystem_Access(
        this: *mut KFileSystem,
        offset: EsFileOffset,
        count: size_t,
        operation: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        flags: u32,
        dispatchGroup: *mut KWorkGroup,
    ) -> EsError;
}
impl KFileSystem {
    #[inline]
    pub unsafe fn Access(
        &mut self,
        offset: EsFileOffset,
        count: size_t,
        operation: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        flags: u32,
        dispatchGroup: *mut KWorkGroup,
    ) -> EsError {
        KFileSystem_Access(self, offset, count, operation, buffer, flags, dispatchGroup)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _bindgen_ty_1 {
    pub fileSystemsLock: KWriterLock,
    pub bootFileSystem: *mut KFileSystem,
    pub foundBootFileSystemEvent: KEvent,
    pub updateNodeHandles: KSpinlock,
    pub shutdown: bool,
    pub totalHandleCount: u64,
    pub fileSystemsUnmounting: usize,
    pub fileSystemUnmounted: KEvent,
}
#[test]
fn bindgen_test_layout__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_1>(),
        160usize,
        concat!("Size of: ", stringify!(_bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).fileSystemsLock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(fileSystemsLock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).bootFileSystem as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(bootFileSystem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_bindgen_ty_1>())).foundBootFileSystemEvent as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(foundBootFileSystemEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).updateNodeHandles as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(updateNodeHandles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).shutdown as *const _ as usize },
        91usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).totalHandleCount as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(totalHandleCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_bindgen_ty_1>())).fileSystemsUnmounting as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(fileSystemsUnmounting)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_bindgen_ty_1>())).fileSystemUnmounted as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(fileSystemUnmounted)
        )
    );
}
extern "C" {
    pub static mut fs: _bindgen_ty_1;
}
extern "C" {
    #[link_name = "\u{1}_Z19MMObjectCacheInsertP13MMObjectCacheP10SimpleList"]
    pub fn MMObjectCacheInsert(cache: *mut MMObjectCache, item: *mut MMObjectCacheItem);
}
extern "C" {
    #[link_name = "\u{1}_Z23MMObjectCacheUnregisterP13MMObjectCache"]
    pub fn MMObjectCacheUnregister(cache: *mut MMObjectCache);
}
extern "C" {
    #[link_name = "\u{1}_Z18MMObjectCacheFlushP13MMObjectCache"]
    pub fn MMObjectCacheFlush(cache: *mut MMObjectCache);
}
extern "C" {
    pub static mut deviceTreeRoot: *mut KDevice;
}
extern "C" {
    pub static mut deviceTreeMutex: KMutex;
}
extern "C" {
    #[link_name = "\u{1}_Z17KDeviceOpenHandleP7KDevice"]
    pub fn KDeviceOpenHandle(device: *mut KDevice);
}
extern "C" {
    #[link_name = "\u{1}_Z13DeviceDestroyP7KDevice"]
    pub fn DeviceDestroy(device: *mut KDevice);
}
extern "C" {
    #[link_name = "\u{1}_Z18KDeviceCloseHandleP7KDevice"]
    pub fn KDeviceCloseHandle(device: *mut KDevice);
}
extern "C" {
    #[link_name = "\u{1}_Z19FSUnmountFileSystemm"]
    pub fn FSUnmountFileSystem(argument: usize);
}
extern "C" {
    #[link_name = "\u{1}_Z12CCSpaceFlushP7CCSpace"]
    pub fn CCSpaceFlush(cache: *mut CCSpace);
}
extern "C" {
    #[link_name = "\u{1}_Z26MMUpdateAvailablePageCountb"]
    pub fn MMUpdateAvailablePageCount(increase: bool);
}
extern "C" {
    #[link_name = "\u{1}_Z14CCSpaceDestroyP7CCSpace"]
    pub fn CCSpaceDestroy(cache: *mut CCSpace);
}
extern "C" {
    #[link_name = "\u{1}_Z16FSNodeOpenHandleP5KNodejh"]
    pub fn FSNodeOpenHandle(node: *mut KNode, flags: u32, mode: u8) -> EsError;
}
extern "C" {
    #[link_name = "\u{1}_Z10FSNodeFreeP5KNode"]
    pub fn FSNodeFree(node: *mut KNode);
}
extern "C" {
    #[link_name = "\u{1}_Z20FSDirectoryEntryFreeP16FSDirectoryEntry"]
    pub fn FSDirectoryEntryFree(entry: *mut FSDirectoryEntry);
}
extern "C" {
    #[link_name = "\u{1}_Z17FSNodeCloseHandleP5KNodej"]
    pub fn FSNodeCloseHandle(node: *mut KNode, flags: u32);
}
extern "C" {
    #[link_name = "\u{1}_Z12ThreadRemoveP6Thread"]
    pub fn ThreadRemove(thread: *mut Thread);
}
extern "C" {
    pub static mut objectHandleCountChange: KMutex;
}
extern "C" {
    #[link_name = "\u{1}_Z20MMSharedResizeRegionP14MMSharedRegionm"]
    pub fn MMSharedResizeRegion(region: *mut MMSharedRegion, sizeBytes: size_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z21MMSharedDestroyRegionP14MMSharedRegion"]
    pub fn MMSharedDestroyRegion(region: *mut MMSharedRegion);
}
extern "C" {
    #[link_name = "\u{1}_Z20MMSharedCreateRegionmbm"]
    pub fn MMSharedCreateRegion(
        sizeBytes: size_t,
        fixed: bool,
        below: usize,
    ) -> *mut MMSharedRegion;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EmbeddedWindow {
    pub owner: *mut Process,
    pub apiWindow: *mut ::std::os::raw::c_void,
    pub handles: u32,
    pub container: *mut Window,
    pub id: EsObjectID,
    pub closed: bool,
}
#[test]
fn bindgen_test_layout_EmbeddedWindow() {
    assert_eq!(
        ::std::mem::size_of::<EmbeddedWindow>(),
        48usize,
        concat!("Size of: ", stringify!(EmbeddedWindow))
    );
    assert_eq!(
        ::std::mem::align_of::<EmbeddedWindow>(),
        8usize,
        concat!("Alignment of ", stringify!(EmbeddedWindow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EmbeddedWindow>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EmbeddedWindow),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EmbeddedWindow>())).apiWindow as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EmbeddedWindow),
            "::",
            stringify!(apiWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EmbeddedWindow>())).handles as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EmbeddedWindow),
            "::",
            stringify!(handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EmbeddedWindow>())).container as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EmbeddedWindow),
            "::",
            stringify!(container)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EmbeddedWindow>())).id as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(EmbeddedWindow),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EmbeddedWindow>())).closed as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(EmbeddedWindow),
            "::",
            stringify!(closed)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14EmbeddedWindow5CloseEv"]
    pub fn EmbeddedWindow_Close(this: *mut EmbeddedWindow);
}
extern "C" {
    #[link_name = "\u{1}_ZN14EmbeddedWindow13SetEmbedOwnerEP7Process"]
    pub fn EmbeddedWindow_SetEmbedOwner(this: *mut EmbeddedWindow, process: *mut Process);
}
impl EmbeddedWindow {
    #[inline]
    pub unsafe fn Close(&mut self) {
        EmbeddedWindow_Close(self)
    }
    #[inline]
    pub unsafe fn SetEmbedOwner(&mut self, process: *mut Process) {
        EmbeddedWindow_SetEmbedOwner(self, process)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsPoint {
    pub x: i32,
    pub y: i32,
}
#[test]
fn bindgen_test_layout_EsPoint() {
    assert_eq!(
        ::std::mem::size_of::<EsPoint>(),
        8usize,
        concat!("Size of: ", stringify!(EsPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<EsPoint>(),
        4usize,
        concat!("Alignment of ", stringify!(EsPoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsPoint>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsPoint),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsPoint>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EsPoint),
            "::",
            stringify!(y)
        )
    );
}
pub const EsWindowStyle_ES_WINDOW_NORMAL: EsWindowStyle = 0;
pub const EsWindowStyle_ES_WINDOW_CONTAINER: EsWindowStyle = 1;
pub const EsWindowStyle_ES_WINDOW_MENU: EsWindowStyle = 2;
pub const EsWindowStyle_ES_WINDOW_TIP: EsWindowStyle = 3;
pub const EsWindowStyle_ES_WINDOW_PLAIN: EsWindowStyle = 4;
pub const EsWindowStyle_ES_WINDOW_INSPECTOR: EsWindowStyle = 5;
pub type EsWindowStyle = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsPaintTarget {
    pub bits: *mut ::std::os::raw::c_void,
    pub width: u32,
    pub height: u32,
    pub stride: u32,
    pub fullAlpha: bool,
    pub readOnly: bool,
    pub fromBitmap: bool,
    pub forWindowManager: bool,
}
#[test]
fn bindgen_test_layout_EsPaintTarget() {
    assert_eq!(
        ::std::mem::size_of::<EsPaintTarget>(),
        24usize,
        concat!("Size of: ", stringify!(EsPaintTarget))
    );
    assert_eq!(
        ::std::mem::align_of::<EsPaintTarget>(),
        8usize,
        concat!("Alignment of ", stringify!(EsPaintTarget))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsPaintTarget>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsPaintTarget),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsPaintTarget>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsPaintTarget),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsPaintTarget>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(EsPaintTarget),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsPaintTarget>())).stride as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsPaintTarget),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsPaintTarget>())).fullAlpha as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(EsPaintTarget),
            "::",
            stringify!(fullAlpha)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsPaintTarget>())).readOnly as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(EsPaintTarget),
            "::",
            stringify!(readOnly)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsPaintTarget>())).fromBitmap as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(EsPaintTarget),
            "::",
            stringify!(fromBitmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsPaintTarget>())).forWindowManager as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(EsPaintTarget),
            "::",
            stringify!(forWindowManager)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Surface {
    pub _base: EsPaintTarget,
    pub modifiedRegion: EsRectangle,
}
#[test]
fn bindgen_test_layout_Surface() {
    assert_eq!(
        ::std::mem::size_of::<Surface>(),
        40usize,
        concat!("Size of: ", stringify!(Surface))
    );
    assert_eq!(
        ::std::mem::align_of::<Surface>(),
        8usize,
        concat!("Alignment of ", stringify!(Surface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Surface>())).modifiedRegion as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Surface),
            "::",
            stringify!(modifiedRegion)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7Surface6ResizeEmmjb"]
    pub fn Surface_Resize(
        this: *mut Surface,
        newResX: size_t,
        newResY: size_t,
        clearColor: u32,
        copyOldBits: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN7Surface4CopyEPS_7EsPoint11EsRectangleb"]
    pub fn Surface_Copy(
        this: *mut Surface,
        source: *mut Surface,
        destinationPoint: EsPoint,
        sourceRegion: EsRectangle,
        addToModifiedRegion: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7Surface4DrawEPS_11EsRectangleiit"]
    pub fn Surface_Draw(
        this: *mut Surface,
        source: *mut Surface,
        destinationRegion: EsRectangle,
        sourceX: ::std::os::raw::c_int,
        sourceY: ::std::os::raw::c_int,
        alpha: u16,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7Surface11BlendWindowEPS_7EsPoint11EsRectangleihS2_"]
    pub fn Surface_BlendWindow(
        this: *mut Surface,
        source: *mut Surface,
        destinationPoint: EsPoint,
        sourceRegion: EsRectangle,
        material: ::std::os::raw::c_int,
        alpha: u8,
        materialRegion: EsRectangle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7Surface4BlurE11EsRectangleS0_"]
    pub fn Surface_Blur(this: *mut Surface, region: EsRectangle, clip: EsRectangle);
}
extern "C" {
    #[link_name = "\u{1}_ZN7Surface7SetBitsEPKvm11EsRectangle"]
    pub fn Surface_SetBits(
        this: *mut Surface,
        bits: *const ::std::os::raw::c_void,
        stride: usize,
        region: EsRectangle,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7Surface6ScrollE11EsRectanglelb"]
    pub fn Surface_Scroll(this: *mut Surface, region: EsRectangle, delta: isize, vertical: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN7Surface18CreateCursorShadowEPS_"]
    pub fn Surface_CreateCursorShadow(this: *mut Surface, source: *mut Surface);
}
impl Surface {
    #[inline]
    pub unsafe fn Resize(
        &mut self,
        newResX: size_t,
        newResY: size_t,
        clearColor: u32,
        copyOldBits: bool,
    ) -> bool {
        Surface_Resize(self, newResX, newResY, clearColor, copyOldBits)
    }
    #[inline]
    pub unsafe fn Copy(
        &mut self,
        source: *mut Surface,
        destinationPoint: EsPoint,
        sourceRegion: EsRectangle,
        addToModifiedRegion: bool,
    ) {
        Surface_Copy(
            self,
            source,
            destinationPoint,
            sourceRegion,
            addToModifiedRegion,
        )
    }
    #[inline]
    pub unsafe fn Draw(
        &mut self,
        source: *mut Surface,
        destinationRegion: EsRectangle,
        sourceX: ::std::os::raw::c_int,
        sourceY: ::std::os::raw::c_int,
        alpha: u16,
    ) {
        Surface_Draw(self, source, destinationRegion, sourceX, sourceY, alpha)
    }
    #[inline]
    pub unsafe fn BlendWindow(
        &mut self,
        source: *mut Surface,
        destinationPoint: EsPoint,
        sourceRegion: EsRectangle,
        material: ::std::os::raw::c_int,
        alpha: u8,
        materialRegion: EsRectangle,
    ) {
        Surface_BlendWindow(
            self,
            source,
            destinationPoint,
            sourceRegion,
            material,
            alpha,
            materialRegion,
        )
    }
    #[inline]
    pub unsafe fn Blur(&mut self, region: EsRectangle, clip: EsRectangle) {
        Surface_Blur(self, region, clip)
    }
    #[inline]
    pub unsafe fn SetBits(
        &mut self,
        bits: *const ::std::os::raw::c_void,
        stride: usize,
        region: EsRectangle,
    ) {
        Surface_SetBits(self, bits, stride, region)
    }
    #[inline]
    pub unsafe fn Scroll(&mut self, region: EsRectangle, delta: isize, vertical: bool) {
        Surface_Scroll(self, region, delta, vertical)
    }
    #[inline]
    pub unsafe fn CreateCursorShadow(&mut self, source: *mut Surface) {
        Surface_CreateCursorShadow(self, source)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Pipe {
    pub buffer: [::std::os::raw::c_char; 4096usize],
    pub writers: size_t,
    pub readers: size_t,
    pub writePosition: usize,
    pub readPosition: usize,
    pub unreadData: usize,
    pub canWrite: KEvent,
    pub canRead: KEvent,
    pub mutex: KMutex,
}
#[test]
fn bindgen_test_layout_Pipe() {
    assert_eq!(
        ::std::mem::size_of::<Pipe>(),
        4264usize,
        concat!("Size of: ", stringify!(Pipe))
    );
    assert_eq!(
        ::std::mem::align_of::<Pipe>(),
        8usize,
        concat!("Alignment of ", stringify!(Pipe))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pipe>())).buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Pipe),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pipe>())).writers as *const _ as usize },
        4096usize,
        concat!(
            "Offset of field: ",
            stringify!(Pipe),
            "::",
            stringify!(writers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pipe>())).readers as *const _ as usize },
        4104usize,
        concat!(
            "Offset of field: ",
            stringify!(Pipe),
            "::",
            stringify!(readers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pipe>())).writePosition as *const _ as usize },
        4112usize,
        concat!(
            "Offset of field: ",
            stringify!(Pipe),
            "::",
            stringify!(writePosition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pipe>())).readPosition as *const _ as usize },
        4120usize,
        concat!(
            "Offset of field: ",
            stringify!(Pipe),
            "::",
            stringify!(readPosition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pipe>())).unreadData as *const _ as usize },
        4128usize,
        concat!(
            "Offset of field: ",
            stringify!(Pipe),
            "::",
            stringify!(unreadData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pipe>())).canWrite as *const _ as usize },
        4136usize,
        concat!(
            "Offset of field: ",
            stringify!(Pipe),
            "::",
            stringify!(canWrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pipe>())).canRead as *const _ as usize },
        4184usize,
        concat!(
            "Offset of field: ",
            stringify!(Pipe),
            "::",
            stringify!(canRead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pipe>())).mutex as *const _ as usize },
        4232usize,
        concat!(
            "Offset of field: ",
            stringify!(Pipe),
            "::",
            stringify!(mutex)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Pipe6AccessEPvmbb"]
    pub fn Pipe_Access(
        this: *mut Pipe,
        buffer: *mut ::std::os::raw::c_void,
        bytes: size_t,
        write: bool,
        userBlockRequest: bool,
    ) -> size_t;
}
impl Pipe {
    #[inline]
    pub unsafe fn Access(
        &mut self,
        buffer: *mut ::std::os::raw::c_void,
        bytes: size_t,
        write: bool,
        userBlockRequest: bool,
    ) -> size_t {
        Pipe_Access(self, buffer, bytes, write, userBlockRequest)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsAnalogInput {
    pub x: u8,
    pub y: u8,
    pub z: u8,
}
#[test]
fn bindgen_test_layout_EsAnalogInput() {
    assert_eq!(
        ::std::mem::size_of::<EsAnalogInput>(),
        3usize,
        concat!("Size of: ", stringify!(EsAnalogInput))
    );
    assert_eq!(
        ::std::mem::align_of::<EsAnalogInput>(),
        1usize,
        concat!("Alignment of ", stringify!(EsAnalogInput))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsAnalogInput>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsAnalogInput),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsAnalogInput>())).y as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(EsAnalogInput),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsAnalogInput>())).z as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(EsAnalogInput),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsGameControllerState {
    pub id: EsObjectID,
    pub buttonCount: u8,
    pub analogCount: u8,
    pub directionalPad: u8,
    pub buttons: u32,
    pub analog: [EsAnalogInput; 8usize],
}
#[test]
fn bindgen_test_layout_EsGameControllerState() {
    assert_eq!(
        ::std::mem::size_of::<EsGameControllerState>(),
        40usize,
        concat!("Size of: ", stringify!(EsGameControllerState))
    );
    assert_eq!(
        ::std::mem::align_of::<EsGameControllerState>(),
        8usize,
        concat!("Alignment of ", stringify!(EsGameControllerState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsGameControllerState>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsGameControllerState),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsGameControllerState>())).buttonCount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EsGameControllerState),
            "::",
            stringify!(buttonCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsGameControllerState>())).analogCount as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(EsGameControllerState),
            "::",
            stringify!(analogCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsGameControllerState>())).directionalPad as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(EsGameControllerState),
            "::",
            stringify!(directionalPad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsGameControllerState>())).buttons as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(EsGameControllerState),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsGameControllerState>())).analog as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EsGameControllerState),
            "::",
            stringify!(analog)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WindowManager {
    pub initialised: bool,
    pub windows: u64,
    pub embeddedWindows: u64,
    pub pressedWindow: *mut Window,
    pub activeWindow: *mut Window,
    pub hoverWindow: *mut Window,
    pub mutex: KMutex,
    pub windowsToCloseEvent: KEvent,
    pub currentWindowID: EsObjectID,
    pub inspectorWindowCount: size_t,
    pub pressedWindowButton: EsMessageType,
    pub cursorX: i32,
    pub cursorY: i32,
    pub cursorXPrecise: i32,
    pub cursorYPrecise: i32,
    pub lastButtons: u32,
    pub cursorSurface: Surface,
    pub cursorSwap: Surface,
    pub cursorTemporary: Surface,
    pub cursorImageOffsetX: ::std::os::raw::c_int,
    pub cursorImageOffsetY: ::std::os::raw::c_int,
    pub cursorID: usize,
    pub cursorShadow: bool,
    pub changedCursorImage: bool,
    pub cursorProperties: u32,
    pub numlock: bool,
    pub leftModifiers: u8,
    pub rightModifiers: u8,
    pub keysHeld: u16,
    pub maximumKeysHeld: u16,
    pub keysHeldBitSet: [u8; 64usize],
    pub eyedropObject: usize,
    pub eyedropping: bool,
    pub eyedropProcess: *mut Process,
    pub eyedropAvoidID: u64,
    pub eyedropCancelColor: u32,
    pub workArea: EsRectangle,
    pub deviceMutex: KMutex,
    pub hiDevices: u64,
    pub gameControllers: [EsGameControllerState; 16usize],
    pub gameControllerCount: size_t,
    pub gameControllerID: EsObjectID,
    pub resizeWindow: *mut Window,
    pub resizeReceivedBitsFromContainer: bool,
    pub resizeReceivedBitsFromEmbed: bool,
    pub resizeStartTimeStampMs: u64,
    pub resizeQueuedRectangle: EsRectangle,
    pub resizeQueued: bool,
    pub resizeSlow: bool,
}
#[test]
fn bindgen_test_layout_WindowManager() {
    assert_eq!(
        ::std::mem::size_of::<WindowManager>(),
        1184usize,
        concat!("Size of: ", stringify!(WindowManager))
    );
    assert_eq!(
        ::std::mem::align_of::<WindowManager>(),
        8usize,
        concat!("Alignment of ", stringify!(WindowManager))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).initialised as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(initialised)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).windows as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(windows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).embeddedWindows as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(embeddedWindows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).pressedWindow as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(pressedWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).activeWindow as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(activeWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).hoverWindow as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(hoverWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).mutex as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WindowManager>())).windowsToCloseEvent as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(windowsToCloseEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).currentWindowID as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(currentWindowID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WindowManager>())).inspectorWindowCount as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(inspectorWindowCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WindowManager>())).pressedWindowButton as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(pressedWindowButton)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).cursorX as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(cursorX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).cursorY as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(cursorY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).cursorXPrecise as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(cursorXPrecise)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).cursorYPrecise as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(cursorYPrecise)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).lastButtons as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(lastButtons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).cursorSurface as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(cursorSurface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).cursorSwap as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(cursorSwap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).cursorTemporary as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(cursorTemporary)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WindowManager>())).cursorImageOffsetX as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(cursorImageOffsetX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WindowManager>())).cursorImageOffsetY as *const _ as usize
        },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(cursorImageOffsetY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).cursorID as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(cursorID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).cursorShadow as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(cursorShadow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WindowManager>())).changedCursorImage as *const _ as usize
        },
        305usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(changedCursorImage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).cursorProperties as *const _ as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(cursorProperties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).numlock as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(numlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).leftModifiers as *const _ as usize },
        313usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(leftModifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).rightModifiers as *const _ as usize },
        314usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(rightModifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).keysHeld as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(keysHeld)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).maximumKeysHeld as *const _ as usize },
        318usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(maximumKeysHeld)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).keysHeldBitSet as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(keysHeldBitSet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).eyedropObject as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(eyedropObject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).eyedropping as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(eyedropping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).eyedropProcess as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(eyedropProcess)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).eyedropAvoidID as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(eyedropAvoidID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WindowManager>())).eyedropCancelColor as *const _ as usize
        },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(eyedropCancelColor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).workArea as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(workArea)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).deviceMutex as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(deviceMutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).hiDevices as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(hiDevices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).gameControllers as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(gameControllers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WindowManager>())).gameControllerCount as *const _ as usize
        },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(gameControllerCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).gameControllerID as *const _ as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(gameControllerID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).resizeWindow as *const _ as usize },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(resizeWindow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WindowManager>())).resizeReceivedBitsFromContainer as *const _
                as usize
        },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(resizeReceivedBitsFromContainer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WindowManager>())).resizeReceivedBitsFromEmbed as *const _
                as usize
        },
        1145usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(resizeReceivedBitsFromEmbed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WindowManager>())).resizeStartTimeStampMs as *const _ as usize
        },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(resizeStartTimeStampMs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WindowManager>())).resizeQueuedRectangle as *const _ as usize
        },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(resizeQueuedRectangle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).resizeQueued as *const _ as usize },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(resizeQueued)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowManager>())).resizeSlow as *const _ as usize },
        1177usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowManager),
            "::",
            stringify!(resizeSlow)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13WindowManager12CreateWindowEP7ProcessPv13EsWindowStyle"]
    pub fn WindowManager_CreateWindow(
        this: *mut WindowManager,
        process: *mut Process,
        apiWindow: *mut ::std::os::raw::c_void,
        style: EsWindowStyle,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN13WindowManager20CreateEmbeddedWindowEP7ProcessPv"]
    pub fn WindowManager_CreateEmbeddedWindow(
        this: *mut WindowManager,
        process: *mut Process,
        apiWindow: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN13WindowManager20FindWindowAtPositionEiim"]
    pub fn WindowManager_FindWindowAtPosition(
        this: *mut WindowManager,
        cursorX: ::std::os::raw::c_int,
        cursorY: ::std::os::raw::c_int,
        exclude: EsObjectID,
    ) -> *mut Window;
}
extern "C" {
    #[link_name = "\u{1}_ZN13WindowManager10InitialiseEv"]
    pub fn WindowManager_Initialise(this: *mut WindowManager);
}
extern "C" {
    #[link_name = "\u{1}_ZN13WindowManager10MoveCursorEll"]
    pub fn WindowManager_MoveCursor(this: *mut WindowManager, xMovement: i64, yMovement: i64);
}
extern "C" {
    #[link_name = "\u{1}_ZN13WindowManager11ClickCursorEj"]
    pub fn WindowManager_ClickCursor(this: *mut WindowManager, buttons: u32);
}
extern "C" {
    #[link_name = "\u{1}_ZN13WindowManager11ScrollWheelEii"]
    pub fn WindowManager_ScrollWheel(this: *mut WindowManager, dx: i32, dy: i32);
}
extern "C" {
    #[link_name = "\u{1}_ZN13WindowManager8PressKeyEj"]
    pub fn WindowManager_PressKey(this: *mut WindowManager, scancode: u32);
}
extern "C" {
    #[link_name = "\u{1}_ZN13WindowManager6RedrawE7EsPointiiP6Windowib"]
    pub fn WindowManager_Redraw(
        this: *mut WindowManager,
        position: EsPoint,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        except: *mut Window,
        startingAt: ::std::os::raw::c_int,
        addToModifiedRegion: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13WindowManager14ActivateWindowEP6Window"]
    pub fn WindowManager_ActivateWindow(this: *mut WindowManager, window: *mut Window) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN13WindowManager10HideWindowEP6Window"]
    pub fn WindowManager_HideWindow(this: *mut WindowManager, window: *mut Window);
}
extern "C" {
    #[link_name = "\u{1}_ZN13WindowManager20FindWindowToActivateEP6Window"]
    pub fn WindowManager_FindWindowToActivate(
        this: *mut WindowManager,
        excluding: *mut Window,
    ) -> *mut Window;
}
extern "C" {
    #[link_name = "\u{1}_ZN13WindowManager19GetActivationZIndexEv"]
    pub fn WindowManager_GetActivationZIndex(this: *mut WindowManager) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZN13WindowManager17ChangeWindowDepthEP6Windowbl"]
    pub fn WindowManager_ChangeWindowDepth(
        this: *mut WindowManager,
        window: *mut Window,
        alwaysRedraw: bool,
        newZDepth: isize,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13WindowManager15FindWindowDepthEP6Window"]
    pub fn WindowManager_FindWindowDepth(this: *mut WindowManager, window: *mut Window) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_ZN13WindowManager10CloseMenusEv"]
    pub fn WindowManager_CloseMenus(this: *mut WindowManager) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN13WindowManager12StartEyedropEmP6Windowj"]
    pub fn WindowManager_StartEyedrop(
        this: *mut WindowManager,
        object: usize,
        avoid: *mut Window,
        cancelColor: u32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13WindowManager10EndEyedropEb"]
    pub fn WindowManager_EndEyedrop(this: *mut WindowManager, cancelled: bool);
}
impl WindowManager {
    #[inline]
    pub unsafe fn CreateWindow(
        &mut self,
        process: *mut Process,
        apiWindow: *mut ::std::os::raw::c_void,
        style: EsWindowStyle,
    ) -> *mut ::std::os::raw::c_void {
        WindowManager_CreateWindow(self, process, apiWindow, style)
    }
    #[inline]
    pub unsafe fn CreateEmbeddedWindow(
        &mut self,
        process: *mut Process,
        apiWindow: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void {
        WindowManager_CreateEmbeddedWindow(self, process, apiWindow)
    }
    #[inline]
    pub unsafe fn FindWindowAtPosition(
        &mut self,
        cursorX: ::std::os::raw::c_int,
        cursorY: ::std::os::raw::c_int,
        exclude: EsObjectID,
    ) -> *mut Window {
        WindowManager_FindWindowAtPosition(self, cursorX, cursorY, exclude)
    }
    #[inline]
    pub unsafe fn Initialise(&mut self) {
        WindowManager_Initialise(self)
    }
    #[inline]
    pub unsafe fn MoveCursor(&mut self, xMovement: i64, yMovement: i64) {
        WindowManager_MoveCursor(self, xMovement, yMovement)
    }
    #[inline]
    pub unsafe fn ClickCursor(&mut self, buttons: u32) {
        WindowManager_ClickCursor(self, buttons)
    }
    #[inline]
    pub unsafe fn ScrollWheel(&mut self, dx: i32, dy: i32) {
        WindowManager_ScrollWheel(self, dx, dy)
    }
    #[inline]
    pub unsafe fn PressKey(&mut self, scancode: u32) {
        WindowManager_PressKey(self, scancode)
    }
    #[inline]
    pub unsafe fn Redraw(
        &mut self,
        position: EsPoint,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        except: *mut Window,
        startingAt: ::std::os::raw::c_int,
        addToModifiedRegion: bool,
    ) {
        WindowManager_Redraw(
            self,
            position,
            width,
            height,
            except,
            startingAt,
            addToModifiedRegion,
        )
    }
    #[inline]
    pub unsafe fn ActivateWindow(&mut self, window: *mut Window) -> bool {
        WindowManager_ActivateWindow(self, window)
    }
    #[inline]
    pub unsafe fn HideWindow(&mut self, window: *mut Window) {
        WindowManager_HideWindow(self, window)
    }
    #[inline]
    pub unsafe fn FindWindowToActivate(&mut self, excluding: *mut Window) -> *mut Window {
        WindowManager_FindWindowToActivate(self, excluding)
    }
    #[inline]
    pub unsafe fn GetActivationZIndex(&mut self) -> usize {
        WindowManager_GetActivationZIndex(self)
    }
    #[inline]
    pub unsafe fn ChangeWindowDepth(
        &mut self,
        window: *mut Window,
        alwaysRedraw: bool,
        newZDepth: isize,
    ) {
        WindowManager_ChangeWindowDepth(self, window, alwaysRedraw, newZDepth)
    }
    #[inline]
    pub unsafe fn FindWindowDepth(&mut self, window: *mut Window) -> isize {
        WindowManager_FindWindowDepth(self, window)
    }
    #[inline]
    pub unsafe fn CloseMenus(&mut self) -> bool {
        WindowManager_CloseMenus(self)
    }
    #[inline]
    pub unsafe fn StartEyedrop(&mut self, object: usize, avoid: *mut Window, cancelColor: u32) {
        WindowManager_StartEyedrop(self, object, avoid, cancelColor)
    }
    #[inline]
    pub unsafe fn EndEyedrop(&mut self, cancelled: bool) {
        WindowManager_EndEyedrop(self, cancelled)
    }
}
extern "C" {
    pub static mut windowManager: WindowManager;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Window {
    pub style: EsWindowStyle,
    pub solidOffsets: EsRectangle,
    pub embedInsets: EsRectangle,
    pub solid: bool,
    pub noClickActivate: bool,
    pub hidden: bool,
    pub isMaximised: bool,
    pub alwaysOnTop: bool,
    pub hoveringOverEmbed: bool,
    pub activationClick: bool,
    pub noBringToFront: bool,
    pub closed: bool,
    pub surface: Surface,
    pub opaqueBounds: EsRectangle,
    pub blurBounds: EsRectangle,
    pub alpha: u8,
    pub material: u8,
    pub owner: *mut Process,
    pub apiWindow: *mut ::std::os::raw::c_void,
    pub embed: *mut EmbeddedWindow,
    pub handles: u32,
    pub id: EsObjectID,
    pub position: EsPoint,
    pub width: size_t,
    pub height: size_t,
}
#[test]
fn bindgen_test_layout_Window() {
    assert_eq!(
        ::std::mem::size_of::<Window>(),
        192usize,
        concat!("Size of: ", stringify!(Window))
    );
    assert_eq!(
        ::std::mem::align_of::<Window>(),
        8usize,
        concat!("Alignment of ", stringify!(Window))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).style as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(style)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).solidOffsets as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(solidOffsets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).embedInsets as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(embedInsets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).solid as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(solid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).noClickActivate as *const _ as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(noClickActivate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).hidden as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(hidden)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).isMaximised as *const _ as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(isMaximised)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).alwaysOnTop as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(alwaysOnTop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).hoveringOverEmbed as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(hoveringOverEmbed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).activationClick as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(activationClick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).noBringToFront as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(noBringToFront)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).closed as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(closed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).surface as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).opaqueBounds as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(opaqueBounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).blurBounds as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(blurBounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).alpha as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(alpha)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).material as *const _ as usize },
        121usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(material)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).owner as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).apiWindow as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(apiWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).embed as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(embed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).handles as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).id as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).position as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).width as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Window>())).height as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(Window),
            "::",
            stringify!(height)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6Window6UpdateEP11EsRectangleb"]
    pub fn Window_Update(this: *mut Window, region: *mut EsRectangle, addToModifiedRegion: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN6Window12UpdateDirectEPvm11EsRectangle"]
    pub fn Window_UpdateDirect(
        this: *mut Window,
        bits: *mut ::std::os::raw::c_void,
        stride: usize,
        region: EsRectangle,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6Window5CloseEv"]
    pub fn Window_Close(this: *mut Window);
}
extern "C" {
    #[link_name = "\u{1}_ZN6Window4MoveE11EsRectanglej"]
    pub fn Window_Move(this: *mut Window, newBounds: EsRectangle, flags: u32) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6Window8SetEmbedEP14EmbeddedWindow"]
    pub fn Window_SetEmbed(this: *mut Window, window: *mut EmbeddedWindow);
}
extern "C" {
    #[link_name = "\u{1}_ZN6Window9IsVisibleEv"]
    pub fn Window_IsVisible(this: *mut Window) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6Window11ResizeEmbedEv"]
    pub fn Window_ResizeEmbed(this: *mut Window);
}
impl Window {
    #[inline]
    pub unsafe fn Update(&mut self, region: *mut EsRectangle, addToModifiedRegion: bool) {
        Window_Update(self, region, addToModifiedRegion)
    }
    #[inline]
    pub unsafe fn UpdateDirect(
        &mut self,
        bits: *mut ::std::os::raw::c_void,
        stride: usize,
        region: EsRectangle,
    ) -> bool {
        Window_UpdateDirect(self, bits, stride, region)
    }
    #[inline]
    pub unsafe fn Close(&mut self) {
        Window_Close(self)
    }
    #[inline]
    pub unsafe fn Move(&mut self, newBounds: EsRectangle, flags: u32) -> bool {
        Window_Move(self, newBounds, flags)
    }
    #[inline]
    pub unsafe fn SetEmbed(&mut self, window: *mut EmbeddedWindow) {
        Window_SetEmbed(self, window)
    }
    #[inline]
    pub unsafe fn IsVisible(&mut self) -> bool {
        Window_IsVisible(self)
    }
    #[inline]
    pub unsafe fn ResizeEmbed(&mut self) {
        Window_ResizeEmbed(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetTask {
    pub callback: ::std::option::Option<
        unsafe extern "C" fn(task: *mut NetTask, receivedData: *mut ::std::os::raw::c_void),
    >,
    pub interface: *mut NetInterface,
    pub index: u16,
    pub error: i16,
    pub step: u8,
    pub completed: bool,
}
#[test]
fn bindgen_test_layout_NetTask() {
    assert_eq!(
        ::std::mem::size_of::<NetTask>(),
        24usize,
        concat!("Size of: ", stringify!(NetTask))
    );
    assert_eq!(
        ::std::mem::align_of::<NetTask>(),
        8usize,
        concat!("Alignment of ", stringify!(NetTask))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetTask>())).callback as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NetTask),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetTask>())).interface as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NetTask),
            "::",
            stringify!(interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetTask>())).index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NetTask),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetTask>())).error as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(NetTask),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetTask>())).step as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NetTask),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetTask>())).completed as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(NetTask),
            "::",
            stringify!(completed)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KMACAddress {
    pub d: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_KMACAddress() {
    assert_eq!(
        ::std::mem::size_of::<KMACAddress>(),
        6usize,
        concat!("Size of: ", stringify!(KMACAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<KMACAddress>(),
        1usize,
        concat!("Alignment of ", stringify!(KMACAddress))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KMACAddress>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KMACAddress),
            "::",
            stringify!(d)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EsAddress {
    pub __bindgen_anon_1: EsAddress__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EsAddress__bindgen_ty_1 {
    pub __bindgen_anon_1: EsAddress__bindgen_ty_1__bindgen_ty_1,
    pub d: [u8; 20usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsAddress__bindgen_ty_1__bindgen_ty_1 {
    pub ipv4: u32,
    pub port: u16,
}
#[test]
fn bindgen_test_layout_EsAddress__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<EsAddress__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(EsAddress__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<EsAddress__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(EsAddress__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsAddress__bindgen_ty_1__bindgen_ty_1>())).ipv4 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsAddress__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ipv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EsAddress__bindgen_ty_1__bindgen_ty_1>())).port as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EsAddress__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(port)
        )
    );
}
#[test]
fn bindgen_test_layout_EsAddress__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<EsAddress__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(EsAddress__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<EsAddress__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(EsAddress__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsAddress__bindgen_ty_1>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsAddress__bindgen_ty_1),
            "::",
            stringify!(d)
        )
    );
}
#[test]
fn bindgen_test_layout_EsAddress() {
    assert_eq!(
        ::std::mem::size_of::<EsAddress>(),
        20usize,
        concat!("Size of: ", stringify!(EsAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<EsAddress>(),
        4usize,
        concat!("Alignment of ", stringify!(EsAddress))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetTCPConnectionTask {
    pub _base: NetTask,
    pub sendUnacknowledged: u32,
    pub sendNext: u32,
    pub sendWindow: u32,
    pub receiveNext: u32,
    pub receiveWindow: u16,
    pub initialSend: u32,
    pub initialReceive: u32,
    pub finSequence: u32,
    pub sendWL1: u32,
    pub sendWL2: u32,
    pub destinationMAC: KMACAddress,
}
#[test]
fn bindgen_test_layout_NetTCPConnectionTask() {
    assert_eq!(
        ::std::mem::size_of::<NetTCPConnectionTask>(),
        72usize,
        concat!("Size of: ", stringify!(NetTCPConnectionTask))
    );
    assert_eq!(
        ::std::mem::align_of::<NetTCPConnectionTask>(),
        8usize,
        concat!("Alignment of ", stringify!(NetTCPConnectionTask))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NetTCPConnectionTask>())).sendUnacknowledged as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NetTCPConnectionTask),
            "::",
            stringify!(sendUnacknowledged)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetTCPConnectionTask>())).sendNext as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(NetTCPConnectionTask),
            "::",
            stringify!(sendNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetTCPConnectionTask>())).sendWindow as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NetTCPConnectionTask),
            "::",
            stringify!(sendWindow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NetTCPConnectionTask>())).receiveNext as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(NetTCPConnectionTask),
            "::",
            stringify!(receiveNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NetTCPConnectionTask>())).receiveWindow as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NetTCPConnectionTask),
            "::",
            stringify!(receiveWindow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NetTCPConnectionTask>())).initialSend as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(NetTCPConnectionTask),
            "::",
            stringify!(initialSend)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NetTCPConnectionTask>())).initialReceive as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NetTCPConnectionTask),
            "::",
            stringify!(initialReceive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NetTCPConnectionTask>())).finSequence as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(NetTCPConnectionTask),
            "::",
            stringify!(finSequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetTCPConnectionTask>())).sendWL1 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NetTCPConnectionTask),
            "::",
            stringify!(sendWL1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetTCPConnectionTask>())).sendWL2 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(NetTCPConnectionTask),
            "::",
            stringify!(sendWL2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NetTCPConnectionTask>())).destinationMAC as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NetTCPConnectionTask),
            "::",
            stringify!(destinationMAC)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NetConnection {
    pub task: NetTCPConnectionTask,
    pub bufferRegion: *mut MMSharedRegion,
    pub sendBuffer: *mut u8,
    pub receiveBuffer: *mut u8,
    pub sendBufferBytes: size_t,
    pub receiveBufferBytes: size_t,
    pub sendReadPointer: usize,
    pub sendWritePointer: usize,
    pub receiveWritePointer: usize,
    pub receiveReadPointer: usize,
    pub receivedData: RangeSet,
    pub address: EsAddress,
    pub mutex: KMutex,
    pub handles: usize,
}
#[test]
fn bindgen_test_layout_NetConnection() {
    assert_eq!(
        ::std::mem::size_of::<NetConnection>(),
        224usize,
        concat!("Size of: ", stringify!(NetConnection))
    );
    assert_eq!(
        ::std::mem::align_of::<NetConnection>(),
        8usize,
        concat!("Alignment of ", stringify!(NetConnection))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetConnection>())).task as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NetConnection),
            "::",
            stringify!(task)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetConnection>())).bufferRegion as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(NetConnection),
            "::",
            stringify!(bufferRegion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetConnection>())).sendBuffer as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(NetConnection),
            "::",
            stringify!(sendBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetConnection>())).receiveBuffer as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(NetConnection),
            "::",
            stringify!(receiveBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetConnection>())).sendBufferBytes as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(NetConnection),
            "::",
            stringify!(sendBufferBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NetConnection>())).receiveBufferBytes as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(NetConnection),
            "::",
            stringify!(receiveBufferBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetConnection>())).sendReadPointer as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(NetConnection),
            "::",
            stringify!(sendReadPointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetConnection>())).sendWritePointer as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(NetConnection),
            "::",
            stringify!(sendWritePointer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NetConnection>())).receiveWritePointer as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(NetConnection),
            "::",
            stringify!(receiveWritePointer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NetConnection>())).receiveReadPointer as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(NetConnection),
            "::",
            stringify!(receiveReadPointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetConnection>())).receivedData as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(NetConnection),
            "::",
            stringify!(receivedData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetConnection>())).address as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(NetConnection),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetConnection>())).mutex as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(NetConnection),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetConnection>())).handles as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(NetConnection),
            "::",
            stringify!(handles)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_Z17NetConnectionOpenP9EsAddressmmj"]
    pub fn NetConnectionOpen(
        address: *mut EsAddress,
        sendBufferBytes: size_t,
        receiveBufferBytes: size_t,
        flags: u32,
    ) -> *mut NetConnection;
}
extern "C" {
    #[link_name = "\u{1}_Z18NetConnectionCloseP13NetConnection"]
    pub fn NetConnectionClose(connection: *mut NetConnection);
}
extern "C" {
    #[link_name = "\u{1}_Z19NetConnectionNotifyP13NetConnectionmm"]
    pub fn NetConnectionNotify(
        connection: *mut NetConnection,
        sendWritePointer: usize,
        receiveReadPointer: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z20NetConnectionDestroyP13NetConnection"]
    pub fn NetConnectionDestroy(connection: *mut NetConnection);
}
extern "C" {
    #[link_name = "\u{1}_Z13ProcessRemoveP7Process"]
    pub fn ProcessRemove(process: *mut Process);
}
extern "C" {
    #[link_name = "\u{1}_Z11MMUnreserveP7MMSpaceP8MMRegionbb"]
    pub fn MMUnreserve(
        space: *mut MMSpace,
        remove: *mut MMRegion,
        unmapPages: bool,
        guardRegion: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z10ThreadKillP10KAsyncTask"]
    pub fn ThreadKill(task: *mut KAsyncTask);
}
extern "C" {
    #[link_name = "\u{1}_Z18KRegisterAsyncTaskP10KAsyncTaskPFvS0_E"]
    pub fn KRegisterAsyncTask(task: *mut KAsyncTask, callback: KAsyncTaskCallback);
}
extern "C" {
    #[link_name = "\u{1}_Z15ThreadTerminateP6Thread"]
    pub fn ThreadTerminate(thread: *mut Thread);
}
extern "C" {
    #[link_name = "\u{1}_Z20MMSpaceOpenReferenceP7MMSpace"]
    pub fn MMSpaceOpenReference(space: *mut MMSpace);
}
extern "C" {
    #[link_name = "\u{1}_Z14MMSpaceDestroyP7MMSpace"]
    pub fn MMSpaceDestroy(space: *mut MMSpace);
}
extern "C" {
    #[link_name = "\u{1}_Z18DesktopSendMessageP20_EsMessageWithObject"]
    pub fn DesktopSendMessage(message: *mut _EsMessageWithObject);
}
extern "C" {
    #[link_name = "\u{1}_Z9MMReserveP7MMSpacemjmb"]
    pub fn MMReserve(
        space: *mut MMSpace,
        bytes: size_t,
        flags: ::std::os::raw::c_uint,
        forcedAddress: usize,
        generateGuardPages: bool,
    ) -> *mut MMRegion;
}
extern "C" {
    #[link_name = "\u{1}_Z30MMPhysicalInsertFreePagesStartv"]
    pub fn MMPhysicalInsertFreePagesStart();
}
extern "C" {
    #[link_name = "\u{1}_Z28MMPhysicalInsertFreePagesEndv"]
    pub fn MMPhysicalInsertFreePagesEnd();
}
extern "C" {
    #[link_name = "\u{1}_Z20CCWriteBehindSectionv"]
    pub fn CCWriteBehindSection() -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z19CCWriteBehindThreadv"]
    pub fn CCWriteBehindThread();
}
extern "C" {
    #[link_name = "\u{1}_Z12CCInitialisev"]
    pub fn CCInitialise();
}
extern "C" {
    #[link_name = "\u{1}_Z6PMZeroPmmb"]
    pub fn PMZero(pages: *mut usize, pageCount: size_t, contiguous: bool);
}
extern "C" {
    pub static mut earlyZeroBuffer: [u8; 4096usize];
}
extern "C" {
    #[link_name = "\u{1}_Z26MMPhysicalInsertZeroedPagem"]
    pub fn MMPhysicalInsertZeroedPage(page: usize);
}
extern "C" {
    #[link_name = "\u{1}_Z16MMZeroPageThreadv"]
    pub fn MMZeroPageThread();
}
extern "C" {
    #[link_name = "\u{1}_Z23MMObjectCacheTrimThreadv"]
    pub fn MMObjectCacheTrimThread();
}
extern "C" {
    #[link_name = "\u{1}_Z15MMBalanceThreadv"]
    pub fn MMBalanceThread();
}
extern "C" {
    #[link_name = "\u{1}_Z18MMSharedOpenRegionPKcmmm"]
    pub fn MMSharedOpenRegion(
        name: *const ::std::os::raw::c_char,
        nameBytes: size_t,
        fallbackSizeBytes: size_t,
        flags: u64,
    ) -> *mut MMSharedRegion;
}
extern "C" {
    #[link_name = "\u{1}_Z11MMMapSharedP7MMSpaceP14MMSharedRegionmmjPv"]
    pub fn MMMapShared(
        space: *mut MMSpace,
        sharedRegion: *mut MMSharedRegion,
        offset: usize,
        bytes: size_t,
        additionalFlags: u32,
        baseAddress: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_Z12MMFaultRangemmj"]
    pub fn MMFaultRange(address: usize, byteCount: usize, flags: u32) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RootSystemDescriptorPointer {
    pub signature: u64,
    pub checksum: u8,
    pub OEMID: [::std::os::raw::c_char; 6usize],
    pub revision: u8,
    pub rsdtAddress: u32,
    pub length: u32,
    pub xsdtAddress: u64,
    pub extendedChecksum: u8,
    pub reserved: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_RootSystemDescriptorPointer() {
    assert_eq!(
        ::std::mem::size_of::<RootSystemDescriptorPointer>(),
        40usize,
        concat!("Size of: ", stringify!(RootSystemDescriptorPointer))
    );
    assert_eq!(
        ::std::mem::align_of::<RootSystemDescriptorPointer>(),
        8usize,
        concat!("Alignment of ", stringify!(RootSystemDescriptorPointer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RootSystemDescriptorPointer>())).signature as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RootSystemDescriptorPointer),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RootSystemDescriptorPointer>())).checksum as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RootSystemDescriptorPointer),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RootSystemDescriptorPointer>())).OEMID as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(RootSystemDescriptorPointer),
            "::",
            stringify!(OEMID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RootSystemDescriptorPointer>())).revision as *const _ as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(RootSystemDescriptorPointer),
            "::",
            stringify!(revision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RootSystemDescriptorPointer>())).rsdtAddress as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RootSystemDescriptorPointer),
            "::",
            stringify!(rsdtAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RootSystemDescriptorPointer>())).length as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RootSystemDescriptorPointer),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RootSystemDescriptorPointer>())).xsdtAddress as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RootSystemDescriptorPointer),
            "::",
            stringify!(xsdtAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RootSystemDescriptorPointer>())).extendedChecksum as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RootSystemDescriptorPointer),
            "::",
            stringify!(extendedChecksum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RootSystemDescriptorPointer>())).reserved as *const _ as usize
        },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(RootSystemDescriptorPointer),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACPIDescriptorTable {
    pub signature: u32,
    pub length: u32,
    pub id: u64,
    pub tableID: u64,
    pub oemRevision: u32,
    pub creatorID: u32,
    pub creatorRevision: u32,
}
#[test]
fn bindgen_test_layout__ACPIDescriptorTable() {
    assert_eq!(
        ::std::mem::size_of::<_ACPIDescriptorTable>(),
        40usize,
        concat!("Size of: ", stringify!(_ACPIDescriptorTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACPIDescriptorTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_ACPIDescriptorTable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACPIDescriptorTable>())).signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACPIDescriptorTable),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACPIDescriptorTable>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACPIDescriptorTable),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACPIDescriptorTable>())).id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACPIDescriptorTable),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACPIDescriptorTable>())).tableID as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACPIDescriptorTable),
            "::",
            stringify!(tableID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACPIDescriptorTable>())).oemRevision as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACPIDescriptorTable),
            "::",
            stringify!(oemRevision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACPIDescriptorTable>())).creatorID as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACPIDescriptorTable),
            "::",
            stringify!(creatorID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACPIDescriptorTable>())).creatorRevision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACPIDescriptorTable),
            "::",
            stringify!(creatorRevision)
        )
    );
}
pub type ACPIDescriptorTable = _ACPIDescriptorTable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MultipleAPICDescriptionTable {
    pub lapicAddress: u32,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout__MultipleAPICDescriptionTable() {
    assert_eq!(
        ::std::mem::size_of::<_MultipleAPICDescriptionTable>(),
        8usize,
        concat!("Size of: ", stringify!(_MultipleAPICDescriptionTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_MultipleAPICDescriptionTable>(),
        4usize,
        concat!("Alignment of ", stringify!(_MultipleAPICDescriptionTable))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MultipleAPICDescriptionTable>())).lapicAddress as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MultipleAPICDescriptionTable),
            "::",
            stringify!(lapicAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MultipleAPICDescriptionTable>())).flags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MultipleAPICDescriptionTable),
            "::",
            stringify!(flags)
        )
    );
}
pub type MultipleAPICDescriptionTable = _MultipleAPICDescriptionTable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArchCPU {
    pub processorID: u8,
    pub kernelProcessorID: u8,
    pub apicID: u8,
    pub bootProcessor: bool,
    pub kernelStack: *mut uint64_t_unaligned,
    pub local: *mut CPULocalStorage,
}
#[test]
fn bindgen_test_layout_ArchCPU() {
    assert_eq!(
        ::std::mem::size_of::<ArchCPU>(),
        24usize,
        concat!("Size of: ", stringify!(ArchCPU))
    );
    assert_eq!(
        ::std::mem::align_of::<ArchCPU>(),
        8usize,
        concat!("Alignment of ", stringify!(ArchCPU))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchCPU>())).processorID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchCPU),
            "::",
            stringify!(processorID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchCPU>())).kernelProcessorID as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchCPU),
            "::",
            stringify!(kernelProcessorID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchCPU>())).apicID as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchCPU),
            "::",
            stringify!(apicID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchCPU>())).bootProcessor as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchCPU),
            "::",
            stringify!(bootProcessor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchCPU>())).kernelStack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchCPU),
            "::",
            stringify!(kernelStack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchCPU>())).local as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchCPU),
            "::",
            stringify!(local)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACPIIoApic {
    pub id: u8,
    pub address: *mut u32,
    pub gsiBase: u32,
}
#[test]
fn bindgen_test_layout_ACPIIoApic() {
    assert_eq!(
        ::std::mem::size_of::<ACPIIoApic>(),
        24usize,
        concat!("Size of: ", stringify!(ACPIIoApic))
    );
    assert_eq!(
        ::std::mem::align_of::<ACPIIoApic>(),
        8usize,
        concat!("Alignment of ", stringify!(ACPIIoApic))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPIIoApic>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPIIoApic),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPIIoApic>())).address as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPIIoApic),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPIIoApic>())).gsiBase as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPIIoApic),
            "::",
            stringify!(gsiBase)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACPIInterruptOverride {
    pub sourceIRQ: u8,
    pub gsiNumber: u32,
    pub activeLow: bool,
    pub levelTriggered: bool,
}
#[test]
fn bindgen_test_layout_ACPIInterruptOverride() {
    assert_eq!(
        ::std::mem::size_of::<ACPIInterruptOverride>(),
        12usize,
        concat!("Size of: ", stringify!(ACPIInterruptOverride))
    );
    assert_eq!(
        ::std::mem::align_of::<ACPIInterruptOverride>(),
        4usize,
        concat!("Alignment of ", stringify!(ACPIInterruptOverride))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPIInterruptOverride>())).sourceIRQ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPIInterruptOverride),
            "::",
            stringify!(sourceIRQ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPIInterruptOverride>())).gsiNumber as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPIInterruptOverride),
            "::",
            stringify!(gsiNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPIInterruptOverride>())).activeLow as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPIInterruptOverride),
            "::",
            stringify!(activeLow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ACPIInterruptOverride>())).levelTriggered as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPIInterruptOverride),
            "::",
            stringify!(levelTriggered)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACPILapicNMI {
    pub processor: u8,
    pub lintIndex: u8,
    pub activeLow: bool,
    pub levelTriggered: bool,
}
#[test]
fn bindgen_test_layout_ACPILapicNMI() {
    assert_eq!(
        ::std::mem::size_of::<ACPILapicNMI>(),
        4usize,
        concat!("Size of: ", stringify!(ACPILapicNMI))
    );
    assert_eq!(
        ::std::mem::align_of::<ACPILapicNMI>(),
        1usize,
        concat!("Alignment of ", stringify!(ACPILapicNMI))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPILapicNMI>())).processor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPILapicNMI),
            "::",
            stringify!(processor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPILapicNMI>())).lintIndex as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPILapicNMI),
            "::",
            stringify!(lintIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPILapicNMI>())).activeLow as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPILapicNMI),
            "::",
            stringify!(activeLow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPILapicNMI>())).levelTriggered as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPILapicNMI),
            "::",
            stringify!(levelTriggered)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACPI {
    pub processorCount: size_t,
    pub ioapicCount: size_t,
    pub interruptOverrideCount: size_t,
    pub lapicNMICount: size_t,
    pub processors: [ArchCPU; 256usize],
    pub ioApics: [ACPIIoApic; 16usize],
    pub interruptOverrides: [ACPIInterruptOverride; 256usize],
    pub lapicNMIs: [ACPILapicNMI; 32usize],
    pub rsdp: *mut RootSystemDescriptorPointer,
    pub madt: *mut ACPIDescriptorTable,
    pub lapicAddress: *mut u32,
    pub lapicTicksPerMs: size_t,
    pub ps2ControllerUnavailable: bool,
    pub vgaControllerUnavailable: bool,
    pub centuryRegisterIndex: u8,
    pub hpetBaseAddress: *mut u64,
    pub hpetPeriod: u64,
    pub computer: *mut KDevice,
}
#[test]
fn bindgen_test_layout_ACPI() {
    assert_eq!(
        ::std::mem::size_of::<ACPI>(),
        9824usize,
        concat!("Size of: ", stringify!(ACPI))
    );
    assert_eq!(
        ::std::mem::align_of::<ACPI>(),
        8usize,
        concat!("Alignment of ", stringify!(ACPI))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPI>())).processorCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPI),
            "::",
            stringify!(processorCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPI>())).ioapicCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPI),
            "::",
            stringify!(ioapicCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPI>())).interruptOverrideCount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPI),
            "::",
            stringify!(interruptOverrideCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPI>())).lapicNMICount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPI),
            "::",
            stringify!(lapicNMICount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPI>())).processors as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPI),
            "::",
            stringify!(processors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPI>())).ioApics as *const _ as usize },
        6176usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPI),
            "::",
            stringify!(ioApics)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPI>())).interruptOverrides as *const _ as usize },
        6560usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPI),
            "::",
            stringify!(interruptOverrides)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPI>())).lapicNMIs as *const _ as usize },
        9632usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPI),
            "::",
            stringify!(lapicNMIs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPI>())).rsdp as *const _ as usize },
        9760usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPI),
            "::",
            stringify!(rsdp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPI>())).madt as *const _ as usize },
        9768usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPI),
            "::",
            stringify!(madt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPI>())).lapicAddress as *const _ as usize },
        9776usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPI),
            "::",
            stringify!(lapicAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPI>())).lapicTicksPerMs as *const _ as usize },
        9784usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPI),
            "::",
            stringify!(lapicTicksPerMs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPI>())).ps2ControllerUnavailable as *const _ as usize },
        9792usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPI),
            "::",
            stringify!(ps2ControllerUnavailable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPI>())).vgaControllerUnavailable as *const _ as usize },
        9793usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPI),
            "::",
            stringify!(vgaControllerUnavailable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPI>())).centuryRegisterIndex as *const _ as usize },
        9794usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPI),
            "::",
            stringify!(centuryRegisterIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPI>())).hpetBaseAddress as *const _ as usize },
        9800usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPI),
            "::",
            stringify!(hpetBaseAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPI>())).hpetPeriod as *const _ as usize },
        9808usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPI),
            "::",
            stringify!(hpetPeriod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ACPI>())).computer as *const _ as usize },
        9816usize,
        concat!(
            "Offset of field: ",
            stringify!(ACPI),
            "::",
            stringify!(computer)
        )
    );
}
extern "C" {
    pub static mut acpi: ACPI;
}
extern "C" {
    #[link_name = "\u{1}_Z22ACPIIoApicReadRegisterP10ACPIIoApicj"]
    pub fn ACPIIoApicReadRegister(apic: *mut ACPIIoApic, reg: u32) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_Z23ACPIIoApicWriteRegisterP10ACPIIoApicjj"]
    pub fn ACPIIoApicWriteRegister(apic: *mut ACPIIoApic, reg: u32, value: u32);
}
extern "C" {
    #[link_name = "\u{1}_Z14ACPICheckTablePK20_ACPIDescriptorTable"]
    pub fn ACPICheckTable(table: *const ACPIDescriptorTable);
}
extern "C" {
    #[link_name = "\u{1}_Z13MMMapPhysicalP7MMSpacemmm"]
    pub fn MMMapPhysical(
        space: *mut MMSpace,
        offset: usize,
        bytes: size_t,
        caching: u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_Z21ACPIMapPhysicalMemorymm"]
    pub fn ACPIMapPhysicalMemory(
        physicalAddress: usize,
        length: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_Z11ACPIGetRSDPv"]
    pub fn ACPIGetRSDP() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_Z27ACPIGetCenturyRegisterIndexv"]
    pub fn ACPIGetCenturyRegisterIndex() -> u8;
}
extern "C" {
    #[link_name = "\u{1}_Z30GetBootloaderInformationOffsetv"]
    pub fn GetBootloaderInformationOffset() -> usize;
}
extern "C" {
    #[link_name = "\u{1}_Z35ArchFindRootSystemDescriptorPointerv"]
    pub fn ArchFindRootSystemDescriptorPointer() -> usize;
}
extern "C" {
    #[link_name = "\u{1}_Z15ACPIParseTablesv"]
    pub fn ACPIParseTables();
}
extern "C" {
    #[link_name = "\u{1}_Z12KGetCPUCountv"]
    pub fn KGetCPUCount() -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_Z12KGetCPULocalm"]
    pub fn KGetCPULocal(index: usize) -> *mut CPULocalStorage;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InterruptContext {
    pub cr2: u64,
    pub ds: u64,
    pub fxsave: [u8; 528usize],
    pub _check: u64,
    pub cr8: u64,
    pub r15: u64,
    pub r14: u64,
    pub r13: u64,
    pub r12: u64,
    pub r11: u64,
    pub r10: u64,
    pub r9: u64,
    pub r8: u64,
    pub rbp: u64,
    pub rdi: u64,
    pub rsi: u64,
    pub rdx: u64,
    pub rcx: u64,
    pub rbx: u64,
    pub rax: u64,
    pub interruptNumber: u64,
    pub errorCode: u64,
    pub rip: u64,
    pub cs: u64,
    pub flags: u64,
    pub rsp: u64,
    pub ss: u64,
}
#[test]
fn bindgen_test_layout_InterruptContext() {
    assert_eq!(
        ::std::mem::size_of::<InterruptContext>(),
        736usize,
        concat!("Size of: ", stringify!(InterruptContext))
    );
    assert_eq!(
        ::std::mem::align_of::<InterruptContext>(),
        8usize,
        concat!("Alignment of ", stringify!(InterruptContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).cr2 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).ds as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).fxsave as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(fxsave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>()))._check as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(_check)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).cr8 as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(cr8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).r15 as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).r14 as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).r13 as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).r12 as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).r11 as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).r10 as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).r9 as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).r8 as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).rbp as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).rdi as *const _ as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).rsi as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).rdx as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).rcx as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).rbx as *const _ as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).rax as *const _ as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<InterruptContext>())).interruptNumber as *const _ as usize
        },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(interruptNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).errorCode as *const _ as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).rip as *const _ as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).cs as *const _ as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).flags as *const _ as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).rsp as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InterruptContext>())).ss as *const _ as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(InterruptContext),
            "::",
            stringify!(ss)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MSIHandler {
    pub callback: KIRQHandler,
    pub context: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MSIHandler() {
    assert_eq!(
        ::std::mem::size_of::<MSIHandler>(),
        16usize,
        concat!("Size of: ", stringify!(MSIHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<MSIHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(MSIHandler))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MSIHandler>())).callback as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MSIHandler),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MSIHandler>())).context as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MSIHandler),
            "::",
            stringify!(context)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRQHandler {
    pub callback: KIRQHandler,
    pub context: *mut ::std::os::raw::c_void,
    pub line: isize,
    pub pciDevice: *mut KPCIDevice,
    pub cOwnerName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_IRQHandler() {
    assert_eq!(
        ::std::mem::size_of::<IRQHandler>(),
        40usize,
        concat!("Size of: ", stringify!(IRQHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<IRQHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(IRQHandler))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IRQHandler>())).callback as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IRQHandler),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IRQHandler>())).context as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IRQHandler),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IRQHandler>())).line as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IRQHandler),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IRQHandler>())).pciDevice as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IRQHandler),
            "::",
            stringify!(pciDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IRQHandler>())).cOwnerName as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IRQHandler),
            "::",
            stringify!(cOwnerName)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZL20exceptionInformation"]
    pub static exceptionInformation: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    pub static mut tlbShootdownVirtualAddress: usize;
}
extern "C" {
    pub static mut tlbShootdownPageCount: size_t;
}
pub type CallFunctionOnAllProcessorsCallbackFunction =
    ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut callFunctionOnAllProcessorsCallback: CallFunctionOnAllProcessorsCallbackFunction;
}
extern "C" {
    pub static mut callFunctionOnAllProcessorsRemaining: usize;
}
extern "C" {
    pub static mut pciConfigSpinlock: KSpinlock;
}
extern "C" {
    pub static mut ipiLock: KSpinlock;
}
extern "C" {
    #[link_name = "\u{1}_Z17LapicReadRegisterj"]
    pub fn LapicReadRegister(reg: u32) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_Z18LapicWriteRegisterjj"]
    pub fn LapicWriteRegister(reg: u32, value: u32);
}
extern "C" {
    #[link_name = "\u{1}_Z14LapicNextTimerm"]
    pub fn LapicNextTimer(ms: size_t);
}
extern "C" {
    #[link_name = "\u{1}_Z19LapicEndOfInterruptv"]
    pub fn LapicEndOfInterrupt();
}
extern "C" {
    #[link_name = "\u{1}_Z16ProcessorSendIPImbi"]
    pub fn ProcessorSendIPI(
        interrupt: usize,
        nmi: bool,
        processorID: ::std::os::raw::c_int,
    ) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_Z31ArchCallFunctionOnAllProcessorsPFvvEb"]
    pub fn ArchCallFunctionOnAllProcessors(
        callback: CallFunctionOnAllProcessorsCallbackFunction,
        includingThisProcessor: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z20TLBShootdownCallbackv"]
    pub fn TLBShootdownCallback();
}
extern "C" {
    pub static mut pciIRQLines: [[u8; 4usize]; 256usize];
}
extern "C" {
    pub static mut msiHandlers: [MSIHandler; 64usize];
}
extern "C" {
    pub static mut irqHandlers: [IRQHandler; 64usize];
}
extern "C" {
    pub static mut irqHandlersLock: KSpinlock;
}
extern "C" {
    pub static mut timeStampCounterSynchronizationValue: u64;
}
extern "C" {
    pub static mut physicalMemoryRegions: *mut PhysicalMemoryRegion;
}
extern "C" {
    pub static mut physicalMemoryRegionsCount: size_t;
}
extern "C" {
    pub static mut physicalMemoryRegionsPagesCount: size_t;
}
extern "C" {
    pub static mut physicalMemoryOriginalPagesCount: size_t;
}
extern "C" {
    pub static mut physicalMemoryRegionsIndex: size_t;
}
extern "C" {
    pub static mut physicalMemoryHighest: usize;
}
extern "C" {
    pub static mut installationID: EsUniqueIdentifier;
}
extern "C" {
    pub static mut bootloaderID: u32;
}
extern "C" {
    pub static mut bootloaderInformationOffset: usize;
}
extern "C" {
    pub static mut coreL1Commit: [u8; 256usize];
}
extern "C" {
    #[link_name = "\u{1}_Z13EarlyDelay1Msv"]
    pub fn EarlyDelay1Ms();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EsSpinlock {
    pub state: u8,
}
#[test]
fn bindgen_test_layout_EsSpinlock() {
    assert_eq!(
        ::std::mem::size_of::<EsSpinlock>(),
        1usize,
        concat!("Size of: ", stringify!(EsSpinlock))
    );
    assert_eq!(
        ::std::mem::align_of::<EsSpinlock>(),
        1usize,
        concat!("Alignment of ", stringify!(EsSpinlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EsSpinlock>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EsSpinlock),
            "::",
            stringify!(state)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_Z17EsSpinlockAcquireP10EsSpinlock"]
    pub fn EsSpinlockAcquire(spinlock: *mut EsSpinlock);
}
extern "C" {
    #[link_name = "\u{1}_Z17EsSpinlockReleaseP10EsSpinlock"]
    pub fn EsSpinlockRelease(spinlock: *mut EsSpinlock);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RNGState {
    pub s: [u64; 4usize],
    pub lock: EsSpinlock,
}
#[test]
fn bindgen_test_layout_RNGState() {
    assert_eq!(
        ::std::mem::size_of::<RNGState>(),
        40usize,
        concat!("Size of: ", stringify!(RNGState))
    );
    assert_eq!(
        ::std::mem::align_of::<RNGState>(),
        8usize,
        concat!("Alignment of ", stringify!(RNGState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RNGState>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RNGState),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RNGState>())).lock as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RNGState),
            "::",
            stringify!(lock)
        )
    );
}
extern "C" {
    pub static mut rngState: RNGState;
}
extern "C" {
    #[link_name = "\u{1}_Z18EsRandomAddEntropym"]
    pub fn EsRandomAddEntropy(x: u64);
}
extern "C" {
    pub static mut timeStampTicksPerMs: u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NewProcessorStorage {
    pub local: *mut CPULocalStorage,
    pub gdt: *mut u32,
}
#[test]
fn bindgen_test_layout_NewProcessorStorage() {
    assert_eq!(
        ::std::mem::size_of::<NewProcessorStorage>(),
        16usize,
        concat!("Size of: ", stringify!(NewProcessorStorage))
    );
    assert_eq!(
        ::std::mem::align_of::<NewProcessorStorage>(),
        8usize,
        concat!("Alignment of ", stringify!(NewProcessorStorage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NewProcessorStorage>())).local as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NewProcessorStorage),
            "::",
            stringify!(local)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NewProcessorStorage>())).gdt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NewProcessorStorage),
            "::",
            stringify!(gdt)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_Z27AllocateNewProcessorStorageP7ArchCPU"]
    pub fn AllocateNewProcessorStorage(archCPU: *mut ArchCPU) -> NewProcessorStorage;
}
extern "C" {
    #[link_name = "\u{1}_Z20ArchGetTimeFromPITMsv"]
    pub fn ArchGetTimeFromPITMs() -> u64;
}
extern "C" {
    #[link_name = "\u{1}_Z11ThreadPauseP6Threadb"]
    pub fn ThreadPause(thread: *mut Thread, resume: bool);
}
extern "C" {
    #[link_name = "\u{1}_Z12ProcessPauseP7Processb"]
    pub fn ProcessPause(process: *mut Process, resume: bool);
}
extern "C" {
    #[link_name = "\u{1}_Z29MMPhysicalInsertFreePagesNextm"]
    pub fn MMPhysicalInsertFreePagesNext(page: usize);
}
extern "C" {
    #[link_name = "\u{1}_Z20ProcessorOut8Delayedth"]
    pub fn ProcessorOut8Delayed(port: u16, value: u8);
}
extern "C" {
    #[link_name = "\u{1}_Z18ContextSanityCheckP16InterruptContext"]
    pub fn ContextSanityCheck(context: *mut InterruptContext);
}
extern "C" {
    #[link_name = "\u{1}_Z15AsyncTaskThreadv"]
    pub fn AsyncTaskThread();
}
extern "C" {
    pub static mut debugKeyPressed: bool;
}
extern "C" {
    #[link_name = "\u{1}_Z23DriversDumpStateRecurseP7KDevice"]
    pub fn DriversDumpStateRecurse(device: *mut KDevice);
}
extern "C" {
    #[link_name = "\u{1}_Z16DriversDumpStatev"]
    pub fn DriversDumpState();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KGraphicsTarget {
    pub _base: KDevice,
    pub screenWidth: size_t,
    pub screenHeight: size_t,
    pub reducedColors: bool,
    pub updateScreen: ::std::option::Option<
        unsafe extern "C" fn(
            source: *const u8,
            sourceWidth: u32,
            sourceHeight: u32,
            sourceStride: u32,
            destinationX: u32,
            destinationY: u32,
        ),
    >,
    pub debugPutBlock:
        ::std::option::Option<unsafe extern "C" fn(x: usize, y: usize, toggle: bool)>,
    pub debugClearScreen: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_KGraphicsTarget() {
    assert_eq!(
        ::std::mem::size_of::<KGraphicsTarget>(),
        128usize,
        concat!("Size of: ", stringify!(KGraphicsTarget))
    );
    assert_eq!(
        ::std::mem::align_of::<KGraphicsTarget>(),
        8usize,
        concat!("Alignment of ", stringify!(KGraphicsTarget))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KGraphicsTarget>())).screenWidth as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(KGraphicsTarget),
            "::",
            stringify!(screenWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KGraphicsTarget>())).screenHeight as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(KGraphicsTarget),
            "::",
            stringify!(screenHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KGraphicsTarget>())).reducedColors as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(KGraphicsTarget),
            "::",
            stringify!(reducedColors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KGraphicsTarget>())).updateScreen as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(KGraphicsTarget),
            "::",
            stringify!(updateScreen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KGraphicsTarget>())).debugPutBlock as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(KGraphicsTarget),
            "::",
            stringify!(debugPutBlock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<KGraphicsTarget>())).debugClearScreen as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(KGraphicsTarget),
            "::",
            stringify!(debugClearScreen)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Graphics {
    pub target: *mut KGraphicsTarget,
    pub width: size_t,
    pub height: size_t,
    pub frameBuffer: Surface,
    pub debuggerActive: bool,
    pub totalSurfaceBytes: size_t,
}
#[test]
fn bindgen_test_layout_Graphics() {
    assert_eq!(
        ::std::mem::size_of::<Graphics>(),
        80usize,
        concat!("Size of: ", stringify!(Graphics))
    );
    assert_eq!(
        ::std::mem::align_of::<Graphics>(),
        8usize,
        concat!("Alignment of ", stringify!(Graphics))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Graphics>())).target as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Graphics),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Graphics>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Graphics),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Graphics>())).height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Graphics),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Graphics>())).frameBuffer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Graphics),
            "::",
            stringify!(frameBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Graphics>())).debuggerActive as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Graphics),
            "::",
            stringify!(debuggerActive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Graphics>())).totalSurfaceBytes as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Graphics),
            "::",
            stringify!(totalSurfaceBytes)
        )
    );
}
extern "C" {
    pub static mut graphics: Graphics;
}
extern "C" {
    pub static mut debugRows: size_t;
}
extern "C" {
    pub static mut debugColumns: size_t;
}
extern "C" {
    pub static mut debugCurrentRow: size_t;
}
extern "C" {
    pub static mut debugCurrentColumn: size_t;
}
pub const printToDebugger: bool = false;
pub const terminalPosition: usize = 80;
extern "C" {
    pub static mut kernelLog: [::std::os::raw::c_char; 262144usize];
}
extern "C" {
    pub static mut kernelLogPosition: usize;
}
extern "C" {
    pub static mut terminalLock: KSpinlock;
}
extern "C" {
    pub static mut printLock: KSpinlock;
}
extern "C" {
    #[link_name = "\u{1}_ZL7vgaFont"]
    pub static vgaFont: [u64; 256usize];
}
pub type FormatCallback = ::std::option::Option<
    unsafe extern "C" fn(character: ::std::os::raw::c_int, data: *mut ::std::os::raw::c_void),
>;
pub const interfaceString_CommonErrorTitle: &'static [u8; 6usize] = b"Error\0";
pub const interfaceString_CommonOK: &'static [u8; 3usize] = b"OK\0";
pub const interfaceString_CommonCancel: &'static [u8; 7usize] = b"Cancel\0";
pub const interfaceString_CommonUndo: &'static [u8; 5usize] = b"Undo\0";
pub const interfaceString_CommonRedo: &'static [u8; 5usize] = b"Redo\0";
pub const interfaceString_CommonClipboardCut: &'static [u8; 4usize] = b"Cut\0";
pub const interfaceString_CommonClipboardCopy: &'static [u8; 5usize] = b"Copy\0";
pub const interfaceString_CommonClipboardPaste: &'static [u8; 6usize] = b"Paste\0";
pub const interfaceString_CommonSelectionSelectAll: &'static [u8; 11usize] = b"Select all\0";
pub const interfaceString_CommonSelectionDelete: &'static [u8; 7usize] = b"Delete\0";
pub const interfaceString_CommonFormatPopup: &'static [u8; 7usize] = b"Format\0";
pub const interfaceString_CommonFormatSize: &'static [u8; 11usize] = b"Text size:\0";
pub const interfaceString_CommonFormatLanguage: &'static [u8; 10usize] = b"Language:\0";
pub const interfaceString_CommonFormatPlainText: &'static [u8; 11usize] = b"Plain text\0";
pub const interfaceString_CommonFileMenu: &'static [u8; 5usize] = b"File\0";
pub const interfaceString_CommonFileSave: &'static [u8; 5usize] = b"Save\0";
pub const interfaceString_CommonFileShare: &'static [u8; 6usize] = b"Share\0";
pub const interfaceString_CommonFileMakeCopy: &'static [u8; 12usize] = b"Make a copy\0";
pub const interfaceString_CommonFileVersionHistory: &'static [u8; 19usize] =
    b"Version history\xE2\x80\xA6\0";
pub const interfaceString_CommonFileShowInFileManager: &'static [u8; 24usize] =
    b"Show in File Manager\xE2\x80\xA6\0";
pub const interfaceString_CommonFileMenuFileSize: &'static [u8; 6usize] = b"Size:\0";
pub const interfaceString_CommonFileMenuFileLocation: &'static [u8; 7usize] = b"Where:\0";
pub const interfaceString_CommonFileUnchanged: &'static [u8; 21usize] = b"(All changes saved.)\0";
pub const interfaceString_CommonZoomIn: &'static [u8; 8usize] = b"Zoom in\0";
pub const interfaceString_CommonZoomOut: &'static [u8; 9usize] = b"Zoom out\0";
pub const interfaceString_CommonSearchOpen: &'static [u8; 7usize] = b"Search\0";
pub const interfaceString_CommonSearchNoMatches: &'static [u8; 18usize] = b"No matches found.\0";
pub const interfaceString_CommonSearchNext: &'static [u8; 10usize] = b"Find next\0";
pub const interfaceString_CommonSearchPrevious: &'static [u8; 14usize] = b"Find previous\0";
pub const interfaceString_CommonSearchPrompt: &'static [u8; 12usize] = b"Search for:\0";
pub const interfaceString_CommonSearchPrompt2: &'static [u8; 26usize] =
    b"Enter text to search for.\0";
pub const interfaceString_CommonItemFolder: &'static [u8; 7usize] = b"Folder\0";
pub const interfaceString_CommonItemFile: &'static [u8; 5usize] = b"File\0";
pub const interfaceString_CommonSortAscending: &'static [u8; 15usize] = b"Sort ascending\0";
pub const interfaceString_CommonSortDescending: &'static [u8; 16usize] = b"Sort descending\0";
pub const interfaceString_CommonDriveHDD: &'static [u8; 10usize] = b"Hard disk\0";
pub const interfaceString_CommonDriveSSD: &'static [u8; 4usize] = b"SSD\0";
pub const interfaceString_CommonDriveCDROM: &'static [u8; 7usize] = b"CD-ROM\0";
pub const interfaceString_CommonDriveUSBMassStorage: &'static [u8; 10usize] = b"USB drive\0";
pub const interfaceString_CommonSystemBrand: &'static [u8; 19usize] = b"Essence Alpha v0.1\0";
pub const interfaceString_CommonListViewType: &'static [u8; 10usize] = b"List view\0";
pub const interfaceString_CommonListViewTypeThumbnails: &'static [u8; 11usize] = b"Thumbnails\0";
pub const interfaceString_CommonListViewTypeTiles: &'static [u8; 6usize] = b"Tiles\0";
pub const interfaceString_CommonListViewTypeDetails: &'static [u8; 8usize] = b"Details\0";
pub const interfaceString_CommonAnnouncementCopied: &'static [u8; 7usize] = b"Copied\0";
pub const interfaceString_CommonAnnouncementCut: &'static [u8; 4usize] = b"Cut\0";
pub const interfaceString_CommonAnnouncementTextCopied: &'static [u8; 12usize] = b"Text copied\0";
pub const interfaceString_CommonAnnouncementCopyErrorResources: &'static [u8; 38usize] =
    b"There's not enough space to copy this\0";
pub const interfaceString_CommonAnnouncementCopyErrorOther: &'static [u8; 15usize] =
    b"Could not copy\0";
pub const interfaceString_CommonAnnouncementPasteErrorOther: &'static [u8; 16usize] =
    b"Could not paste\0";
pub const interfaceString_CommonEmpty: &'static [u8; 6usize] = b"empty\0";
pub const interfaceString_CommonUnitPercent: &'static [u8; 2usize] = b"%\0";
pub const interfaceString_CommonUnitBytes: &'static [u8; 3usize] = b" B\0";
pub const interfaceString_CommonUnitKilobytes: &'static [u8; 4usize] = b" KB\0";
pub const interfaceString_CommonUnitMegabytes: &'static [u8; 4usize] = b" MB\0";
pub const interfaceString_CommonUnitGigabytes: &'static [u8; 4usize] = b" GB\0";
pub const interfaceString_CommonUnitMilliseconds: &'static [u8; 4usize] = b" ms\0";
pub const interfaceString_DesktopNewTabTitle: &'static [u8; 8usize] = b"New Tab\0";
pub const interfaceString_DesktopShutdownTitle: &'static [u8; 10usize] = b"Shut Down\0";
pub const interfaceString_DesktopShutdownAction: &'static [u8; 10usize] = b"Shut down\0";
pub const interfaceString_DesktopRestartAction: &'static [u8; 8usize] = b"Restart\0";
pub const interfaceString_DesktopForceQuit: &'static [u8; 11usize] = b"Force quit\0";
pub const interfaceString_DesktopCrashedApplication : & 'static [u8 ; 101usize] = b"The application has crashed. If you're a developer, more information is available in System Monitor.\0" ;
pub const interfaceString_DesktopNoSuchApplication: &'static [u8; 73usize] =
    b"The requested application could not found. It may have been uninstalled.\0";
pub const interfaceString_DesktopApplicationStartupError : & 'static [u8 ; 135usize] = b"The requested application could not be started. Your system may be low on resources, or the application files may have been corrupted.\0" ;
pub const interfaceString_DesktopNotResponding : & 'static [u8 ; 94usize] = b"The application is not responding.\nIf you choose to force quit, any unsaved data may be lost.\0" ;
pub const interfaceString_DesktopConfirmShutdown: &'static [u8; 82usize] =
    b"Are you sure you want to turn off your computer? All applications will be closed.\0";
pub const interfaceString_DesktopCloseTab: &'static [u8; 10usize] = b"Close tab\0";
pub const interfaceString_DesktopMoveTabToNewWindow: &'static [u8; 23usize] =
    b"Move tab to new window\0";
pub const interfaceString_DesktopMoveTabToNewWindowSplitLeft: &'static [u8; 27usize] =
    b"Move tab to left of screen\0";
pub const interfaceString_DesktopMoveTabToNewWindowSplitRight: &'static [u8; 28usize] =
    b"Move tab to right of screen\0";
pub const interfaceString_DesktopInspectUI: &'static [u8; 11usize] = b"Inspect UI\0";
pub const interfaceString_DesktopCloseWindow: &'static [u8; 13usize] = b"Close window\0";
pub const interfaceString_DesktopCloseAllTabs: &'static [u8; 15usize] = b"Close all tabs\0";
pub const interfaceString_DesktopMaximiseWindow: &'static [u8; 12usize] = b"Fill screen\0";
pub const interfaceString_DesktopRestoreWindow: &'static [u8; 17usize] = b"Restore position\0";
pub const interfaceString_DesktopMinimiseWindow: &'static [u8; 5usize] = b"Hide\0";
pub const interfaceString_DesktopCenterWindow: &'static [u8; 17usize] = b"Center in screen\0";
pub const interfaceString_DesktopSnapWindowLeft: &'static [u8; 18usize] = b"Move to left side\0";
pub const interfaceString_DesktopSnapWindowRight: &'static [u8; 19usize] = b"Move to right side\0";
pub const interfaceString_DesktopSettingsApplication: &'static [u8; 9usize] = b"Settings\0";
pub const interfaceString_DesktopSettingsTitle: &'static [u8; 9usize] = b"Settings\0";
pub const interfaceString_DesktopSettingsBackButton: &'static [u8; 13usize] = b"All settings\0";
pub const interfaceString_DesktopSettingsUndoButton: &'static [u8; 13usize] = b"Undo changes\0";
pub const interfaceString_DesktopSettingsAccessibility: &'static [u8; 14usize] = b"Accessibility\0";
pub const interfaceString_DesktopSettingsApplications: &'static [u8; 13usize] = b"Applications\0";
pub const interfaceString_DesktopSettingsDateAndTime: &'static [u8; 14usize] = b"Date and time\0";
pub const interfaceString_DesktopSettingsDevices: &'static [u8; 8usize] = b"Devices\0";
pub const interfaceString_DesktopSettingsDisplay: &'static [u8; 8usize] = b"Display\0";
pub const interfaceString_DesktopSettingsKeyboard: &'static [u8; 9usize] = b"Keyboard\0";
pub const interfaceString_DesktopSettingsLocalisation: &'static [u8; 13usize] = b"Localisation\0";
pub const interfaceString_DesktopSettingsMouse: &'static [u8; 6usize] = b"Mouse\0";
pub const interfaceString_DesktopSettingsNetwork: &'static [u8; 8usize] = b"Network\0";
pub const interfaceString_DesktopSettingsPower: &'static [u8; 6usize] = b"Power\0";
pub const interfaceString_DesktopSettingsSound: &'static [u8; 6usize] = b"Sound\0";
pub const interfaceString_DesktopSettingsTheme: &'static [u8; 6usize] = b"Theme\0";
pub const interfaceString_DesktopSettingsKeyboardKeyRepeatDelay: &'static [u8; 18usize] =
    b"Key repeat delay:\0";
pub const interfaceString_DesktopSettingsKeyboardKeyRepeatRate: &'static [u8; 17usize] =
    b"Key repeat rate:\0";
pub const interfaceString_DesktopSettingsKeyboardCaretBlinkRate: &'static [u8; 18usize] =
    b"Caret blink rate:\0";
pub const interfaceString_DesktopSettingsKeyboardTestTextboxIntroduction: &'static [u8; 40usize] =
    b"Try your settings in the textbox below:\0";
pub const interfaceString_DesktopSettingsKeyboardUseSmartQuotes: &'static [u8; 29usize] =
    b"Use smart quotes when typing\0";
pub const interfaceString_DesktopSettingsKeyboardLayout: &'static [u8; 17usize] =
    b"Keyboard layout:\0";
pub const interfaceString_DesktopSettingsMouseDoubleClickSpeed: &'static [u8; 19usize] =
    b"Double click time:\0";
pub const interfaceString_DesktopSettingsMouseSpeed: &'static [u8; 23usize] =
    b"Cursor movement speed:\0";
pub const interfaceString_DesktopSettingsMouseCursorTrails: &'static [u8; 20usize] =
    b"Cursor trail count:\0";
pub const interfaceString_DesktopSettingsMouseLinesPerScrollNotch: &'static [u8; 33usize] =
    b"Lines to scroll per wheel notch:\0";
pub const interfaceString_DesktopSettingsMouseSwapLeftAndRightButtons: &'static [u8; 28usize] =
    b"Swap left and right buttons\0";
pub const interfaceString_DesktopSettingsMouseShowShadow: &'static [u8; 25usize] =
    b"Show shadow below cursor\0";
pub const interfaceString_DesktopSettingsMouseLocateCursorOnCtrl: &'static [u8; 47usize] =
    b"Highlight cursor location when Ctrl is pressed\0";
pub const interfaceString_DesktopSettingsMouseTestDoubleClickIntroduction : & 'static [u8 ; 112usize] = b"Double click the circle below to try your setting. If it does not change color, increase the double click time.\0" ;
pub const interfaceString_DesktopSettingsMouseUseAcceleration: &'static [u8; 47usize] =
    b"Move cursor faster when mouse is moved quickly\0";
pub const interfaceString_DesktopSettingsMouseSlowOnAlt: &'static [u8; 36usize] =
    b"Move cursor slower when Alt is held\0";
pub const interfaceString_DesktopSettingsMouseSpeedSlow: &'static [u8; 5usize] = b"Slow\0";
pub const interfaceString_DesktopSettingsMouseSpeedFast: &'static [u8; 5usize] = b"Fast\0";
pub const interfaceString_DesktopSettingsMouseCursorTrailsNone: &'static [u8; 5usize] = b"None\0";
pub const interfaceString_DesktopSettingsMouseCursorTrailsMany: &'static [u8; 5usize] = b"Many\0";
pub const interfaceString_DesktopSettingsDisplayUIScale: &'static [u8; 17usize] =
    b"Interface scale:\0";
pub const interfaceString_DesktopSettingsThemeWindowColor: &'static [u8; 14usize] =
    b"Window color:\0";
pub const interfaceString_DesktopSettingsThemeEnableHoverState: &'static [u8; 38usize] =
    b"Highlight the item the cursor is over\0";
pub const interfaceString_DesktopSettingsThemeEnableAnimations: &'static [u8; 27usize] =
    b"Animate the user interface\0";
pub const interfaceString_DesktopSettingsThemeWallpaper: &'static [u8; 10usize] = b"Wallpaper\0";
pub const interfaceString_FileCannotSave: &'static [u8; 28usize] = b"The document was not saved.\0";
pub const interfaceString_FileCannotOpen: &'static [u8; 30usize] =
    b"The file could not be opened.\0";
pub const interfaceString_FileCannotRename: &'static [u8; 31usize] =
    b"The file could not be renamed.\0";
pub const interfaceString_FileRenameSuccess: &'static [u8; 8usize] = b"Renamed\0";
pub const interfaceString_FileSaveErrorFileDeleted: &'static [u8; 38usize] =
    b"Another application deleted the file.\0";
pub const interfaceString_FileSaveErrorCorrupt: &'static [u8; 56usize] =
    b"The file has been corrupted, and it cannot be modified.\0";
pub const interfaceString_FileSaveErrorDrive: &'static [u8; 55usize] =
    b"The drive containing the file was unable to modify it.\0";
pub const interfaceString_FileSaveErrorTooLarge: &'static [u8; 70usize] =
    b"The drive does not support files large enough to store this document.\0";
pub const interfaceString_FileSaveErrorConcurrentAccess: &'static [u8; 43usize] =
    b"Another application is modifying the file.\0";
pub const interfaceString_FileSaveErrorDriveFull: &'static [u8; 61usize] =
    b"The drive is full. Try deleting some files to free up space.\0";
pub const interfaceString_FileSaveErrorResourcesLow: &'static [u8; 70usize] =
    b"The system is low on resources. Close some applcations and try again.\0";
pub const interfaceString_FileSaveErrorAlreadyExists: &'static [u8; 56usize] =
    b"There is already a file called \xE2\x80\x9C%s\xE2\x80\x9D in this folder.\0";
pub const interfaceString_FileSaveErrorTooManyFiles: &'static [u8; 43usize] =
    b"Too many files already have the same name.\0";
pub const interfaceString_FileSaveErrorUnknown: &'static [u8; 51usize] =
    b"An unknown error occurred. Please try again later.\0";
pub const interfaceString_FileLoadErrorCorrupt: &'static [u8; 54usize] =
    b"The file has been corrupted, and it cannot be opened.\0";
pub const interfaceString_FileLoadErrorDrive: &'static [u8; 65usize] =
    b"The drive containing the file was unable to access its contents.\0";
pub const interfaceString_FileLoadErrorResourcesLow: &'static [u8; 70usize] =
    b"The system is low on resources. Close some applcations and try again.\0";
pub const interfaceString_FileLoadErrorUnknown: &'static [u8; 51usize] =
    b"An unknown error occurred. Please try again later.\0";
pub const interfaceString_FileCloseWithModificationsTitle: &'static [u8; 35usize] =
    b"Do you want to save this document?\0";
pub const interfaceString_FileCloseWithModificationsContent: &'static [u8; 67usize] =
    b"You need to save your changes to \xE2\x80\x9C%s\xE2\x80\x9D before you can close it.\0";
pub const interfaceString_FileCloseWithModificationsSave: &'static [u8; 15usize] =
    b"Save and close\0";
pub const interfaceString_FileCloseWithModificationsDelete: &'static [u8; 8usize] = b"Discard\0";
pub const interfaceString_FileCloseNewTitle: &'static [u8; 35usize] =
    b"Do you want to keep this document?\0";
pub const interfaceString_FileCloseNewContent: &'static [u8; 51usize] =
    b"You need to save it before you can close \xE2\x80\x9C%s\xE2\x80\x9D.\0";
pub const interfaceString_FileCloseNewName: &'static [u8; 6usize] = b"Name:\0";
pub const interfaceString_ImageEditorToolBrush: &'static [u8; 6usize] = b"Brush\0";
pub const interfaceString_ImageEditorToolFill: &'static [u8; 5usize] = b"Fill\0";
pub const interfaceString_ImageEditorToolRectangle: &'static [u8; 10usize] = b"Rectangle\0";
pub const interfaceString_ImageEditorToolSelect: &'static [u8; 7usize] = b"Select\0";
pub const interfaceString_ImageEditorToolText: &'static [u8; 5usize] = b"Text\0";
pub const interfaceString_ImageEditorCanvasSize: &'static [u8; 12usize] = b"Canvas size\0";
pub const interfaceString_ImageEditorPropertyWidth: &'static [u8; 7usize] = b"Width:\0";
pub const interfaceString_ImageEditorPropertyHeight: &'static [u8; 8usize] = b"Height:\0";
pub const interfaceString_ImageEditorPropertyColor: &'static [u8; 7usize] = b"Color:\0";
pub const interfaceString_ImageEditorPropertyBrushSize: &'static [u8; 12usize] = b"Brush size:\0";
pub const interfaceString_ImageEditorImageTransformations: &'static [u8; 16usize] =
    b"Transform image\0";
pub const interfaceString_ImageEditorRotateLeft: &'static [u8; 12usize] = b"Rotate left\0";
pub const interfaceString_ImageEditorRotateRight: &'static [u8; 13usize] = b"Rotate right\0";
pub const interfaceString_ImageEditorFlipHorizontally: &'static [u8; 18usize] =
    b"Flip horizontally\0";
pub const interfaceString_ImageEditorFlipVertically: &'static [u8; 16usize] = b"Flip vertically\0";
pub const interfaceString_ImageEditorImage: &'static [u8; 6usize] = b"Image\0";
pub const interfaceString_ImageEditorPickTool: &'static [u8; 10usize] = b"Pick tool\0";
pub const interfaceString_ImageEditorUnsupportedFormat: &'static [u8; 80usize] =
    b"The image is in an unsupported format. Try opening it with another application.\0";
pub const interfaceString_ImageEditorNewFileName: &'static [u8; 13usize] = b"untitled.png\0";
pub const interfaceString_ImageEditorNewDocument: &'static [u8; 17usize] = b"New bitmap image\0";
pub const interfaceString_ImageEditorTitle: &'static [u8; 13usize] = b"Image Editor\0";
pub const interfaceString_TextEditorTitle: &'static [u8; 12usize] = b"Text Editor\0";
pub const interfaceString_TextEditorNewFileName: &'static [u8; 13usize] = b"untitled.txt\0";
pub const interfaceString_TextEditorNewDocument: &'static [u8; 18usize] = b"New text document\0";
pub const interfaceString_MarkdownViewerTitle: &'static [u8; 16usize] = b"Markdown Viewer\0";
pub const interfaceString_POSIXUnavailable : & 'static [u8 ; 119usize] = b"This application depends on the POSIX subsystem. To enable it, select \x07m]Flag.ENABLE_POSIX_SUBSYSTEM\x07] in \x07m]config\x07].\0" ;
pub const interfaceString_POSIXTitle: &'static [u8; 18usize] = b"POSIX Application\0";
pub const interfaceString_FontBookTitle: &'static [u8; 10usize] = b"Font Book\0";
pub const interfaceString_FontBookTextSize: &'static [u8; 11usize] = b"Text size:\0";
pub const interfaceString_FontBookPreviewText: &'static [u8; 14usize] = b"Preview text:\0";
pub const interfaceString_FontBookVariants: &'static [u8; 9usize] = b"Variants\0";
pub const interfaceString_FontBookPreviewTextDefault: &'static [u8; 30usize] =
    b"Looking for a change of mind.\0";
pub const interfaceString_FontBookPreviewTextLongDefault: &'static [u8; 38usize] =
    b"Sphinx of black quartz, judge my vow.\0";
pub const interfaceString_FontBookOpenFont: &'static [u8; 5usize] = b"Open\0";
pub const interfaceString_FontBookNavigationBack: &'static [u8; 18usize] = b"Back to all fonts\0";
pub const interfaceString_FontBookVariantNormal100: &'static [u8; 5usize] = b"Thin\0";
pub const interfaceString_FontBookVariantNormal200: &'static [u8; 12usize] = b"Extra light\0";
pub const interfaceString_FontBookVariantNormal300: &'static [u8; 6usize] = b"Light\0";
pub const interfaceString_FontBookVariantNormal400: &'static [u8; 7usize] = b"Normal\0";
pub const interfaceString_FontBookVariantNormal500: &'static [u8; 7usize] = b"Medium\0";
pub const interfaceString_FontBookVariantNormal600: &'static [u8; 10usize] = b"Semi bold\0";
pub const interfaceString_FontBookVariantNormal700: &'static [u8; 5usize] = b"Bold\0";
pub const interfaceString_FontBookVariantNormal800: &'static [u8; 11usize] = b"Extra bold\0";
pub const interfaceString_FontBookVariantNormal900: &'static [u8; 6usize] = b"Black\0";
pub const interfaceString_FontBookVariantItalic100: &'static [u8; 14usize] = b"Thin (italic)\0";
pub const interfaceString_FontBookVariantItalic200: &'static [u8; 21usize] =
    b"Extra light (italic)\0";
pub const interfaceString_FontBookVariantItalic300: &'static [u8; 15usize] = b"Light (italic)\0";
pub const interfaceString_FontBookVariantItalic400: &'static [u8; 16usize] = b"Normal (italic)\0";
pub const interfaceString_FontBookVariantItalic500: &'static [u8; 16usize] = b"Medium (italic)\0";
pub const interfaceString_FontBookVariantItalic600: &'static [u8; 19usize] =
    b"Semi bold (italic)\0";
pub const interfaceString_FontBookVariantItalic700: &'static [u8; 14usize] = b"Bold (italic)\0";
pub const interfaceString_FontBookVariantItalic800: &'static [u8; 20usize] =
    b"Extra bold (italic)\0";
pub const interfaceString_FontBookVariantItalic900: &'static [u8; 15usize] = b"Black (italic)\0";
pub const interfaceString_FileManagerOpenFolderError: &'static [u8; 32usize] =
    b"The folder could not be opened.\0";
pub const interfaceString_FileManagerNewFolderError: &'static [u8; 29usize] =
    b"Could not create the folder.\0";
pub const interfaceString_FileManagerRenameItemError: &'static [u8; 31usize] =
    b"The item could not be renamed.\0";
pub const interfaceString_FileManagerUnknownError: &'static [u8; 27usize] =
    b"An unknown error occurred.\0";
pub const interfaceString_FileManagerTitle: &'static [u8; 13usize] = b"File Manager\0";
pub const interfaceString_FileManagerRootFolder: &'static [u8; 9usize] = b"Computer\0";
pub const interfaceString_FileManagerColumnName: &'static [u8; 5usize] = b"Name\0";
pub const interfaceString_FileManagerColumnType: &'static [u8; 5usize] = b"Type\0";
pub const interfaceString_FileManagerColumnSize: &'static [u8; 5usize] = b"Size\0";
pub const interfaceString_FileManagerOpenFolderTask: &'static [u8; 18usize] =
    b"Opening folder\xE2\x80\xA6\0";
pub const interfaceString_FileManagerOpenFileError: &'static [u8; 30usize] =
    b"The file could not be opened.\0";
pub const interfaceString_FileManagerNoRegisteredApplicationsForFile: &'static [u8; 80usize] =
    b"None of the applications installed on this computer can open this type of file.\0";
pub const interfaceString_FileManagerFolderNamePrompt: &'static [u8; 13usize] = b"Folder name:\0";
pub const interfaceString_FileManagerNewFolderAction: &'static [u8; 7usize] = b"Create\0";
pub const interfaceString_FileManagerNewFolderTask: &'static [u8; 19usize] =
    b"Creating folder\xE2\x80\xA6\0";
pub const interfaceString_FileManagerRenameTitle: &'static [u8; 7usize] = b"Rename\0";
pub const interfaceString_FileManagerRenamePrompt: &'static [u8; 31usize] =
    b"Type the new name of the item:\0";
pub const interfaceString_FileManagerRenameAction: &'static [u8; 7usize] = b"Rename\0";
pub const interfaceString_FileManagerRenameTask: &'static [u8; 17usize] =
    b"Renaming item\xE2\x80\xA6\0";
pub const interfaceString_FileManagerEmptyBookmarkView: &'static [u8; 36usize] =
    b"Drag folders here to bookmark them.\0";
pub const interfaceString_FileManagerEmptyFolderView: &'static [u8; 43usize] =
    b"Drag items here to add them to the folder.\0";
pub const interfaceString_FileManagerNewFolderToolbarItem: &'static [u8; 11usize] = b"New folder\0";
pub const interfaceString_FileManagerNewFolderName: &'static [u8; 11usize] = b"New folder\0";
pub const interfaceString_FileManagerGenericError: &'static [u8; 48usize] =
    b"The cause of the error could not be identified.\0";
pub const interfaceString_FileManagerItemAlreadyExistsError: &'static [u8; 39usize] =
    b"The item already exists in the folder.\0";
pub const interfaceString_FileManagerItemDoesNotExistError: &'static [u8; 25usize] =
    b"The item does not exist.\0";
pub const interfaceString_FileManagerPermissionNotGrantedError: &'static [u8; 49usize] =
    b"You don't have permission to modify this folder.\0";
pub const interfaceString_FileManagerOngoingTaskDescription: &'static [u8; 26usize] =
    b"This shouldn't take long.\0";
pub const interfaceString_FileManagerPlacesDrives: &'static [u8; 7usize] = b"Drives\0";
pub const interfaceString_FileManagerPlacesBookmarks: &'static [u8; 10usize] = b"Bookmarks\0";
pub const interfaceString_FileManagerBookmarksAddHere: &'static [u8; 18usize] =
    b"Add bookmark here\0";
pub const interfaceString_FileManagerBookmarksRemoveHere: &'static [u8; 21usize] =
    b"Remove bookmark here\0";
pub const interfaceString_FileManagerDrivesPage: &'static [u8; 8usize] = b"Drives/\0";
pub const interfaceString_FileManagerInvalidPath: &'static [u8; 79usize] =
    b"The current path does not lead to a folder. It may have been deleted or moved.\0";
pub const interfaceString_FileManagerInvalidDrive: &'static [u8; 51usize] =
    b"The drive containing this folder was disconnected.\0";
pub const interfaceString_FileManagerRefresh: &'static [u8; 8usize] = b"Refresh\0";
pub const interfaceString_FileManagerListContextActions: &'static [u8; 8usize] = b"Actions\0";
pub const interfaceString_FileManagerCopyTask: &'static [u8; 11usize] = b"Copying\xE2\x80\xA6\0";
pub const interfaceString_FileManagerMoveTask: &'static [u8; 10usize] = b"Moving\xE2\x80\xA6\0";
pub const interfaceString_FileManagerGoBack: &'static [u8; 8usize] = b"Go back\0";
pub const interfaceString_FileManagerGoForwards: &'static [u8; 12usize] = b"Go forwards\0";
pub const interfaceString_FileManagerGoUp: &'static [u8; 24usize] = b"Go to containing folder\0";
pub const interfaceString_FileManagerFileOpenIn: &'static [u8; 25usize] =
    b"File is open in \xE2\x80\x9C%s\xE2\x80\x9D\0";
pub const interfaceString_Game2048Score: &'static [u8; 7usize] = b"Score:\0";
pub const interfaceString_Game2048Instructions : & 'static [u8 ; 136usize] = b"Use the \x07w6]arrow-keys\x07] to slide the tiles. When matching tiles touch, they \x07w6]merge\x07] into one. Try to create the number \x07w6]2048\x07]!\0" ;
pub const interfaceString_Game2048GameOver: &'static [u8; 10usize] = b"Game over\0";
pub const interfaceString_Game2048GameOverExplanation: &'static [u8; 31usize] =
    b"There are no valid moves left.\0";
pub const interfaceString_Game2048NewGame: &'static [u8; 9usize] = b"New game\0";
pub const interfaceString_Game2048HighScore: &'static [u8; 21usize] =
    b"High score: \x07w6]%d\x07]\0";
pub const interfaceString_Game2048NewHighScore: &'static [u8; 30usize] =
    b"You reached a new high score!\0";
pub const interfaceString_InstallerTitle: &'static [u8; 16usize] = b"Install Essence\0";
pub const interfaceString_InstallerDrivesList: &'static [u8; 32usize] =
    b"Select the drive to install on:\0";
pub const interfaceString_InstallerDrivesSelectHint: &'static [u8; 42usize] =
    b"Choose a drive from the list on the left.\0";
pub const interfaceString_InstallerDriveRemoved: &'static [u8; 28usize] =
    b"The drive was disconnected.\0";
pub const interfaceString_InstallerDriveReadOnly: &'static [u8; 67usize] =
    b"This drive is read-only. You cannot install Essence on this drive.\0";
pub const interfaceString_InstallerDriveNotEnoughSpace: &'static [u8; 58usize] =
    b"This drive does not have enough space to install Essence.\0";
pub const interfaceString_InstallerDriveCouldNotRead: &'static [u8; 66usize] =
    b"The drive could not be accessed. It may not be working correctly.\0";
pub const interfaceString_InstallerDriveAlreadyHasPartitions: &'static [u8; 76usize] =
    b"The drive already has data on it. You cannot install Essence on this drive.\0";
pub const interfaceString_InstallerDriveUnsupported: &'static [u8; 80usize] =
    b"This drive uses unsupported features. You cannot install Essence on this drive.\0";
pub const interfaceString_InstallerDriveOkay: &'static [u8; 40usize] =
    b"Essence can be installed on this drive.\0";
pub const interfaceString_InstallerInstall: &'static [u8; 8usize] = b"Install\0";
pub const interfaceString_InstallerViewLicenses: &'static [u8; 9usize] = b"Licenses\0";
pub const interfaceString_InstallerGoBack: &'static [u8; 5usize] = b"Back\0";
pub const interfaceString_InstallerFinish: &'static [u8; 7usize] = b"Finish\0";
pub const interfaceString_InstallerCustomizeOptions: &'static [u8; 25usize] =
    b"Customize your computer.\0";
pub const interfaceString_InstallerCustomizeOptionsHint: &'static [u8; 44usize] =
    b"More options will be available in Settings.\0";
pub const interfaceString_InstallerUserName: &'static [u8; 11usize] = b"User name:\0";
pub const interfaceString_InstallerTime: &'static [u8; 14usize] = b"Current time:\0";
pub const interfaceString_InstallerSystemFont: &'static [u8; 13usize] = b"System font:\0";
pub const interfaceString_InstallerFontDefault: &'static [u8; 8usize] = b"Default\0";
pub const interfaceString_InstallerProgressMessage: &'static [u8; 73usize] =
    b"Installing, please wait\xE2\x80\xA6\nDo not turn off your computer.\nProgress: \x07w6]\0";
pub const interfaceString_InstallerCompleteFromOther : & 'static [u8 ; 98usize] = b"Installation has completed successfully. Remove the installation disk, and restart your computer.\0" ;
pub const interfaceString_InstallerCompleteFromUSB : & 'static [u8 ; 101usize] = b"Installation has completed successfully. Disconnect the installation USB, and restart your computer.\0" ;
pub const interfaceString_InstallerVolumeLabel: &'static [u8; 11usize] = b"Essence HD\0";
pub const interfaceString_InstallerUseMBR: &'static [u8; 50usize] =
    b"Use legacy BIOS boot (select for older computers)\0";
pub const interfaceString_InstallerFailedArchiveCRCError : & 'static [u8 ; 96usize] = b"The installation data has been corrupted. Create a new installation USB or disk, and try again.\0" ;
pub const interfaceString_InstallerFailedGeneric : & 'static [u8 ; 132usize] = b"The installation could not complete. This likely means that the drive you selected is failing. Try installing on a different drive.\0" ;
pub const interfaceString_InstallerFailedResources : & 'static [u8 ; 98usize] = b"The installation could not complete. Your computer does not have enough memory to install Essence\0" ;
pub const interfaceString_InstallerNotSupported : & 'static [u8 ; 129usize] = b"Your computer does not meet the minimum system requirements to install Essence. Remove the installer, and restart your computer.\0" ;
extern "C" {
    #[link_name = "\u{1}_Z14_FormatIntegerPFviPvES_lib"]
    pub fn _FormatInteger(
        callback: FormatCallback,
        callbackData: *mut ::std::os::raw::c_void,
        value: ::std::os::raw::c_long,
        pad: ::std::os::raw::c_int,
        simple: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z22WriteCStringToCallbackPFviPvES_PKc"]
    pub fn WriteCStringToCallback(
        callback: FormatCallback,
        callbackData: *mut ::std::os::raw::c_void,
        cString: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z13_StringFormatPFviPvES_PKcP13__va_list_tag"]
    pub fn _StringFormat(
        callback: FormatCallback,
        callbackData: *mut ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
        arguments: *mut __va_list_tag,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z16StartDebugOutputv"]
    pub fn StartDebugOutput();
}
extern "C" {
    #[link_name = "\u{1}_Z19DebugWriteCharacterm"]
    pub fn DebugWriteCharacter(character: usize);
}
extern "C" {
    #[link_name = "\u{1}_Z21MMArchInvalidatePagesmm"]
    pub fn MMArchInvalidatePages(virtualAddressStart: usize, pageCount: usize);
}
extern "C" {
    #[link_name = "\u{1}_Z15MMUnmapFilePagem"]
    pub fn MMUnmapFilePage(frameNumber: usize) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z11__KernelLogPKcz"]
    pub fn __KernelLog(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "\u{1}_Z17ArchPCIReadConfighhhhi"]
    pub fn ArchPCIReadConfig(
        bus: u8,
        device: u8,
        function: u8,
        offset: u8,
        size: ::std::os::raw::c_int,
    ) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_Z9PCI_setupv"]
    pub fn PCI_setup();
}
extern "C" {
    pub fn KernelMain(a: usize);
}
extern "C" {
    pub fn KernelInitialise();
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[test]
fn __bindgen_test_layout_AVLTree_open0_MMRegion_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<AVLTree<MMRegion>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(AVLTree<MMRegion>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<AVLTree<MMRegion>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(AVLTree<MMRegion>)
        )
    );
}
#[test]
fn __bindgen_test_layout_AVLTree_open0_MMRegion_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<AVLTree<MMRegion>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(AVLTree<MMRegion>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<AVLTree<MMRegion>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(AVLTree<MMRegion>)
        )
    );
}
#[test]
fn __bindgen_test_layout_AVLTree_open0_MMRegion_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<AVLTree<MMRegion>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(AVLTree<MMRegion>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<AVLTree<MMRegion>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(AVLTree<MMRegion>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedList_open0_MMRegion_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<LinkedList<MMRegion>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedList<MMRegion>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedList<MMRegion>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedList<MMRegion>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedList_open0_Thread_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<LinkedList<Thread>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedList<Thread>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedList<Thread>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedList<Thread>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedList_open0_Thread_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<LinkedList<Thread>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedList<Thread>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedList<Thread>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedList<Thread>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedList_open0_Thread_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<LinkedList<Thread>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedList<Thread>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedList<Thread>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedList<Thread>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedItem_open0_Thread_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<LinkedItem<Thread>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedItem<Thread>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedItem<Thread>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedItem<Thread>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedItem_open0_Thread_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<LinkedItem<Thread>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedItem<Thread>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedItem<Thread>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedItem<Thread>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedItem_open0_Thread_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<LinkedItem<Thread>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedItem<Thread>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedItem<Thread>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedItem<Thread>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedItem_open0_Thread_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<LinkedItem<Thread>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedItem<Thread>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedItem<Thread>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedItem<Thread>)
        )
    );
}
#[test]
fn __bindgen_test_layout_AVLItem_open0_FSDirectoryEntry_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<AVLItem<FSDirectoryEntry>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(AVLItem<FSDirectoryEntry>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<AVLItem<FSDirectoryEntry>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(AVLItem<FSDirectoryEntry>)
        )
    );
}
#[test]
fn __bindgen_test_layout_AVLTree_open0_FSDirectoryEntry_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<AVLTree<FSDirectoryEntry>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(AVLTree<FSDirectoryEntry>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<AVLTree<FSDirectoryEntry>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(AVLTree<FSDirectoryEntry>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedList_open0_Thread_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<LinkedList<Thread>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedList<Thread>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedList<Thread>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedList<Thread>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedItem_open0_Process_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<LinkedItem<Process>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedItem<Process>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedItem<Process>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedItem<Process>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedItem_open0_KTimer_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<LinkedItem<KTimer>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedItem<KTimer>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedItem<KTimer>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedItem<KTimer>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedList_open0_Thread_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<LinkedList<Thread>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedList<Thread>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedList<Thread>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedList<Thread>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedList_open0_Thread_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<LinkedList<Thread>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedList<Thread>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedList<Thread>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedList<Thread>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedList_open0_Thread_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<LinkedList<Thread>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedList<Thread>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedList<Thread>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedList<Thread>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedList_open0_KTimer_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<LinkedList<KTimer>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedList<KTimer>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedList<KTimer>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedList<KTimer>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedList_open0_Thread_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<LinkedList<Thread>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedList<Thread>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedList<Thread>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedList<Thread>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedList_open0_Process_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<LinkedList<Process>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedList<Process>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedList<Process>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedList<Process>)
        )
    );
}
#[test]
fn __bindgen_test_layout_AVLItem_open0_MMRegion_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<AVLItem<MMRegion>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(AVLItem<MMRegion>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<AVLItem<MMRegion>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(AVLItem<MMRegion>)
        )
    );
}
#[test]
fn __bindgen_test_layout_AVLItem_open0_MMRegion_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<AVLItem<MMRegion>>(),
        64usize,
        concat!(
            "Size of template specialization: ",
            stringify!(AVLItem<MMRegion>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<AVLItem<MMRegion>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(AVLItem<MMRegion>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedItem_open0_MMRegion_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<LinkedItem<MMRegion>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedItem<MMRegion>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedItem<MMRegion>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedItem<MMRegion>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedItem_open0_MMSharedRegion_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<LinkedItem<MMSharedRegion>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedItem<MMSharedRegion>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedItem<MMSharedRegion>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedItem<MMSharedRegion>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedItem_open0_MMObjectCache_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<LinkedItem<MMObjectCache>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedItem<MMObjectCache>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedItem<MMObjectCache>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedItem<MMObjectCache>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedList_open0_MMObjectCache_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<LinkedList<MMObjectCache>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedList<MMObjectCache>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedList<MMObjectCache>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedList<MMObjectCache>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedItem_open0_CCActiveSection_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<LinkedItem<CCActiveSection>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedItem<CCActiveSection>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedItem<CCActiveSection>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedItem<CCActiveSection>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedList_open0_CCActiveSection_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<LinkedList<CCActiveSection>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedList<CCActiveSection>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedList<CCActiveSection>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedList<CCActiveSection>)
        )
    );
}
#[test]
fn __bindgen_test_layout_LinkedList_open0_CCActiveSection_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<LinkedList<CCActiveSection>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(LinkedList<CCActiveSection>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<LinkedList<CCActiveSection>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(LinkedList<CCActiveSection>)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetInterface {
    pub _address: u8,
}
